
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model ClientSolution
 * 
 */
export type ClientSolution = $Result.DefaultSelection<Prisma.$ClientSolutionPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model Opportunity
 * 
 */
export type Opportunity = $Result.DefaultSelection<Prisma.$OpportunityPayload>
/**
 * Model Proposal
 * 
 */
export type Proposal = $Result.DefaultSelection<Prisma.$ProposalPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectMilestone
 * 
 */
export type ProjectMilestone = $Result.DefaultSelection<Prisma.$ProjectMilestonePayload>
/**
 * Model ProjectTask
 * 
 */
export type ProjectTask = $Result.DefaultSelection<Prisma.$ProjectTaskPayload>
/**
 * Model ProjectMetric
 * 
 */
export type ProjectMetric = $Result.DefaultSelection<Prisma.$ProjectMetricPayload>
/**
 * Model AISolution
 * 
 */
export type AISolution = $Result.DefaultSelection<Prisma.$AISolutionPayload>
/**
 * Model AISolutionModule
 * 
 */
export type AISolutionModule = $Result.DefaultSelection<Prisma.$AISolutionModulePayload>
/**
 * Model Quote
 * 
 */
export type Quote = $Result.DefaultSelection<Prisma.$QuotePayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model TicketComment
 * 
 */
export type TicketComment = $Result.DefaultSelection<Prisma.$TicketCommentPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  SYSTEM_ADMIN: 'SYSTEM_ADMIN',
  SALES_DIRECTOR: 'SALES_DIRECTOR',
  SALES_REPRESENTATIVE: 'SALES_REPRESENTATIVE',
  PROJECT_DIRECTOR: 'PROJECT_DIRECTOR',
  AI_PROJECT_MANAGER: 'AI_PROJECT_MANAGER',
  AI_EXPERT: 'AI_EXPERT',
  CLIENT_ADMIN: 'CLIENT_ADMIN',
  CLIENT_USER: 'CLIENT_USER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ClientLifecycleStage: {
  PROSPECT: 'PROSPECT',
  ACTIVE_PROSPECT: 'ACTIVE_PROSPECT',
  ONBOARDING: 'ONBOARDING',
  IMPLEMENTATION: 'IMPLEMENTATION',
  OPTIMIZATION: 'OPTIMIZATION',
  RENEWAL: 'RENEWAL',
  EXPANSION: 'EXPANSION',
  INACTIVE: 'INACTIVE'
};

export type ClientLifecycleStage = (typeof ClientLifecycleStage)[keyof typeof ClientLifecycleStage]


export const LeadStatus: {
  NEW: 'NEW',
  CONTACTED: 'CONTACTED',
  QUALIFIED: 'QUALIFIED',
  UNQUALIFIED: 'UNQUALIFIED',
  CONVERTED: 'CONVERTED',
  LOST: 'LOST'
};

export type LeadStatus = (typeof LeadStatus)[keyof typeof LeadStatus]


export const OpportunityStage: {
  LEAD_INGESTION: 'LEAD_INGESTION',
  QUALIFICATION: 'QUALIFICATION',
  DISCOVERY: 'DISCOVERY',
  SOLUTION_DESIGN: 'SOLUTION_DESIGN',
  PROPOSAL: 'PROPOSAL',
  NEGOTIATION: 'NEGOTIATION',
  CLOSED_WON: 'CLOSED_WON',
  CLOSED_LOST: 'CLOSED_LOST'
};

export type OpportunityStage = (typeof OpportunityStage)[keyof typeof OpportunityStage]


export const ProjectStatus: {
  NOT_STARTED: 'NOT_STARTED',
  INITIATION: 'INITIATION',
  DISCOVERY: 'DISCOVERY',
  DESIGN: 'DESIGN',
  DEVELOPMENT: 'DEVELOPMENT',
  DEPLOYMENT: 'DEPLOYMENT',
  OPTIMIZATION: 'OPTIMIZATION',
  HANDOVER: 'HANDOVER',
  COMPLETED: 'COMPLETED',
  ON_HOLD: 'ON_HOLD',
  CANCELLED: 'CANCELLED'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const MilestoneStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  BLOCKED: 'BLOCKED',
  CANCELLED: 'CANCELLED'
};

export type MilestoneStatus = (typeof MilestoneStatus)[keyof typeof MilestoneStatus]


export const TaskStatus: {
  NOT_STARTED: 'NOT_STARTED',
  IN_PROGRESS: 'IN_PROGRESS',
  BLOCKED: 'BLOCKED',
  IN_REVIEW: 'IN_REVIEW',
  COMPLETE: 'COMPLETE'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const TicketType: {
  TECHNICAL_ISSUE: 'TECHNICAL_ISSUE',
  HOW_TO_QUESTION: 'HOW_TO_QUESTION',
  ENHANCEMENT_REQUEST: 'ENHANCEMENT_REQUEST',
  BILLING_INQUIRY: 'BILLING_INQUIRY'
};

export type TicketType = (typeof TicketType)[keyof typeof TicketType]


export const TicketSeverity: {
  CRITICAL: 'CRITICAL',
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW'
};

export type TicketSeverity = (typeof TicketSeverity)[keyof typeof TicketSeverity]


export const TicketStatus: {
  NEW: 'NEW',
  ASSIGNED: 'ASSIGNED',
  IN_PROGRESS: 'IN_PROGRESS',
  PENDING_CLIENT: 'PENDING_CLIENT',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ClientLifecycleStage = $Enums.ClientLifecycleStage

export const ClientLifecycleStage: typeof $Enums.ClientLifecycleStage

export type LeadStatus = $Enums.LeadStatus

export const LeadStatus: typeof $Enums.LeadStatus

export type OpportunityStage = $Enums.OpportunityStage

export const OpportunityStage: typeof $Enums.OpportunityStage

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type MilestoneStatus = $Enums.MilestoneStatus

export const MilestoneStatus: typeof $Enums.MilestoneStatus

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type TicketType = $Enums.TicketType

export const TicketType: typeof $Enums.TicketType

export type TicketSeverity = $Enums.TicketSeverity

export const TicketSeverity: typeof $Enums.TicketSeverity

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs>;

  /**
   * `prisma.clientSolution`: Exposes CRUD operations for the **ClientSolution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientSolutions
    * const clientSolutions = await prisma.clientSolution.findMany()
    * ```
    */
  get clientSolution(): Prisma.ClientSolutionDelegate<ExtArgs>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs>;

  /**
   * `prisma.opportunity`: Exposes CRUD operations for the **Opportunity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Opportunities
    * const opportunities = await prisma.opportunity.findMany()
    * ```
    */
  get opportunity(): Prisma.OpportunityDelegate<ExtArgs>;

  /**
   * `prisma.proposal`: Exposes CRUD operations for the **Proposal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proposals
    * const proposals = await prisma.proposal.findMany()
    * ```
    */
  get proposal(): Prisma.ProposalDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.projectMilestone`: Exposes CRUD operations for the **ProjectMilestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMilestones
    * const projectMilestones = await prisma.projectMilestone.findMany()
    * ```
    */
  get projectMilestone(): Prisma.ProjectMilestoneDelegate<ExtArgs>;

  /**
   * `prisma.projectTask`: Exposes CRUD operations for the **ProjectTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectTasks
    * const projectTasks = await prisma.projectTask.findMany()
    * ```
    */
  get projectTask(): Prisma.ProjectTaskDelegate<ExtArgs>;

  /**
   * `prisma.projectMetric`: Exposes CRUD operations for the **ProjectMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMetrics
    * const projectMetrics = await prisma.projectMetric.findMany()
    * ```
    */
  get projectMetric(): Prisma.ProjectMetricDelegate<ExtArgs>;

  /**
   * `prisma.aISolution`: Exposes CRUD operations for the **AISolution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AISolutions
    * const aISolutions = await prisma.aISolution.findMany()
    * ```
    */
  get aISolution(): Prisma.AISolutionDelegate<ExtArgs>;

  /**
   * `prisma.aISolutionModule`: Exposes CRUD operations for the **AISolutionModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AISolutionModules
    * const aISolutionModules = await prisma.aISolutionModule.findMany()
    * ```
    */
  get aISolutionModule(): Prisma.AISolutionModuleDelegate<ExtArgs>;

  /**
   * `prisma.quote`: Exposes CRUD operations for the **Quote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotes
    * const quotes = await prisma.quote.findMany()
    * ```
    */
  get quote(): Prisma.QuoteDelegate<ExtArgs>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs>;

  /**
   * `prisma.ticketComment`: Exposes CRUD operations for the **TicketComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketComments
    * const ticketComments = await prisma.ticketComment.findMany()
    * ```
    */
  get ticketComment(): Prisma.TicketCommentDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Client: 'Client',
    ClientSolution: 'ClientSolution',
    Contact: 'Contact',
    Lead: 'Lead',
    Opportunity: 'Opportunity',
    Proposal: 'Proposal',
    Project: 'Project',
    ProjectMilestone: 'ProjectMilestone',
    ProjectTask: 'ProjectTask',
    ProjectMetric: 'ProjectMetric',
    AISolution: 'AISolution',
    AISolutionModule: 'AISolutionModule',
    Quote: 'Quote',
    Activity: 'Activity',
    Feedback: 'Feedback',
    Ticket: 'Ticket',
    TicketComment: 'TicketComment',
    Comment: 'Comment',
    AuditLog: 'AuditLog',
    RefreshToken: 'RefreshToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "client" | "clientSolution" | "contact" | "lead" | "opportunity" | "proposal" | "project" | "projectMilestone" | "projectTask" | "projectMetric" | "aISolution" | "aISolutionModule" | "quote" | "activity" | "feedback" | "ticket" | "ticketComment" | "comment" | "auditLog" | "refreshToken"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      ClientSolution: {
        payload: Prisma.$ClientSolutionPayload<ExtArgs>
        fields: Prisma.ClientSolutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientSolutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSolutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientSolutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSolutionPayload>
          }
          findFirst: {
            args: Prisma.ClientSolutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSolutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientSolutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSolutionPayload>
          }
          findMany: {
            args: Prisma.ClientSolutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSolutionPayload>[]
          }
          create: {
            args: Prisma.ClientSolutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSolutionPayload>
          }
          createMany: {
            args: Prisma.ClientSolutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientSolutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSolutionPayload>[]
          }
          delete: {
            args: Prisma.ClientSolutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSolutionPayload>
          }
          update: {
            args: Prisma.ClientSolutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSolutionPayload>
          }
          deleteMany: {
            args: Prisma.ClientSolutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientSolutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientSolutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSolutionPayload>
          }
          aggregate: {
            args: Prisma.ClientSolutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientSolution>
          }
          groupBy: {
            args: Prisma.ClientSolutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientSolutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientSolutionCountArgs<ExtArgs>
            result: $Utils.Optional<ClientSolutionCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      Opportunity: {
        payload: Prisma.$OpportunityPayload<ExtArgs>
        fields: Prisma.OpportunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpportunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpportunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          findFirst: {
            args: Prisma.OpportunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpportunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          findMany: {
            args: Prisma.OpportunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          create: {
            args: Prisma.OpportunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          createMany: {
            args: Prisma.OpportunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpportunityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          delete: {
            args: Prisma.OpportunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          update: {
            args: Prisma.OpportunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          deleteMany: {
            args: Prisma.OpportunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpportunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OpportunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          aggregate: {
            args: Prisma.OpportunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpportunity>
          }
          groupBy: {
            args: Prisma.OpportunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpportunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpportunityCountArgs<ExtArgs>
            result: $Utils.Optional<OpportunityCountAggregateOutputType> | number
          }
        }
      }
      Proposal: {
        payload: Prisma.$ProposalPayload<ExtArgs>
        fields: Prisma.ProposalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProposalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProposalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          findFirst: {
            args: Prisma.ProposalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProposalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          findMany: {
            args: Prisma.ProposalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>[]
          }
          create: {
            args: Prisma.ProposalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          createMany: {
            args: Prisma.ProposalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProposalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>[]
          }
          delete: {
            args: Prisma.ProposalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          update: {
            args: Prisma.ProposalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          deleteMany: {
            args: Prisma.ProposalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProposalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProposalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          aggregate: {
            args: Prisma.ProposalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProposal>
          }
          groupBy: {
            args: Prisma.ProposalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProposalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProposalCountArgs<ExtArgs>
            result: $Utils.Optional<ProposalCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectMilestone: {
        payload: Prisma.$ProjectMilestonePayload<ExtArgs>
        fields: Prisma.ProjectMilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMilestonePayload>
          }
          findFirst: {
            args: Prisma.ProjectMilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMilestonePayload>
          }
          findMany: {
            args: Prisma.ProjectMilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMilestonePayload>[]
          }
          create: {
            args: Prisma.ProjectMilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMilestonePayload>
          }
          createMany: {
            args: Prisma.ProjectMilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectMilestoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMilestonePayload>[]
          }
          delete: {
            args: Prisma.ProjectMilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMilestonePayload>
          }
          update: {
            args: Prisma.ProjectMilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMilestonePayload>
          }
          deleteMany: {
            args: Prisma.ProjectMilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectMilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMilestonePayload>
          }
          aggregate: {
            args: Prisma.ProjectMilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMilestone>
          }
          groupBy: {
            args: Prisma.ProjectMilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMilestoneCountAggregateOutputType> | number
          }
        }
      }
      ProjectTask: {
        payload: Prisma.$ProjectTaskPayload<ExtArgs>
        fields: Prisma.ProjectTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload>
          }
          findFirst: {
            args: Prisma.ProjectTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload>
          }
          findMany: {
            args: Prisma.ProjectTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload>[]
          }
          create: {
            args: Prisma.ProjectTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload>
          }
          createMany: {
            args: Prisma.ProjectTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload>[]
          }
          delete: {
            args: Prisma.ProjectTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload>
          }
          update: {
            args: Prisma.ProjectTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload>
          }
          deleteMany: {
            args: Prisma.ProjectTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload>
          }
          aggregate: {
            args: Prisma.ProjectTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectTask>
          }
          groupBy: {
            args: Prisma.ProjectTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectTaskCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectTaskCountAggregateOutputType> | number
          }
        }
      }
      ProjectMetric: {
        payload: Prisma.$ProjectMetricPayload<ExtArgs>
        fields: Prisma.ProjectMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricPayload>
          }
          findFirst: {
            args: Prisma.ProjectMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricPayload>
          }
          findMany: {
            args: Prisma.ProjectMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricPayload>[]
          }
          create: {
            args: Prisma.ProjectMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricPayload>
          }
          createMany: {
            args: Prisma.ProjectMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricPayload>[]
          }
          delete: {
            args: Prisma.ProjectMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricPayload>
          }
          update: {
            args: Prisma.ProjectMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricPayload>
          }
          deleteMany: {
            args: Prisma.ProjectMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricPayload>
          }
          aggregate: {
            args: Prisma.ProjectMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMetric>
          }
          groupBy: {
            args: Prisma.ProjectMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMetricCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMetricCountAggregateOutputType> | number
          }
        }
      }
      AISolution: {
        payload: Prisma.$AISolutionPayload<ExtArgs>
        fields: Prisma.AISolutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AISolutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AISolutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionPayload>
          }
          findFirst: {
            args: Prisma.AISolutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AISolutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionPayload>
          }
          findMany: {
            args: Prisma.AISolutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionPayload>[]
          }
          create: {
            args: Prisma.AISolutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionPayload>
          }
          createMany: {
            args: Prisma.AISolutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AISolutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionPayload>[]
          }
          delete: {
            args: Prisma.AISolutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionPayload>
          }
          update: {
            args: Prisma.AISolutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionPayload>
          }
          deleteMany: {
            args: Prisma.AISolutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AISolutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AISolutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionPayload>
          }
          aggregate: {
            args: Prisma.AISolutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAISolution>
          }
          groupBy: {
            args: Prisma.AISolutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AISolutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AISolutionCountArgs<ExtArgs>
            result: $Utils.Optional<AISolutionCountAggregateOutputType> | number
          }
        }
      }
      AISolutionModule: {
        payload: Prisma.$AISolutionModulePayload<ExtArgs>
        fields: Prisma.AISolutionModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AISolutionModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AISolutionModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionModulePayload>
          }
          findFirst: {
            args: Prisma.AISolutionModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AISolutionModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionModulePayload>
          }
          findMany: {
            args: Prisma.AISolutionModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionModulePayload>[]
          }
          create: {
            args: Prisma.AISolutionModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionModulePayload>
          }
          createMany: {
            args: Prisma.AISolutionModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AISolutionModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionModulePayload>[]
          }
          delete: {
            args: Prisma.AISolutionModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionModulePayload>
          }
          update: {
            args: Prisma.AISolutionModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionModulePayload>
          }
          deleteMany: {
            args: Prisma.AISolutionModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AISolutionModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AISolutionModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AISolutionModulePayload>
          }
          aggregate: {
            args: Prisma.AISolutionModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAISolutionModule>
          }
          groupBy: {
            args: Prisma.AISolutionModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AISolutionModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AISolutionModuleCountArgs<ExtArgs>
            result: $Utils.Optional<AISolutionModuleCountAggregateOutputType> | number
          }
        }
      }
      Quote: {
        payload: Prisma.$QuotePayload<ExtArgs>
        fields: Prisma.QuoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findFirst: {
            args: Prisma.QuoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findMany: {
            args: Prisma.QuoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          create: {
            args: Prisma.QuoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          createMany: {
            args: Prisma.QuoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          delete: {
            args: Prisma.QuoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          update: {
            args: Prisma.QuoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          deleteMany: {
            args: Prisma.QuoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          aggregate: {
            args: Prisma.QuoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuote>
          }
          groupBy: {
            args: Prisma.QuoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      TicketComment: {
        payload: Prisma.$TicketCommentPayload<ExtArgs>
        fields: Prisma.TicketCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          findFirst: {
            args: Prisma.TicketCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          findMany: {
            args: Prisma.TicketCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          create: {
            args: Prisma.TicketCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          createMany: {
            args: Prisma.TicketCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          delete: {
            args: Prisma.TicketCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          update: {
            args: Prisma.TicketCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          deleteMany: {
            args: Prisma.TicketCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          aggregate: {
            args: Prisma.TicketCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketComment>
          }
          groupBy: {
            args: Prisma.TicketCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCommentCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCommentCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    subordinates: number
    leads: number
    opportunities: number
    activities: number
    projectTasks: number
    projectMilestones: number
    tickets: number
    comments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subordinates?: boolean | UserCountOutputTypeCountSubordinatesArgs
    leads?: boolean | UserCountOutputTypeCountLeadsArgs
    opportunities?: boolean | UserCountOutputTypeCountOpportunitiesArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    projectTasks?: boolean | UserCountOutputTypeCountProjectTasksArgs
    projectMilestones?: boolean | UserCountOutputTypeCountProjectMilestonesArgs
    tickets?: boolean | UserCountOutputTypeCountTicketsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMilestoneWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    contacts: number
    leads: number
    opportunities: number
    projects: number
    tickets: number
    feedback: number
    aiSolutions: number
    users: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | ClientCountOutputTypeCountContactsArgs
    leads?: boolean | ClientCountOutputTypeCountLeadsArgs
    opportunities?: boolean | ClientCountOutputTypeCountOpportunitiesArgs
    projects?: boolean | ClientCountOutputTypeCountProjectsArgs
    tickets?: boolean | ClientCountOutputTypeCountTicketsArgs
    feedback?: boolean | ClientCountOutputTypeCountFeedbackArgs
    aiSolutions?: boolean | ClientCountOutputTypeCountAiSolutionsArgs
    users?: boolean | ClientCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountAiSolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientSolutionWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    activities: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | ContactCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }


  /**
   * Count Type LeadCountOutputType
   */

  export type LeadCountOutputType = {
    activities: number
    opportunities: number
  }

  export type LeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | LeadCountOutputTypeCountActivitiesArgs
    opportunities?: boolean | LeadCountOutputTypeCountOpportunitiesArgs
  }

  // Custom InputTypes
  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCountOutputType
     */
    select?: LeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
  }


  /**
   * Count Type OpportunityCountOutputType
   */

  export type OpportunityCountOutputType = {
    activities: number
    proposals: number
  }

  export type OpportunityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | OpportunityCountOutputTypeCountActivitiesArgs
    proposals?: boolean | OpportunityCountOutputTypeCountProposalsArgs
  }

  // Custom InputTypes
  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityCountOutputType
     */
    select?: OpportunityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    milestones: number
    tasks: number
    metrics: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    milestones?: boolean | ProjectCountOutputTypeCountMilestonesArgs
    tasks?: boolean | ProjectCountOutputTypeCountTasksArgs
    metrics?: boolean | ProjectCountOutputTypeCountMetricsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMilestoneWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTaskWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMetricWhereInput
  }


  /**
   * Count Type AISolutionCountOutputType
   */

  export type AISolutionCountOutputType = {
    modules: number
    quotes: number
    clientSolutions: number
  }

  export type AISolutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | AISolutionCountOutputTypeCountModulesArgs
    quotes?: boolean | AISolutionCountOutputTypeCountQuotesArgs
    clientSolutions?: boolean | AISolutionCountOutputTypeCountClientSolutionsArgs
  }

  // Custom InputTypes
  /**
   * AISolutionCountOutputType without action
   */
  export type AISolutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolutionCountOutputType
     */
    select?: AISolutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AISolutionCountOutputType without action
   */
  export type AISolutionCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AISolutionModuleWhereInput
  }

  /**
   * AISolutionCountOutputType without action
   */
  export type AISolutionCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }

  /**
   * AISolutionCountOutputType without action
   */
  export type AISolutionCountOutputTypeCountClientSolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientSolutionWhereInput
  }


  /**
   * Count Type TicketCountOutputType
   */

  export type TicketCountOutputType = {
    comments: number
  }

  export type TicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | TicketCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCountOutputType
     */
    select?: TicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    managerId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    managerId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    role: number
    isActive: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    clientId: number
    managerId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    managerId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    managerId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    managerId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive: boolean
    lastLogin: Date | null
    createdAt: Date
    updatedAt: Date
    clientId: string | null
    managerId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    managerId?: boolean
    client?: boolean | User$clientArgs<ExtArgs>
    managedBy?: boolean | User$managedByArgs<ExtArgs>
    subordinates?: boolean | User$subordinatesArgs<ExtArgs>
    leads?: boolean | User$leadsArgs<ExtArgs>
    opportunities?: boolean | User$opportunitiesArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    projectTasks?: boolean | User$projectTasksArgs<ExtArgs>
    projectMilestones?: boolean | User$projectMilestonesArgs<ExtArgs>
    tickets?: boolean | User$ticketsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    managerId?: boolean
    client?: boolean | User$clientArgs<ExtArgs>
    managedBy?: boolean | User$managedByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    managerId?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | User$clientArgs<ExtArgs>
    managedBy?: boolean | User$managedByArgs<ExtArgs>
    subordinates?: boolean | User$subordinatesArgs<ExtArgs>
    leads?: boolean | User$leadsArgs<ExtArgs>
    opportunities?: boolean | User$opportunitiesArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    projectTasks?: boolean | User$projectTasksArgs<ExtArgs>
    projectMilestones?: boolean | User$projectMilestonesArgs<ExtArgs>
    tickets?: boolean | User$ticketsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | User$clientArgs<ExtArgs>
    managedBy?: boolean | User$managedByArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      managedBy: Prisma.$UserPayload<ExtArgs> | null
      subordinates: Prisma.$UserPayload<ExtArgs>[]
      leads: Prisma.$LeadPayload<ExtArgs>[]
      opportunities: Prisma.$OpportunityPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      projectTasks: Prisma.$ProjectTaskPayload<ExtArgs>[]
      projectMilestones: Prisma.$ProjectMilestonePayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      firstName: string
      lastName: string
      role: $Enums.UserRole
      isActive: boolean
      lastLogin: Date | null
      createdAt: Date
      updatedAt: Date
      clientId: string | null
      managerId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends User$clientArgs<ExtArgs> = {}>(args?: Subset<T, User$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    managedBy<T extends User$managedByArgs<ExtArgs> = {}>(args?: Subset<T, User$managedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subordinates<T extends User$subordinatesArgs<ExtArgs> = {}>(args?: Subset<T, User$subordinatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    leads<T extends User$leadsArgs<ExtArgs> = {}>(args?: Subset<T, User$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany"> | Null>
    opportunities<T extends User$opportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$opportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany"> | Null>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    projectTasks<T extends User$projectTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$projectTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "findMany"> | Null>
    projectMilestones<T extends User$projectMilestonesArgs<ExtArgs> = {}>(args?: Subset<T, User$projectMilestonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMilestonePayload<ExtArgs>, T, "findMany"> | Null>
    tickets<T extends User$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly clientId: FieldRef<"User", 'String'>
    readonly managerId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.client
   */
  export type User$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * User.managedBy
   */
  export type User$managedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.subordinates
   */
  export type User$subordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.leads
   */
  export type User$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * User.opportunities
   */
  export type User$opportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    cursor?: OpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User.projectTasks
   */
  export type User$projectTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTaskInclude<ExtArgs> | null
    where?: ProjectTaskWhereInput
    orderBy?: ProjectTaskOrderByWithRelationInput | ProjectTaskOrderByWithRelationInput[]
    cursor?: ProjectTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectTaskScalarFieldEnum | ProjectTaskScalarFieldEnum[]
  }

  /**
   * User.projectMilestones
   */
  export type User$projectMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMilestone
     */
    select?: ProjectMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMilestoneInclude<ExtArgs> | null
    where?: ProjectMilestoneWhereInput
    orderBy?: ProjectMilestoneOrderByWithRelationInput | ProjectMilestoneOrderByWithRelationInput[]
    cursor?: ProjectMilestoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMilestoneScalarFieldEnum | ProjectMilestoneScalarFieldEnum[]
  }

  /**
   * User.tickets
   */
  export type User$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    aiReadinessScore: number | null
    healthScore: number | null
    npsScore: number | null
    renewalNoticeDays: number | null
  }

  export type ClientSumAggregateOutputType = {
    aiReadinessScore: number | null
    healthScore: number | null
    npsScore: number | null
    renewalNoticeDays: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    name: string | null
    legalName: string | null
    industry: string | null
    industryCode: string | null
    size: string | null
    revenueBand: string | null
    address: string | null
    city: string | null
    country: string | null
    phone: string | null
    website: string | null
    aiMaturityLevel: string | null
    aiReadinessScore: number | null
    lifecycleStage: $Enums.ClientLifecycleStage | null
    healthScore: number | null
    npsScore: number | null
    accountExecutiveId: string | null
    contractStartDate: Date | null
    contractEndDate: Date | null
    autoRenewal: boolean | null
    renewalNoticeDays: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    legalName: string | null
    industry: string | null
    industryCode: string | null
    size: string | null
    revenueBand: string | null
    address: string | null
    city: string | null
    country: string | null
    phone: string | null
    website: string | null
    aiMaturityLevel: string | null
    aiReadinessScore: number | null
    lifecycleStage: $Enums.ClientLifecycleStage | null
    healthScore: number | null
    npsScore: number | null
    accountExecutiveId: string | null
    contractStartDate: Date | null
    contractEndDate: Date | null
    autoRenewal: boolean | null
    renewalNoticeDays: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    legalName: number
    industry: number
    industryCode: number
    size: number
    revenueBand: number
    address: number
    city: number
    country: number
    phone: number
    website: number
    aiMaturityLevel: number
    aiReadinessScore: number
    technologyStack: number
    lifecycleStage: number
    healthScore: number
    npsScore: number
    accountExecutiveId: number
    contractStartDate: number
    contractEndDate: number
    autoRenewal: number
    renewalNoticeDays: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    aiReadinessScore?: true
    healthScore?: true
    npsScore?: true
    renewalNoticeDays?: true
  }

  export type ClientSumAggregateInputType = {
    aiReadinessScore?: true
    healthScore?: true
    npsScore?: true
    renewalNoticeDays?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    legalName?: true
    industry?: true
    industryCode?: true
    size?: true
    revenueBand?: true
    address?: true
    city?: true
    country?: true
    phone?: true
    website?: true
    aiMaturityLevel?: true
    aiReadinessScore?: true
    lifecycleStage?: true
    healthScore?: true
    npsScore?: true
    accountExecutiveId?: true
    contractStartDate?: true
    contractEndDate?: true
    autoRenewal?: true
    renewalNoticeDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    legalName?: true
    industry?: true
    industryCode?: true
    size?: true
    revenueBand?: true
    address?: true
    city?: true
    country?: true
    phone?: true
    website?: true
    aiMaturityLevel?: true
    aiReadinessScore?: true
    lifecycleStage?: true
    healthScore?: true
    npsScore?: true
    accountExecutiveId?: true
    contractStartDate?: true
    contractEndDate?: true
    autoRenewal?: true
    renewalNoticeDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    legalName?: true
    industry?: true
    industryCode?: true
    size?: true
    revenueBand?: true
    address?: true
    city?: true
    country?: true
    phone?: true
    website?: true
    aiMaturityLevel?: true
    aiReadinessScore?: true
    technologyStack?: true
    lifecycleStage?: true
    healthScore?: true
    npsScore?: true
    accountExecutiveId?: true
    contractStartDate?: true
    contractEndDate?: true
    autoRenewal?: true
    renewalNoticeDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    name: string
    legalName: string | null
    industry: string | null
    industryCode: string | null
    size: string | null
    revenueBand: string | null
    address: string | null
    city: string | null
    country: string | null
    phone: string | null
    website: string | null
    aiMaturityLevel: string | null
    aiReadinessScore: number | null
    technologyStack: string[]
    lifecycleStage: $Enums.ClientLifecycleStage
    healthScore: number
    npsScore: number | null
    accountExecutiveId: string | null
    contractStartDate: Date | null
    contractEndDate: Date | null
    autoRenewal: boolean
    renewalNoticeDays: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    legalName?: boolean
    industry?: boolean
    industryCode?: boolean
    size?: boolean
    revenueBand?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    phone?: boolean
    website?: boolean
    aiMaturityLevel?: boolean
    aiReadinessScore?: boolean
    technologyStack?: boolean
    lifecycleStage?: boolean
    healthScore?: boolean
    npsScore?: boolean
    accountExecutiveId?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    autoRenewal?: boolean
    renewalNoticeDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contacts?: boolean | Client$contactsArgs<ExtArgs>
    leads?: boolean | Client$leadsArgs<ExtArgs>
    opportunities?: boolean | Client$opportunitiesArgs<ExtArgs>
    projects?: boolean | Client$projectsArgs<ExtArgs>
    tickets?: boolean | Client$ticketsArgs<ExtArgs>
    feedback?: boolean | Client$feedbackArgs<ExtArgs>
    aiSolutions?: boolean | Client$aiSolutionsArgs<ExtArgs>
    users?: boolean | Client$usersArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    legalName?: boolean
    industry?: boolean
    industryCode?: boolean
    size?: boolean
    revenueBand?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    phone?: boolean
    website?: boolean
    aiMaturityLevel?: boolean
    aiReadinessScore?: boolean
    technologyStack?: boolean
    lifecycleStage?: boolean
    healthScore?: boolean
    npsScore?: boolean
    accountExecutiveId?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    autoRenewal?: boolean
    renewalNoticeDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    name?: boolean
    legalName?: boolean
    industry?: boolean
    industryCode?: boolean
    size?: boolean
    revenueBand?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    phone?: boolean
    website?: boolean
    aiMaturityLevel?: boolean
    aiReadinessScore?: boolean
    technologyStack?: boolean
    lifecycleStage?: boolean
    healthScore?: boolean
    npsScore?: boolean
    accountExecutiveId?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    autoRenewal?: boolean
    renewalNoticeDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | Client$contactsArgs<ExtArgs>
    leads?: boolean | Client$leadsArgs<ExtArgs>
    opportunities?: boolean | Client$opportunitiesArgs<ExtArgs>
    projects?: boolean | Client$projectsArgs<ExtArgs>
    tickets?: boolean | Client$ticketsArgs<ExtArgs>
    feedback?: boolean | Client$feedbackArgs<ExtArgs>
    aiSolutions?: boolean | Client$aiSolutionsArgs<ExtArgs>
    users?: boolean | Client$usersArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      leads: Prisma.$LeadPayload<ExtArgs>[]
      opportunities: Prisma.$OpportunityPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      feedback: Prisma.$FeedbackPayload<ExtArgs>[]
      aiSolutions: Prisma.$ClientSolutionPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      legalName: string | null
      industry: string | null
      industryCode: string | null
      size: string | null
      revenueBand: string | null
      address: string | null
      city: string | null
      country: string | null
      phone: string | null
      website: string | null
      aiMaturityLevel: string | null
      aiReadinessScore: number | null
      technologyStack: string[]
      lifecycleStage: $Enums.ClientLifecycleStage
      healthScore: number
      npsScore: number | null
      accountExecutiveId: string | null
      contractStartDate: Date | null
      contractEndDate: Date | null
      autoRenewal: boolean
      renewalNoticeDays: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contacts<T extends Client$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Client$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany"> | Null>
    leads<T extends Client$leadsArgs<ExtArgs> = {}>(args?: Subset<T, Client$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany"> | Null>
    opportunities<T extends Client$opportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, Client$opportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany"> | Null>
    projects<T extends Client$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Client$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    tickets<T extends Client$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Client$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    feedback<T extends Client$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, Client$feedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    aiSolutions<T extends Client$aiSolutionsArgs<ExtArgs> = {}>(args?: Subset<T, Client$aiSolutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSolutionPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Client$usersArgs<ExtArgs> = {}>(args?: Subset<T, Client$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */ 
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly name: FieldRef<"Client", 'String'>
    readonly legalName: FieldRef<"Client", 'String'>
    readonly industry: FieldRef<"Client", 'String'>
    readonly industryCode: FieldRef<"Client", 'String'>
    readonly size: FieldRef<"Client", 'String'>
    readonly revenueBand: FieldRef<"Client", 'String'>
    readonly address: FieldRef<"Client", 'String'>
    readonly city: FieldRef<"Client", 'String'>
    readonly country: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly website: FieldRef<"Client", 'String'>
    readonly aiMaturityLevel: FieldRef<"Client", 'String'>
    readonly aiReadinessScore: FieldRef<"Client", 'Int'>
    readonly technologyStack: FieldRef<"Client", 'String[]'>
    readonly lifecycleStage: FieldRef<"Client", 'ClientLifecycleStage'>
    readonly healthScore: FieldRef<"Client", 'Int'>
    readonly npsScore: FieldRef<"Client", 'Int'>
    readonly accountExecutiveId: FieldRef<"Client", 'String'>
    readonly contractStartDate: FieldRef<"Client", 'DateTime'>
    readonly contractEndDate: FieldRef<"Client", 'DateTime'>
    readonly autoRenewal: FieldRef<"Client", 'Boolean'>
    readonly renewalNoticeDays: FieldRef<"Client", 'Int'>
    readonly isActive: FieldRef<"Client", 'Boolean'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
  }

  /**
   * Client.contacts
   */
  export type Client$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Client.leads
   */
  export type Client$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Client.opportunities
   */
  export type Client$opportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    cursor?: OpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Client.projects
   */
  export type Client$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Client.tickets
   */
  export type Client$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Client.feedback
   */
  export type Client$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Client.aiSolutions
   */
  export type Client$aiSolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSolution
     */
    select?: ClientSolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSolutionInclude<ExtArgs> | null
    where?: ClientSolutionWhereInput
    orderBy?: ClientSolutionOrderByWithRelationInput | ClientSolutionOrderByWithRelationInput[]
    cursor?: ClientSolutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientSolutionScalarFieldEnum | ClientSolutionScalarFieldEnum[]
  }

  /**
   * Client.users
   */
  export type Client$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model ClientSolution
   */

  export type AggregateClientSolution = {
    _count: ClientSolutionCountAggregateOutputType | null
    _min: ClientSolutionMinAggregateOutputType | null
    _max: ClientSolutionMaxAggregateOutputType | null
  }

  export type ClientSolutionMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    solutionId: string | null
    deployedAt: Date | null
    status: string | null
  }

  export type ClientSolutionMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    solutionId: string | null
    deployedAt: Date | null
    status: string | null
  }

  export type ClientSolutionCountAggregateOutputType = {
    id: number
    clientId: number
    solutionId: number
    deployedAt: number
    status: number
    _all: number
  }


  export type ClientSolutionMinAggregateInputType = {
    id?: true
    clientId?: true
    solutionId?: true
    deployedAt?: true
    status?: true
  }

  export type ClientSolutionMaxAggregateInputType = {
    id?: true
    clientId?: true
    solutionId?: true
    deployedAt?: true
    status?: true
  }

  export type ClientSolutionCountAggregateInputType = {
    id?: true
    clientId?: true
    solutionId?: true
    deployedAt?: true
    status?: true
    _all?: true
  }

  export type ClientSolutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientSolution to aggregate.
     */
    where?: ClientSolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSolutions to fetch.
     */
    orderBy?: ClientSolutionOrderByWithRelationInput | ClientSolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientSolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientSolutions
    **/
    _count?: true | ClientSolutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientSolutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientSolutionMaxAggregateInputType
  }

  export type GetClientSolutionAggregateType<T extends ClientSolutionAggregateArgs> = {
        [P in keyof T & keyof AggregateClientSolution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientSolution[P]>
      : GetScalarType<T[P], AggregateClientSolution[P]>
  }




  export type ClientSolutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientSolutionWhereInput
    orderBy?: ClientSolutionOrderByWithAggregationInput | ClientSolutionOrderByWithAggregationInput[]
    by: ClientSolutionScalarFieldEnum[] | ClientSolutionScalarFieldEnum
    having?: ClientSolutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientSolutionCountAggregateInputType | true
    _min?: ClientSolutionMinAggregateInputType
    _max?: ClientSolutionMaxAggregateInputType
  }

  export type ClientSolutionGroupByOutputType = {
    id: string
    clientId: string
    solutionId: string
    deployedAt: Date | null
    status: string
    _count: ClientSolutionCountAggregateOutputType | null
    _min: ClientSolutionMinAggregateOutputType | null
    _max: ClientSolutionMaxAggregateOutputType | null
  }

  type GetClientSolutionGroupByPayload<T extends ClientSolutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientSolutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientSolutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientSolutionGroupByOutputType[P]>
            : GetScalarType<T[P], ClientSolutionGroupByOutputType[P]>
        }
      >
    >


  export type ClientSolutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    solutionId?: boolean
    deployedAt?: boolean
    status?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    solution?: boolean | AISolutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientSolution"]>

  export type ClientSolutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    solutionId?: boolean
    deployedAt?: boolean
    status?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    solution?: boolean | AISolutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientSolution"]>

  export type ClientSolutionSelectScalar = {
    id?: boolean
    clientId?: boolean
    solutionId?: boolean
    deployedAt?: boolean
    status?: boolean
  }

  export type ClientSolutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    solution?: boolean | AISolutionDefaultArgs<ExtArgs>
  }
  export type ClientSolutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    solution?: boolean | AISolutionDefaultArgs<ExtArgs>
  }

  export type $ClientSolutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientSolution"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      solution: Prisma.$AISolutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      solutionId: string
      deployedAt: Date | null
      status: string
    }, ExtArgs["result"]["clientSolution"]>
    composites: {}
  }

  type ClientSolutionGetPayload<S extends boolean | null | undefined | ClientSolutionDefaultArgs> = $Result.GetResult<Prisma.$ClientSolutionPayload, S>

  type ClientSolutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientSolutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientSolutionCountAggregateInputType | true
    }

  export interface ClientSolutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientSolution'], meta: { name: 'ClientSolution' } }
    /**
     * Find zero or one ClientSolution that matches the filter.
     * @param {ClientSolutionFindUniqueArgs} args - Arguments to find a ClientSolution
     * @example
     * // Get one ClientSolution
     * const clientSolution = await prisma.clientSolution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientSolutionFindUniqueArgs>(args: SelectSubset<T, ClientSolutionFindUniqueArgs<ExtArgs>>): Prisma__ClientSolutionClient<$Result.GetResult<Prisma.$ClientSolutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClientSolution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientSolutionFindUniqueOrThrowArgs} args - Arguments to find a ClientSolution
     * @example
     * // Get one ClientSolution
     * const clientSolution = await prisma.clientSolution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientSolutionFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientSolutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientSolutionClient<$Result.GetResult<Prisma.$ClientSolutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClientSolution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSolutionFindFirstArgs} args - Arguments to find a ClientSolution
     * @example
     * // Get one ClientSolution
     * const clientSolution = await prisma.clientSolution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientSolutionFindFirstArgs>(args?: SelectSubset<T, ClientSolutionFindFirstArgs<ExtArgs>>): Prisma__ClientSolutionClient<$Result.GetResult<Prisma.$ClientSolutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClientSolution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSolutionFindFirstOrThrowArgs} args - Arguments to find a ClientSolution
     * @example
     * // Get one ClientSolution
     * const clientSolution = await prisma.clientSolution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientSolutionFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientSolutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientSolutionClient<$Result.GetResult<Prisma.$ClientSolutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClientSolutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSolutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientSolutions
     * const clientSolutions = await prisma.clientSolution.findMany()
     * 
     * // Get first 10 ClientSolutions
     * const clientSolutions = await prisma.clientSolution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientSolutionWithIdOnly = await prisma.clientSolution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientSolutionFindManyArgs>(args?: SelectSubset<T, ClientSolutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSolutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClientSolution.
     * @param {ClientSolutionCreateArgs} args - Arguments to create a ClientSolution.
     * @example
     * // Create one ClientSolution
     * const ClientSolution = await prisma.clientSolution.create({
     *   data: {
     *     // ... data to create a ClientSolution
     *   }
     * })
     * 
     */
    create<T extends ClientSolutionCreateArgs>(args: SelectSubset<T, ClientSolutionCreateArgs<ExtArgs>>): Prisma__ClientSolutionClient<$Result.GetResult<Prisma.$ClientSolutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClientSolutions.
     * @param {ClientSolutionCreateManyArgs} args - Arguments to create many ClientSolutions.
     * @example
     * // Create many ClientSolutions
     * const clientSolution = await prisma.clientSolution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientSolutionCreateManyArgs>(args?: SelectSubset<T, ClientSolutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientSolutions and returns the data saved in the database.
     * @param {ClientSolutionCreateManyAndReturnArgs} args - Arguments to create many ClientSolutions.
     * @example
     * // Create many ClientSolutions
     * const clientSolution = await prisma.clientSolution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientSolutions and only return the `id`
     * const clientSolutionWithIdOnly = await prisma.clientSolution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientSolutionCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientSolutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSolutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClientSolution.
     * @param {ClientSolutionDeleteArgs} args - Arguments to delete one ClientSolution.
     * @example
     * // Delete one ClientSolution
     * const ClientSolution = await prisma.clientSolution.delete({
     *   where: {
     *     // ... filter to delete one ClientSolution
     *   }
     * })
     * 
     */
    delete<T extends ClientSolutionDeleteArgs>(args: SelectSubset<T, ClientSolutionDeleteArgs<ExtArgs>>): Prisma__ClientSolutionClient<$Result.GetResult<Prisma.$ClientSolutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClientSolution.
     * @param {ClientSolutionUpdateArgs} args - Arguments to update one ClientSolution.
     * @example
     * // Update one ClientSolution
     * const clientSolution = await prisma.clientSolution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientSolutionUpdateArgs>(args: SelectSubset<T, ClientSolutionUpdateArgs<ExtArgs>>): Prisma__ClientSolutionClient<$Result.GetResult<Prisma.$ClientSolutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClientSolutions.
     * @param {ClientSolutionDeleteManyArgs} args - Arguments to filter ClientSolutions to delete.
     * @example
     * // Delete a few ClientSolutions
     * const { count } = await prisma.clientSolution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientSolutionDeleteManyArgs>(args?: SelectSubset<T, ClientSolutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientSolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSolutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientSolutions
     * const clientSolution = await prisma.clientSolution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientSolutionUpdateManyArgs>(args: SelectSubset<T, ClientSolutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientSolution.
     * @param {ClientSolutionUpsertArgs} args - Arguments to update or create a ClientSolution.
     * @example
     * // Update or create a ClientSolution
     * const clientSolution = await prisma.clientSolution.upsert({
     *   create: {
     *     // ... data to create a ClientSolution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientSolution we want to update
     *   }
     * })
     */
    upsert<T extends ClientSolutionUpsertArgs>(args: SelectSubset<T, ClientSolutionUpsertArgs<ExtArgs>>): Prisma__ClientSolutionClient<$Result.GetResult<Prisma.$ClientSolutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClientSolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSolutionCountArgs} args - Arguments to filter ClientSolutions to count.
     * @example
     * // Count the number of ClientSolutions
     * const count = await prisma.clientSolution.count({
     *   where: {
     *     // ... the filter for the ClientSolutions we want to count
     *   }
     * })
    **/
    count<T extends ClientSolutionCountArgs>(
      args?: Subset<T, ClientSolutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientSolutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientSolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSolutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientSolutionAggregateArgs>(args: Subset<T, ClientSolutionAggregateArgs>): Prisma.PrismaPromise<GetClientSolutionAggregateType<T>>

    /**
     * Group by ClientSolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSolutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientSolutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientSolutionGroupByArgs['orderBy'] }
        : { orderBy?: ClientSolutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientSolutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientSolutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientSolution model
   */
  readonly fields: ClientSolutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientSolution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientSolutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    solution<T extends AISolutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AISolutionDefaultArgs<ExtArgs>>): Prisma__AISolutionClient<$Result.GetResult<Prisma.$AISolutionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientSolution model
   */ 
  interface ClientSolutionFieldRefs {
    readonly id: FieldRef<"ClientSolution", 'String'>
    readonly clientId: FieldRef<"ClientSolution", 'String'>
    readonly solutionId: FieldRef<"ClientSolution", 'String'>
    readonly deployedAt: FieldRef<"ClientSolution", 'DateTime'>
    readonly status: FieldRef<"ClientSolution", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClientSolution findUnique
   */
  export type ClientSolutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSolution
     */
    select?: ClientSolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSolutionInclude<ExtArgs> | null
    /**
     * Filter, which ClientSolution to fetch.
     */
    where: ClientSolutionWhereUniqueInput
  }

  /**
   * ClientSolution findUniqueOrThrow
   */
  export type ClientSolutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSolution
     */
    select?: ClientSolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSolutionInclude<ExtArgs> | null
    /**
     * Filter, which ClientSolution to fetch.
     */
    where: ClientSolutionWhereUniqueInput
  }

  /**
   * ClientSolution findFirst
   */
  export type ClientSolutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSolution
     */
    select?: ClientSolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSolutionInclude<ExtArgs> | null
    /**
     * Filter, which ClientSolution to fetch.
     */
    where?: ClientSolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSolutions to fetch.
     */
    orderBy?: ClientSolutionOrderByWithRelationInput | ClientSolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientSolutions.
     */
    cursor?: ClientSolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientSolutions.
     */
    distinct?: ClientSolutionScalarFieldEnum | ClientSolutionScalarFieldEnum[]
  }

  /**
   * ClientSolution findFirstOrThrow
   */
  export type ClientSolutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSolution
     */
    select?: ClientSolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSolutionInclude<ExtArgs> | null
    /**
     * Filter, which ClientSolution to fetch.
     */
    where?: ClientSolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSolutions to fetch.
     */
    orderBy?: ClientSolutionOrderByWithRelationInput | ClientSolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientSolutions.
     */
    cursor?: ClientSolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientSolutions.
     */
    distinct?: ClientSolutionScalarFieldEnum | ClientSolutionScalarFieldEnum[]
  }

  /**
   * ClientSolution findMany
   */
  export type ClientSolutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSolution
     */
    select?: ClientSolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSolutionInclude<ExtArgs> | null
    /**
     * Filter, which ClientSolutions to fetch.
     */
    where?: ClientSolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSolutions to fetch.
     */
    orderBy?: ClientSolutionOrderByWithRelationInput | ClientSolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientSolutions.
     */
    cursor?: ClientSolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSolutions.
     */
    skip?: number
    distinct?: ClientSolutionScalarFieldEnum | ClientSolutionScalarFieldEnum[]
  }

  /**
   * ClientSolution create
   */
  export type ClientSolutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSolution
     */
    select?: ClientSolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSolutionInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientSolution.
     */
    data: XOR<ClientSolutionCreateInput, ClientSolutionUncheckedCreateInput>
  }

  /**
   * ClientSolution createMany
   */
  export type ClientSolutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientSolutions.
     */
    data: ClientSolutionCreateManyInput | ClientSolutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientSolution createManyAndReturn
   */
  export type ClientSolutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSolution
     */
    select?: ClientSolutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClientSolutions.
     */
    data: ClientSolutionCreateManyInput | ClientSolutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSolutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientSolution update
   */
  export type ClientSolutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSolution
     */
    select?: ClientSolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSolutionInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientSolution.
     */
    data: XOR<ClientSolutionUpdateInput, ClientSolutionUncheckedUpdateInput>
    /**
     * Choose, which ClientSolution to update.
     */
    where: ClientSolutionWhereUniqueInput
  }

  /**
   * ClientSolution updateMany
   */
  export type ClientSolutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientSolutions.
     */
    data: XOR<ClientSolutionUpdateManyMutationInput, ClientSolutionUncheckedUpdateManyInput>
    /**
     * Filter which ClientSolutions to update
     */
    where?: ClientSolutionWhereInput
  }

  /**
   * ClientSolution upsert
   */
  export type ClientSolutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSolution
     */
    select?: ClientSolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSolutionInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientSolution to update in case it exists.
     */
    where: ClientSolutionWhereUniqueInput
    /**
     * In case the ClientSolution found by the `where` argument doesn't exist, create a new ClientSolution with this data.
     */
    create: XOR<ClientSolutionCreateInput, ClientSolutionUncheckedCreateInput>
    /**
     * In case the ClientSolution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientSolutionUpdateInput, ClientSolutionUncheckedUpdateInput>
  }

  /**
   * ClientSolution delete
   */
  export type ClientSolutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSolution
     */
    select?: ClientSolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSolutionInclude<ExtArgs> | null
    /**
     * Filter which ClientSolution to delete.
     */
    where: ClientSolutionWhereUniqueInput
  }

  /**
   * ClientSolution deleteMany
   */
  export type ClientSolutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientSolutions to delete
     */
    where?: ClientSolutionWhereInput
  }

  /**
   * ClientSolution without action
   */
  export type ClientSolutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSolution
     */
    select?: ClientSolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSolutionInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactAvgAggregateOutputType = {
    influenceLevel: number | null
    relationshipScore: number | null
  }

  export type ContactSumAggregateOutputType = {
    influenceLevel: number | null
    relationshipScore: number | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    jobTitle: string | null
    isDecisionMaker: boolean | null
    isInfluencer: boolean | null
    isTechnicalLead: boolean | null
    isEndUser: boolean | null
    isBudgetHolder: boolean | null
    influenceLevel: number | null
    relationshipScore: number | null
    lastInteraction: Date | null
    preferredChannel: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    jobTitle: string | null
    isDecisionMaker: boolean | null
    isInfluencer: boolean | null
    isTechnicalLead: boolean | null
    isEndUser: boolean | null
    isBudgetHolder: boolean | null
    influenceLevel: number | null
    relationshipScore: number | null
    lastInteraction: Date | null
    preferredChannel: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    clientId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    jobTitle: number
    isDecisionMaker: number
    isInfluencer: number
    isTechnicalLead: number
    isEndUser: number
    isBudgetHolder: number
    influenceLevel: number
    relationshipScore: number
    lastInteraction: number
    preferredChannel: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactAvgAggregateInputType = {
    influenceLevel?: true
    relationshipScore?: true
  }

  export type ContactSumAggregateInputType = {
    influenceLevel?: true
    relationshipScore?: true
  }

  export type ContactMinAggregateInputType = {
    id?: true
    clientId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    jobTitle?: true
    isDecisionMaker?: true
    isInfluencer?: true
    isTechnicalLead?: true
    isEndUser?: true
    isBudgetHolder?: true
    influenceLevel?: true
    relationshipScore?: true
    lastInteraction?: true
    preferredChannel?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    clientId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    jobTitle?: true
    isDecisionMaker?: true
    isInfluencer?: true
    isTechnicalLead?: true
    isEndUser?: true
    isBudgetHolder?: true
    influenceLevel?: true
    relationshipScore?: true
    lastInteraction?: true
    preferredChannel?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    clientId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    jobTitle?: true
    isDecisionMaker?: true
    isInfluencer?: true
    isTechnicalLead?: true
    isEndUser?: true
    isBudgetHolder?: true
    influenceLevel?: true
    relationshipScore?: true
    lastInteraction?: true
    preferredChannel?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _avg?: ContactAvgAggregateInputType
    _sum?: ContactSumAggregateInputType
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    clientId: string
    firstName: string
    lastName: string
    email: string
    phone: string | null
    jobTitle: string | null
    isDecisionMaker: boolean
    isInfluencer: boolean
    isTechnicalLead: boolean
    isEndUser: boolean
    isBudgetHolder: boolean
    influenceLevel: number
    relationshipScore: number
    lastInteraction: Date | null
    preferredChannel: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    jobTitle?: boolean
    isDecisionMaker?: boolean
    isInfluencer?: boolean
    isTechnicalLead?: boolean
    isEndUser?: boolean
    isBudgetHolder?: boolean
    influenceLevel?: boolean
    relationshipScore?: boolean
    lastInteraction?: boolean
    preferredChannel?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    activities?: boolean | Contact$activitiesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    jobTitle?: boolean
    isDecisionMaker?: boolean
    isInfluencer?: boolean
    isTechnicalLead?: boolean
    isEndUser?: boolean
    isBudgetHolder?: boolean
    influenceLevel?: boolean
    relationshipScore?: boolean
    lastInteraction?: boolean
    preferredChannel?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    clientId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    jobTitle?: boolean
    isDecisionMaker?: boolean
    isInfluencer?: boolean
    isTechnicalLead?: boolean
    isEndUser?: boolean
    isBudgetHolder?: boolean
    influenceLevel?: boolean
    relationshipScore?: boolean
    lastInteraction?: boolean
    preferredChannel?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    activities?: boolean | Contact$activitiesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      activities: Prisma.$ActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      firstName: string
      lastName: string
      email: string
      phone: string | null
      jobTitle: string | null
      isDecisionMaker: boolean
      isInfluencer: boolean
      isTechnicalLead: boolean
      isEndUser: boolean
      isBudgetHolder: boolean
      influenceLevel: number
      relationshipScore: number
      lastInteraction: Date | null
      preferredChannel: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    activities<T extends Contact$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */ 
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly clientId: FieldRef<"Contact", 'String'>
    readonly firstName: FieldRef<"Contact", 'String'>
    readonly lastName: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly jobTitle: FieldRef<"Contact", 'String'>
    readonly isDecisionMaker: FieldRef<"Contact", 'Boolean'>
    readonly isInfluencer: FieldRef<"Contact", 'Boolean'>
    readonly isTechnicalLead: FieldRef<"Contact", 'Boolean'>
    readonly isEndUser: FieldRef<"Contact", 'Boolean'>
    readonly isBudgetHolder: FieldRef<"Contact", 'Boolean'>
    readonly influenceLevel: FieldRef<"Contact", 'Int'>
    readonly relationshipScore: FieldRef<"Contact", 'Int'>
    readonly lastInteraction: FieldRef<"Contact", 'DateTime'>
    readonly preferredChannel: FieldRef<"Contact", 'String'>
    readonly isActive: FieldRef<"Contact", 'Boolean'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
  }

  /**
   * Contact.activities
   */
  export type Contact$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadAvgAggregateOutputType = {
    leadScore: number | null
  }

  export type LeadSumAggregateOutputType = {
    leadScore: number | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    ownerId: string | null
    source: string | null
    sourceDetails: string | null
    status: $Enums.LeadStatus | null
    companyName: string | null
    contactName: string | null
    contactEmail: string | null
    contactPhone: string | null
    industry: string | null
    companySize: string | null
    leadScore: number | null
    scoreTier: string | null
    scoreReason: string | null
    budgetRange: string | null
    timeline: string | null
    needDescription: string | null
    convertedAt: Date | null
    lostAt: Date | null
    lossReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    ownerId: string | null
    source: string | null
    sourceDetails: string | null
    status: $Enums.LeadStatus | null
    companyName: string | null
    contactName: string | null
    contactEmail: string | null
    contactPhone: string | null
    industry: string | null
    companySize: string | null
    leadScore: number | null
    scoreTier: string | null
    scoreReason: string | null
    budgetRange: string | null
    timeline: string | null
    needDescription: string | null
    convertedAt: Date | null
    lostAt: Date | null
    lossReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    clientId: number
    ownerId: number
    source: number
    sourceDetails: number
    status: number
    companyName: number
    contactName: number
    contactEmail: number
    contactPhone: number
    industry: number
    companySize: number
    leadScore: number
    scoreTier: number
    scoreReason: number
    budgetRange: number
    timeline: number
    needDescription: number
    convertedAt: number
    lostAt: number
    lossReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeadAvgAggregateInputType = {
    leadScore?: true
  }

  export type LeadSumAggregateInputType = {
    leadScore?: true
  }

  export type LeadMinAggregateInputType = {
    id?: true
    clientId?: true
    ownerId?: true
    source?: true
    sourceDetails?: true
    status?: true
    companyName?: true
    contactName?: true
    contactEmail?: true
    contactPhone?: true
    industry?: true
    companySize?: true
    leadScore?: true
    scoreTier?: true
    scoreReason?: true
    budgetRange?: true
    timeline?: true
    needDescription?: true
    convertedAt?: true
    lostAt?: true
    lossReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    clientId?: true
    ownerId?: true
    source?: true
    sourceDetails?: true
    status?: true
    companyName?: true
    contactName?: true
    contactEmail?: true
    contactPhone?: true
    industry?: true
    companySize?: true
    leadScore?: true
    scoreTier?: true
    scoreReason?: true
    budgetRange?: true
    timeline?: true
    needDescription?: true
    convertedAt?: true
    lostAt?: true
    lossReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    clientId?: true
    ownerId?: true
    source?: true
    sourceDetails?: true
    status?: true
    companyName?: true
    contactName?: true
    contactEmail?: true
    contactPhone?: true
    industry?: true
    companySize?: true
    leadScore?: true
    scoreTier?: true
    scoreReason?: true
    budgetRange?: true
    timeline?: true
    needDescription?: true
    convertedAt?: true
    lostAt?: true
    lossReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _avg?: LeadAvgAggregateInputType
    _sum?: LeadSumAggregateInputType
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    clientId: string | null
    ownerId: string
    source: string
    sourceDetails: string | null
    status: $Enums.LeadStatus
    companyName: string
    contactName: string
    contactEmail: string
    contactPhone: string | null
    industry: string | null
    companySize: string | null
    leadScore: number
    scoreTier: string
    scoreReason: string | null
    budgetRange: string | null
    timeline: string | null
    needDescription: string | null
    convertedAt: Date | null
    lostAt: Date | null
    lossReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    ownerId?: boolean
    source?: boolean
    sourceDetails?: boolean
    status?: boolean
    companyName?: boolean
    contactName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    industry?: boolean
    companySize?: boolean
    leadScore?: boolean
    scoreTier?: boolean
    scoreReason?: boolean
    budgetRange?: boolean
    timeline?: boolean
    needDescription?: boolean
    convertedAt?: boolean
    lostAt?: boolean
    lossReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | Lead$clientArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    activities?: boolean | Lead$activitiesArgs<ExtArgs>
    opportunities?: boolean | Lead$opportunitiesArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    ownerId?: boolean
    source?: boolean
    sourceDetails?: boolean
    status?: boolean
    companyName?: boolean
    contactName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    industry?: boolean
    companySize?: boolean
    leadScore?: boolean
    scoreTier?: boolean
    scoreReason?: boolean
    budgetRange?: boolean
    timeline?: boolean
    needDescription?: boolean
    convertedAt?: boolean
    lostAt?: boolean
    lossReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | Lead$clientArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectScalar = {
    id?: boolean
    clientId?: boolean
    ownerId?: boolean
    source?: boolean
    sourceDetails?: boolean
    status?: boolean
    companyName?: boolean
    contactName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    industry?: boolean
    companySize?: boolean
    leadScore?: boolean
    scoreTier?: boolean
    scoreReason?: boolean
    budgetRange?: boolean
    timeline?: boolean
    needDescription?: boolean
    convertedAt?: boolean
    lostAt?: boolean
    lossReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Lead$clientArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    activities?: boolean | Lead$activitiesArgs<ExtArgs>
    opportunities?: boolean | Lead$opportunitiesArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Lead$clientArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      owner: Prisma.$UserPayload<ExtArgs>
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      opportunities: Prisma.$OpportunityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string | null
      ownerId: string
      source: string
      sourceDetails: string | null
      status: $Enums.LeadStatus
      companyName: string
      contactName: string
      contactEmail: string
      contactPhone: string | null
      industry: string | null
      companySize: string | null
      leadScore: number
      scoreTier: string
      scoreReason: string | null
      budgetRange: string | null
      timeline: string | null
      needDescription: string | null
      convertedAt: Date | null
      lostAt: Date | null
      lossReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leads and returns the data saved in the database.
     * @param {LeadCreateManyAndReturnArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends Lead$clientArgs<ExtArgs> = {}>(args?: Subset<T, Lead$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    activities<T extends Lead$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Lead$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    opportunities<T extends Lead$opportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, Lead$opportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */ 
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly clientId: FieldRef<"Lead", 'String'>
    readonly ownerId: FieldRef<"Lead", 'String'>
    readonly source: FieldRef<"Lead", 'String'>
    readonly sourceDetails: FieldRef<"Lead", 'String'>
    readonly status: FieldRef<"Lead", 'LeadStatus'>
    readonly companyName: FieldRef<"Lead", 'String'>
    readonly contactName: FieldRef<"Lead", 'String'>
    readonly contactEmail: FieldRef<"Lead", 'String'>
    readonly contactPhone: FieldRef<"Lead", 'String'>
    readonly industry: FieldRef<"Lead", 'String'>
    readonly companySize: FieldRef<"Lead", 'String'>
    readonly leadScore: FieldRef<"Lead", 'Int'>
    readonly scoreTier: FieldRef<"Lead", 'String'>
    readonly scoreReason: FieldRef<"Lead", 'String'>
    readonly budgetRange: FieldRef<"Lead", 'String'>
    readonly timeline: FieldRef<"Lead", 'String'>
    readonly needDescription: FieldRef<"Lead", 'String'>
    readonly convertedAt: FieldRef<"Lead", 'DateTime'>
    readonly lostAt: FieldRef<"Lead", 'DateTime'>
    readonly lossReason: FieldRef<"Lead", 'String'>
    readonly createdAt: FieldRef<"Lead", 'DateTime'>
    readonly updatedAt: FieldRef<"Lead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lead createManyAndReturn
   */
  export type LeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
  }

  /**
   * Lead.client
   */
  export type Lead$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Lead.activities
   */
  export type Lead$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Lead.opportunities
   */
  export type Lead$opportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    cursor?: OpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
  }


  /**
   * Model Opportunity
   */

  export type AggregateOpportunity = {
    _count: OpportunityCountAggregateOutputType | null
    _avg: OpportunityAvgAggregateOutputType | null
    _sum: OpportunitySumAggregateOutputType | null
    _min: OpportunityMinAggregateOutputType | null
    _max: OpportunityMaxAggregateOutputType | null
  }

  export type OpportunityAvgAggregateOutputType = {
    probability: number | null
    estimatedValue: number | null
    weightedValue: number | null
  }

  export type OpportunitySumAggregateOutputType = {
    probability: number | null
    estimatedValue: number | null
    weightedValue: number | null
  }

  export type OpportunityMinAggregateOutputType = {
    id: string | null
    leadId: string | null
    clientId: string | null
    ownerId: string | null
    name: string | null
    stage: $Enums.OpportunityStage | null
    probability: number | null
    expectedCloseDate: Date | null
    actualCloseDate: Date | null
    estimatedValue: number | null
    weightedValue: number | null
    nextStep: string | null
    nextStepDate: Date | null
    lostReason: string | null
    wonReason: string | null
    solutionType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OpportunityMaxAggregateOutputType = {
    id: string | null
    leadId: string | null
    clientId: string | null
    ownerId: string | null
    name: string | null
    stage: $Enums.OpportunityStage | null
    probability: number | null
    expectedCloseDate: Date | null
    actualCloseDate: Date | null
    estimatedValue: number | null
    weightedValue: number | null
    nextStep: string | null
    nextStepDate: Date | null
    lostReason: string | null
    wonReason: string | null
    solutionType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OpportunityCountAggregateOutputType = {
    id: number
    leadId: number
    clientId: number
    ownerId: number
    name: number
    stage: number
    probability: number
    expectedCloseDate: number
    actualCloseDate: number
    estimatedValue: number
    weightedValue: number
    nextStep: number
    nextStepDate: number
    lostReason: number
    wonReason: number
    solutionType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OpportunityAvgAggregateInputType = {
    probability?: true
    estimatedValue?: true
    weightedValue?: true
  }

  export type OpportunitySumAggregateInputType = {
    probability?: true
    estimatedValue?: true
    weightedValue?: true
  }

  export type OpportunityMinAggregateInputType = {
    id?: true
    leadId?: true
    clientId?: true
    ownerId?: true
    name?: true
    stage?: true
    probability?: true
    expectedCloseDate?: true
    actualCloseDate?: true
    estimatedValue?: true
    weightedValue?: true
    nextStep?: true
    nextStepDate?: true
    lostReason?: true
    wonReason?: true
    solutionType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OpportunityMaxAggregateInputType = {
    id?: true
    leadId?: true
    clientId?: true
    ownerId?: true
    name?: true
    stage?: true
    probability?: true
    expectedCloseDate?: true
    actualCloseDate?: true
    estimatedValue?: true
    weightedValue?: true
    nextStep?: true
    nextStepDate?: true
    lostReason?: true
    wonReason?: true
    solutionType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OpportunityCountAggregateInputType = {
    id?: true
    leadId?: true
    clientId?: true
    ownerId?: true
    name?: true
    stage?: true
    probability?: true
    expectedCloseDate?: true
    actualCloseDate?: true
    estimatedValue?: true
    weightedValue?: true
    nextStep?: true
    nextStepDate?: true
    lostReason?: true
    wonReason?: true
    solutionType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OpportunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Opportunity to aggregate.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Opportunities
    **/
    _count?: true | OpportunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OpportunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OpportunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpportunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpportunityMaxAggregateInputType
  }

  export type GetOpportunityAggregateType<T extends OpportunityAggregateArgs> = {
        [P in keyof T & keyof AggregateOpportunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpportunity[P]>
      : GetScalarType<T[P], AggregateOpportunity[P]>
  }




  export type OpportunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithAggregationInput | OpportunityOrderByWithAggregationInput[]
    by: OpportunityScalarFieldEnum[] | OpportunityScalarFieldEnum
    having?: OpportunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpportunityCountAggregateInputType | true
    _avg?: OpportunityAvgAggregateInputType
    _sum?: OpportunitySumAggregateInputType
    _min?: OpportunityMinAggregateInputType
    _max?: OpportunityMaxAggregateInputType
  }

  export type OpportunityGroupByOutputType = {
    id: string
    leadId: string | null
    clientId: string | null
    ownerId: string
    name: string
    stage: $Enums.OpportunityStage
    probability: number
    expectedCloseDate: Date | null
    actualCloseDate: Date | null
    estimatedValue: number
    weightedValue: number
    nextStep: string | null
    nextStepDate: Date | null
    lostReason: string | null
    wonReason: string | null
    solutionType: string | null
    createdAt: Date
    updatedAt: Date
    _count: OpportunityCountAggregateOutputType | null
    _avg: OpportunityAvgAggregateOutputType | null
    _sum: OpportunitySumAggregateOutputType | null
    _min: OpportunityMinAggregateOutputType | null
    _max: OpportunityMaxAggregateOutputType | null
  }

  type GetOpportunityGroupByPayload<T extends OpportunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpportunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpportunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpportunityGroupByOutputType[P]>
            : GetScalarType<T[P], OpportunityGroupByOutputType[P]>
        }
      >
    >


  export type OpportunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leadId?: boolean
    clientId?: boolean
    ownerId?: boolean
    name?: boolean
    stage?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    actualCloseDate?: boolean
    estimatedValue?: boolean
    weightedValue?: boolean
    nextStep?: boolean
    nextStepDate?: boolean
    lostReason?: boolean
    wonReason?: boolean
    solutionType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lead?: boolean | Opportunity$leadArgs<ExtArgs>
    client?: boolean | Opportunity$clientArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    activities?: boolean | Opportunity$activitiesArgs<ExtArgs>
    proposals?: boolean | Opportunity$proposalsArgs<ExtArgs>
    project?: boolean | Opportunity$projectArgs<ExtArgs>
    _count?: boolean | OpportunityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leadId?: boolean
    clientId?: boolean
    ownerId?: boolean
    name?: boolean
    stage?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    actualCloseDate?: boolean
    estimatedValue?: boolean
    weightedValue?: boolean
    nextStep?: boolean
    nextStepDate?: boolean
    lostReason?: boolean
    wonReason?: boolean
    solutionType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lead?: boolean | Opportunity$leadArgs<ExtArgs>
    client?: boolean | Opportunity$clientArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectScalar = {
    id?: boolean
    leadId?: boolean
    clientId?: boolean
    ownerId?: boolean
    name?: boolean
    stage?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    actualCloseDate?: boolean
    estimatedValue?: boolean
    weightedValue?: boolean
    nextStep?: boolean
    nextStepDate?: boolean
    lostReason?: boolean
    wonReason?: boolean
    solutionType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OpportunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lead?: boolean | Opportunity$leadArgs<ExtArgs>
    client?: boolean | Opportunity$clientArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    activities?: boolean | Opportunity$activitiesArgs<ExtArgs>
    proposals?: boolean | Opportunity$proposalsArgs<ExtArgs>
    project?: boolean | Opportunity$projectArgs<ExtArgs>
    _count?: boolean | OpportunityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OpportunityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lead?: boolean | Opportunity$leadArgs<ExtArgs>
    client?: boolean | Opportunity$clientArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OpportunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Opportunity"
    objects: {
      lead: Prisma.$LeadPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
      owner: Prisma.$UserPayload<ExtArgs>
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      proposals: Prisma.$ProposalPayload<ExtArgs>[]
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leadId: string | null
      clientId: string | null
      ownerId: string
      name: string
      stage: $Enums.OpportunityStage
      probability: number
      expectedCloseDate: Date | null
      actualCloseDate: Date | null
      estimatedValue: number
      weightedValue: number
      nextStep: string | null
      nextStepDate: Date | null
      lostReason: string | null
      wonReason: string | null
      solutionType: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["opportunity"]>
    composites: {}
  }

  type OpportunityGetPayload<S extends boolean | null | undefined | OpportunityDefaultArgs> = $Result.GetResult<Prisma.$OpportunityPayload, S>

  type OpportunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OpportunityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OpportunityCountAggregateInputType | true
    }

  export interface OpportunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Opportunity'], meta: { name: 'Opportunity' } }
    /**
     * Find zero or one Opportunity that matches the filter.
     * @param {OpportunityFindUniqueArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpportunityFindUniqueArgs>(args: SelectSubset<T, OpportunityFindUniqueArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Opportunity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OpportunityFindUniqueOrThrowArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpportunityFindUniqueOrThrowArgs>(args: SelectSubset<T, OpportunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Opportunity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindFirstArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpportunityFindFirstArgs>(args?: SelectSubset<T, OpportunityFindFirstArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Opportunity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindFirstOrThrowArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpportunityFindFirstOrThrowArgs>(args?: SelectSubset<T, OpportunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Opportunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Opportunities
     * const opportunities = await prisma.opportunity.findMany()
     * 
     * // Get first 10 Opportunities
     * const opportunities = await prisma.opportunity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpportunityFindManyArgs>(args?: SelectSubset<T, OpportunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Opportunity.
     * @param {OpportunityCreateArgs} args - Arguments to create a Opportunity.
     * @example
     * // Create one Opportunity
     * const Opportunity = await prisma.opportunity.create({
     *   data: {
     *     // ... data to create a Opportunity
     *   }
     * })
     * 
     */
    create<T extends OpportunityCreateArgs>(args: SelectSubset<T, OpportunityCreateArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Opportunities.
     * @param {OpportunityCreateManyArgs} args - Arguments to create many Opportunities.
     * @example
     * // Create many Opportunities
     * const opportunity = await prisma.opportunity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpportunityCreateManyArgs>(args?: SelectSubset<T, OpportunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Opportunities and returns the data saved in the database.
     * @param {OpportunityCreateManyAndReturnArgs} args - Arguments to create many Opportunities.
     * @example
     * // Create many Opportunities
     * const opportunity = await prisma.opportunity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Opportunities and only return the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpportunityCreateManyAndReturnArgs>(args?: SelectSubset<T, OpportunityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Opportunity.
     * @param {OpportunityDeleteArgs} args - Arguments to delete one Opportunity.
     * @example
     * // Delete one Opportunity
     * const Opportunity = await prisma.opportunity.delete({
     *   where: {
     *     // ... filter to delete one Opportunity
     *   }
     * })
     * 
     */
    delete<T extends OpportunityDeleteArgs>(args: SelectSubset<T, OpportunityDeleteArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Opportunity.
     * @param {OpportunityUpdateArgs} args - Arguments to update one Opportunity.
     * @example
     * // Update one Opportunity
     * const opportunity = await prisma.opportunity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpportunityUpdateArgs>(args: SelectSubset<T, OpportunityUpdateArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Opportunities.
     * @param {OpportunityDeleteManyArgs} args - Arguments to filter Opportunities to delete.
     * @example
     * // Delete a few Opportunities
     * const { count } = await prisma.opportunity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpportunityDeleteManyArgs>(args?: SelectSubset<T, OpportunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Opportunities
     * const opportunity = await prisma.opportunity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpportunityUpdateManyArgs>(args: SelectSubset<T, OpportunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Opportunity.
     * @param {OpportunityUpsertArgs} args - Arguments to update or create a Opportunity.
     * @example
     * // Update or create a Opportunity
     * const opportunity = await prisma.opportunity.upsert({
     *   create: {
     *     // ... data to create a Opportunity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Opportunity we want to update
     *   }
     * })
     */
    upsert<T extends OpportunityUpsertArgs>(args: SelectSubset<T, OpportunityUpsertArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityCountArgs} args - Arguments to filter Opportunities to count.
     * @example
     * // Count the number of Opportunities
     * const count = await prisma.opportunity.count({
     *   where: {
     *     // ... the filter for the Opportunities we want to count
     *   }
     * })
    **/
    count<T extends OpportunityCountArgs>(
      args?: Subset<T, OpportunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpportunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Opportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpportunityAggregateArgs>(args: Subset<T, OpportunityAggregateArgs>): Prisma.PrismaPromise<GetOpportunityAggregateType<T>>

    /**
     * Group by Opportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpportunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpportunityGroupByArgs['orderBy'] }
        : { orderBy?: OpportunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpportunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpportunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Opportunity model
   */
  readonly fields: OpportunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Opportunity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpportunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lead<T extends Opportunity$leadArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    client<T extends Opportunity$clientArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    activities<T extends Opportunity$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    proposals<T extends Opportunity$proposalsArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$proposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findMany"> | Null>
    project<T extends Opportunity$projectArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Opportunity model
   */ 
  interface OpportunityFieldRefs {
    readonly id: FieldRef<"Opportunity", 'String'>
    readonly leadId: FieldRef<"Opportunity", 'String'>
    readonly clientId: FieldRef<"Opportunity", 'String'>
    readonly ownerId: FieldRef<"Opportunity", 'String'>
    readonly name: FieldRef<"Opportunity", 'String'>
    readonly stage: FieldRef<"Opportunity", 'OpportunityStage'>
    readonly probability: FieldRef<"Opportunity", 'Int'>
    readonly expectedCloseDate: FieldRef<"Opportunity", 'DateTime'>
    readonly actualCloseDate: FieldRef<"Opportunity", 'DateTime'>
    readonly estimatedValue: FieldRef<"Opportunity", 'Float'>
    readonly weightedValue: FieldRef<"Opportunity", 'Float'>
    readonly nextStep: FieldRef<"Opportunity", 'String'>
    readonly nextStepDate: FieldRef<"Opportunity", 'DateTime'>
    readonly lostReason: FieldRef<"Opportunity", 'String'>
    readonly wonReason: FieldRef<"Opportunity", 'String'>
    readonly solutionType: FieldRef<"Opportunity", 'String'>
    readonly createdAt: FieldRef<"Opportunity", 'DateTime'>
    readonly updatedAt: FieldRef<"Opportunity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Opportunity findUnique
   */
  export type OpportunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity findUniqueOrThrow
   */
  export type OpportunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity findFirst
   */
  export type OpportunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Opportunities.
     */
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Opportunity findFirstOrThrow
   */
  export type OpportunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Opportunities.
     */
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Opportunity findMany
   */
  export type OpportunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunities to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Opportunity create
   */
  export type OpportunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The data needed to create a Opportunity.
     */
    data: XOR<OpportunityCreateInput, OpportunityUncheckedCreateInput>
  }

  /**
   * Opportunity createMany
   */
  export type OpportunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Opportunities.
     */
    data: OpportunityCreateManyInput | OpportunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Opportunity createManyAndReturn
   */
  export type OpportunityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Opportunities.
     */
    data: OpportunityCreateManyInput | OpportunityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Opportunity update
   */
  export type OpportunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The data needed to update a Opportunity.
     */
    data: XOR<OpportunityUpdateInput, OpportunityUncheckedUpdateInput>
    /**
     * Choose, which Opportunity to update.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity updateMany
   */
  export type OpportunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Opportunities.
     */
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyInput>
    /**
     * Filter which Opportunities to update
     */
    where?: OpportunityWhereInput
  }

  /**
   * Opportunity upsert
   */
  export type OpportunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The filter to search for the Opportunity to update in case it exists.
     */
    where: OpportunityWhereUniqueInput
    /**
     * In case the Opportunity found by the `where` argument doesn't exist, create a new Opportunity with this data.
     */
    create: XOR<OpportunityCreateInput, OpportunityUncheckedCreateInput>
    /**
     * In case the Opportunity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpportunityUpdateInput, OpportunityUncheckedUpdateInput>
  }

  /**
   * Opportunity delete
   */
  export type OpportunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter which Opportunity to delete.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity deleteMany
   */
  export type OpportunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Opportunities to delete
     */
    where?: OpportunityWhereInput
  }

  /**
   * Opportunity.lead
   */
  export type Opportunity$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * Opportunity.client
   */
  export type Opportunity$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Opportunity.activities
   */
  export type Opportunity$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Opportunity.proposals
   */
  export type Opportunity$proposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    where?: ProposalWhereInput
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    cursor?: ProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Opportunity.project
   */
  export type Opportunity$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Opportunity without action
   */
  export type OpportunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
  }


  /**
   * Model Proposal
   */

  export type AggregateProposal = {
    _count: ProposalCountAggregateOutputType | null
    _avg: ProposalAvgAggregateOutputType | null
    _sum: ProposalSumAggregateOutputType | null
    _min: ProposalMinAggregateOutputType | null
    _max: ProposalMaxAggregateOutputType | null
  }

  export type ProposalAvgAggregateOutputType = {
    version: number | null
    timelineWeeks: number | null
    basePrice: number | null
    discount: number | null
    finalPrice: number | null
  }

  export type ProposalSumAggregateOutputType = {
    version: number | null
    timelineWeeks: number | null
    basePrice: number | null
    discount: number | null
    finalPrice: number | null
  }

  export type ProposalMinAggregateOutputType = {
    id: string | null
    opportunityId: string | null
    version: number | null
    title: string | null
    solutionDescription: string | null
    implementationPlan: string | null
    timelineWeeks: number | null
    basePrice: number | null
    discount: number | null
    finalPrice: number | null
    terms: string | null
    status: string | null
    approvalStatus: string | null
    approvedBy: string | null
    approvedAt: Date | null
    signedAt: Date | null
    documentUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProposalMaxAggregateOutputType = {
    id: string | null
    opportunityId: string | null
    version: number | null
    title: string | null
    solutionDescription: string | null
    implementationPlan: string | null
    timelineWeeks: number | null
    basePrice: number | null
    discount: number | null
    finalPrice: number | null
    terms: string | null
    status: string | null
    approvalStatus: string | null
    approvedBy: string | null
    approvedAt: Date | null
    signedAt: Date | null
    documentUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProposalCountAggregateOutputType = {
    id: number
    opportunityId: number
    version: number
    title: number
    content: number
    solutionDescription: number
    implementationPlan: number
    timelineWeeks: number
    basePrice: number
    discount: number
    finalPrice: number
    terms: number
    status: number
    approvalStatus: number
    approvedBy: number
    approvedAt: number
    signedAt: number
    documentUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProposalAvgAggregateInputType = {
    version?: true
    timelineWeeks?: true
    basePrice?: true
    discount?: true
    finalPrice?: true
  }

  export type ProposalSumAggregateInputType = {
    version?: true
    timelineWeeks?: true
    basePrice?: true
    discount?: true
    finalPrice?: true
  }

  export type ProposalMinAggregateInputType = {
    id?: true
    opportunityId?: true
    version?: true
    title?: true
    solutionDescription?: true
    implementationPlan?: true
    timelineWeeks?: true
    basePrice?: true
    discount?: true
    finalPrice?: true
    terms?: true
    status?: true
    approvalStatus?: true
    approvedBy?: true
    approvedAt?: true
    signedAt?: true
    documentUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProposalMaxAggregateInputType = {
    id?: true
    opportunityId?: true
    version?: true
    title?: true
    solutionDescription?: true
    implementationPlan?: true
    timelineWeeks?: true
    basePrice?: true
    discount?: true
    finalPrice?: true
    terms?: true
    status?: true
    approvalStatus?: true
    approvedBy?: true
    approvedAt?: true
    signedAt?: true
    documentUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProposalCountAggregateInputType = {
    id?: true
    opportunityId?: true
    version?: true
    title?: true
    content?: true
    solutionDescription?: true
    implementationPlan?: true
    timelineWeeks?: true
    basePrice?: true
    discount?: true
    finalPrice?: true
    terms?: true
    status?: true
    approvalStatus?: true
    approvedBy?: true
    approvedAt?: true
    signedAt?: true
    documentUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProposalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proposal to aggregate.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proposals
    **/
    _count?: true | ProposalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProposalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProposalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProposalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProposalMaxAggregateInputType
  }

  export type GetProposalAggregateType<T extends ProposalAggregateArgs> = {
        [P in keyof T & keyof AggregateProposal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProposal[P]>
      : GetScalarType<T[P], AggregateProposal[P]>
  }




  export type ProposalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalWhereInput
    orderBy?: ProposalOrderByWithAggregationInput | ProposalOrderByWithAggregationInput[]
    by: ProposalScalarFieldEnum[] | ProposalScalarFieldEnum
    having?: ProposalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProposalCountAggregateInputType | true
    _avg?: ProposalAvgAggregateInputType
    _sum?: ProposalSumAggregateInputType
    _min?: ProposalMinAggregateInputType
    _max?: ProposalMaxAggregateInputType
  }

  export type ProposalGroupByOutputType = {
    id: string
    opportunityId: string
    version: number
    title: string
    content: JsonValue | null
    solutionDescription: string | null
    implementationPlan: string | null
    timelineWeeks: number | null
    basePrice: number
    discount: number
    finalPrice: number
    terms: string | null
    status: string
    approvalStatus: string
    approvedBy: string | null
    approvedAt: Date | null
    signedAt: Date | null
    documentUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProposalCountAggregateOutputType | null
    _avg: ProposalAvgAggregateOutputType | null
    _sum: ProposalSumAggregateOutputType | null
    _min: ProposalMinAggregateOutputType | null
    _max: ProposalMaxAggregateOutputType | null
  }

  type GetProposalGroupByPayload<T extends ProposalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProposalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProposalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProposalGroupByOutputType[P]>
            : GetScalarType<T[P], ProposalGroupByOutputType[P]>
        }
      >
    >


  export type ProposalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    opportunityId?: boolean
    version?: boolean
    title?: boolean
    content?: boolean
    solutionDescription?: boolean
    implementationPlan?: boolean
    timelineWeeks?: boolean
    basePrice?: boolean
    discount?: boolean
    finalPrice?: boolean
    terms?: boolean
    status?: boolean
    approvalStatus?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    signedAt?: boolean
    documentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposal"]>

  export type ProposalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    opportunityId?: boolean
    version?: boolean
    title?: boolean
    content?: boolean
    solutionDescription?: boolean
    implementationPlan?: boolean
    timelineWeeks?: boolean
    basePrice?: boolean
    discount?: boolean
    finalPrice?: boolean
    terms?: boolean
    status?: boolean
    approvalStatus?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    signedAt?: boolean
    documentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposal"]>

  export type ProposalSelectScalar = {
    id?: boolean
    opportunityId?: boolean
    version?: boolean
    title?: boolean
    content?: boolean
    solutionDescription?: boolean
    implementationPlan?: boolean
    timelineWeeks?: boolean
    basePrice?: boolean
    discount?: boolean
    finalPrice?: boolean
    terms?: boolean
    status?: boolean
    approvalStatus?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    signedAt?: boolean
    documentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProposalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }
  export type ProposalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }

  export type $ProposalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proposal"
    objects: {
      opportunity: Prisma.$OpportunityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      opportunityId: string
      version: number
      title: string
      content: Prisma.JsonValue | null
      solutionDescription: string | null
      implementationPlan: string | null
      timelineWeeks: number | null
      basePrice: number
      discount: number
      finalPrice: number
      terms: string | null
      status: string
      approvalStatus: string
      approvedBy: string | null
      approvedAt: Date | null
      signedAt: Date | null
      documentUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["proposal"]>
    composites: {}
  }

  type ProposalGetPayload<S extends boolean | null | undefined | ProposalDefaultArgs> = $Result.GetResult<Prisma.$ProposalPayload, S>

  type ProposalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProposalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProposalCountAggregateInputType | true
    }

  export interface ProposalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proposal'], meta: { name: 'Proposal' } }
    /**
     * Find zero or one Proposal that matches the filter.
     * @param {ProposalFindUniqueArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProposalFindUniqueArgs>(args: SelectSubset<T, ProposalFindUniqueArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Proposal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProposalFindUniqueOrThrowArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProposalFindUniqueOrThrowArgs>(args: SelectSubset<T, ProposalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Proposal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindFirstArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProposalFindFirstArgs>(args?: SelectSubset<T, ProposalFindFirstArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Proposal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindFirstOrThrowArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProposalFindFirstOrThrowArgs>(args?: SelectSubset<T, ProposalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Proposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proposals
     * const proposals = await prisma.proposal.findMany()
     * 
     * // Get first 10 Proposals
     * const proposals = await prisma.proposal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proposalWithIdOnly = await prisma.proposal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProposalFindManyArgs>(args?: SelectSubset<T, ProposalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Proposal.
     * @param {ProposalCreateArgs} args - Arguments to create a Proposal.
     * @example
     * // Create one Proposal
     * const Proposal = await prisma.proposal.create({
     *   data: {
     *     // ... data to create a Proposal
     *   }
     * })
     * 
     */
    create<T extends ProposalCreateArgs>(args: SelectSubset<T, ProposalCreateArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Proposals.
     * @param {ProposalCreateManyArgs} args - Arguments to create many Proposals.
     * @example
     * // Create many Proposals
     * const proposal = await prisma.proposal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProposalCreateManyArgs>(args?: SelectSubset<T, ProposalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Proposals and returns the data saved in the database.
     * @param {ProposalCreateManyAndReturnArgs} args - Arguments to create many Proposals.
     * @example
     * // Create many Proposals
     * const proposal = await prisma.proposal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Proposals and only return the `id`
     * const proposalWithIdOnly = await prisma.proposal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProposalCreateManyAndReturnArgs>(args?: SelectSubset<T, ProposalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Proposal.
     * @param {ProposalDeleteArgs} args - Arguments to delete one Proposal.
     * @example
     * // Delete one Proposal
     * const Proposal = await prisma.proposal.delete({
     *   where: {
     *     // ... filter to delete one Proposal
     *   }
     * })
     * 
     */
    delete<T extends ProposalDeleteArgs>(args: SelectSubset<T, ProposalDeleteArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Proposal.
     * @param {ProposalUpdateArgs} args - Arguments to update one Proposal.
     * @example
     * // Update one Proposal
     * const proposal = await prisma.proposal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProposalUpdateArgs>(args: SelectSubset<T, ProposalUpdateArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Proposals.
     * @param {ProposalDeleteManyArgs} args - Arguments to filter Proposals to delete.
     * @example
     * // Delete a few Proposals
     * const { count } = await prisma.proposal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProposalDeleteManyArgs>(args?: SelectSubset<T, ProposalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proposals
     * const proposal = await prisma.proposal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProposalUpdateManyArgs>(args: SelectSubset<T, ProposalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proposal.
     * @param {ProposalUpsertArgs} args - Arguments to update or create a Proposal.
     * @example
     * // Update or create a Proposal
     * const proposal = await prisma.proposal.upsert({
     *   create: {
     *     // ... data to create a Proposal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proposal we want to update
     *   }
     * })
     */
    upsert<T extends ProposalUpsertArgs>(args: SelectSubset<T, ProposalUpsertArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCountArgs} args - Arguments to filter Proposals to count.
     * @example
     * // Count the number of Proposals
     * const count = await prisma.proposal.count({
     *   where: {
     *     // ... the filter for the Proposals we want to count
     *   }
     * })
    **/
    count<T extends ProposalCountArgs>(
      args?: Subset<T, ProposalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProposalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProposalAggregateArgs>(args: Subset<T, ProposalAggregateArgs>): Prisma.PrismaPromise<GetProposalAggregateType<T>>

    /**
     * Group by Proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProposalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProposalGroupByArgs['orderBy'] }
        : { orderBy?: ProposalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProposalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProposalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proposal model
   */
  readonly fields: ProposalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proposal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProposalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    opportunity<T extends OpportunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpportunityDefaultArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Proposal model
   */ 
  interface ProposalFieldRefs {
    readonly id: FieldRef<"Proposal", 'String'>
    readonly opportunityId: FieldRef<"Proposal", 'String'>
    readonly version: FieldRef<"Proposal", 'Int'>
    readonly title: FieldRef<"Proposal", 'String'>
    readonly content: FieldRef<"Proposal", 'Json'>
    readonly solutionDescription: FieldRef<"Proposal", 'String'>
    readonly implementationPlan: FieldRef<"Proposal", 'String'>
    readonly timelineWeeks: FieldRef<"Proposal", 'Int'>
    readonly basePrice: FieldRef<"Proposal", 'Float'>
    readonly discount: FieldRef<"Proposal", 'Float'>
    readonly finalPrice: FieldRef<"Proposal", 'Float'>
    readonly terms: FieldRef<"Proposal", 'String'>
    readonly status: FieldRef<"Proposal", 'String'>
    readonly approvalStatus: FieldRef<"Proposal", 'String'>
    readonly approvedBy: FieldRef<"Proposal", 'String'>
    readonly approvedAt: FieldRef<"Proposal", 'DateTime'>
    readonly signedAt: FieldRef<"Proposal", 'DateTime'>
    readonly documentUrl: FieldRef<"Proposal", 'String'>
    readonly createdAt: FieldRef<"Proposal", 'DateTime'>
    readonly updatedAt: FieldRef<"Proposal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Proposal findUnique
   */
  export type ProposalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal findUniqueOrThrow
   */
  export type ProposalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal findFirst
   */
  export type ProposalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proposals.
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proposals.
     */
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Proposal findFirstOrThrow
   */
  export type ProposalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proposals.
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proposals.
     */
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Proposal findMany
   */
  export type ProposalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposals to fetch.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proposals.
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Proposal create
   */
  export type ProposalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * The data needed to create a Proposal.
     */
    data: XOR<ProposalCreateInput, ProposalUncheckedCreateInput>
  }

  /**
   * Proposal createMany
   */
  export type ProposalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Proposals.
     */
    data: ProposalCreateManyInput | ProposalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Proposal createManyAndReturn
   */
  export type ProposalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Proposals.
     */
    data: ProposalCreateManyInput | ProposalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Proposal update
   */
  export type ProposalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * The data needed to update a Proposal.
     */
    data: XOR<ProposalUpdateInput, ProposalUncheckedUpdateInput>
    /**
     * Choose, which Proposal to update.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal updateMany
   */
  export type ProposalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Proposals.
     */
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyInput>
    /**
     * Filter which Proposals to update
     */
    where?: ProposalWhereInput
  }

  /**
   * Proposal upsert
   */
  export type ProposalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * The filter to search for the Proposal to update in case it exists.
     */
    where: ProposalWhereUniqueInput
    /**
     * In case the Proposal found by the `where` argument doesn't exist, create a new Proposal with this data.
     */
    create: XOR<ProposalCreateInput, ProposalUncheckedCreateInput>
    /**
     * In case the Proposal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProposalUpdateInput, ProposalUncheckedUpdateInput>
  }

  /**
   * Proposal delete
   */
  export type ProposalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter which Proposal to delete.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal deleteMany
   */
  export type ProposalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proposals to delete
     */
    where?: ProposalWhereInput
  }

  /**
   * Proposal without action
   */
  export type ProposalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    budget: number | null
    actualCost: number | null
    completionPercentage: number | null
  }

  export type ProjectSumAggregateOutputType = {
    budget: number | null
    actualCost: number | null
    completionPercentage: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    opportunityId: string | null
    clientId: string | null
    name: string | null
    description: string | null
    status: $Enums.ProjectStatus | null
    startDate: Date | null
    endDate: Date | null
    actualEndDate: Date | null
    budget: number | null
    actualCost: number | null
    projectManagerId: string | null
    solutionType: string | null
    healthStatus: string | null
    completionPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    opportunityId: string | null
    clientId: string | null
    name: string | null
    description: string | null
    status: $Enums.ProjectStatus | null
    startDate: Date | null
    endDate: Date | null
    actualEndDate: Date | null
    budget: number | null
    actualCost: number | null
    projectManagerId: string | null
    solutionType: string | null
    healthStatus: string | null
    completionPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    opportunityId: number
    clientId: number
    name: number
    description: number
    status: number
    startDate: number
    endDate: number
    actualEndDate: number
    budget: number
    actualCost: number
    projectManagerId: number
    solutionType: number
    healthStatus: number
    completionPercentage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    budget?: true
    actualCost?: true
    completionPercentage?: true
  }

  export type ProjectSumAggregateInputType = {
    budget?: true
    actualCost?: true
    completionPercentage?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    opportunityId?: true
    clientId?: true
    name?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    actualEndDate?: true
    budget?: true
    actualCost?: true
    projectManagerId?: true
    solutionType?: true
    healthStatus?: true
    completionPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    opportunityId?: true
    clientId?: true
    name?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    actualEndDate?: true
    budget?: true
    actualCost?: true
    projectManagerId?: true
    solutionType?: true
    healthStatus?: true
    completionPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    opportunityId?: true
    clientId?: true
    name?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    actualEndDate?: true
    budget?: true
    actualCost?: true
    projectManagerId?: true
    solutionType?: true
    healthStatus?: true
    completionPercentage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    opportunityId: string | null
    clientId: string
    name: string
    description: string | null
    status: $Enums.ProjectStatus
    startDate: Date | null
    endDate: Date | null
    actualEndDate: Date | null
    budget: number
    actualCost: number
    projectManagerId: string | null
    solutionType: string | null
    healthStatus: string
    completionPercentage: number
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    opportunityId?: boolean
    clientId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    actualEndDate?: boolean
    budget?: boolean
    actualCost?: boolean
    projectManagerId?: boolean
    solutionType?: boolean
    healthStatus?: boolean
    completionPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    opportunity?: boolean | Project$opportunityArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    milestones?: boolean | Project$milestonesArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    metrics?: boolean | Project$metricsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    opportunityId?: boolean
    clientId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    actualEndDate?: boolean
    budget?: boolean
    actualCost?: boolean
    projectManagerId?: boolean
    solutionType?: boolean
    healthStatus?: boolean
    completionPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    opportunity?: boolean | Project$opportunityArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    opportunityId?: boolean
    clientId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    actualEndDate?: boolean
    budget?: boolean
    actualCost?: boolean
    projectManagerId?: boolean
    solutionType?: boolean
    healthStatus?: boolean
    completionPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunity?: boolean | Project$opportunityArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    milestones?: boolean | Project$milestonesArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    metrics?: boolean | Project$metricsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunity?: boolean | Project$opportunityArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      opportunity: Prisma.$OpportunityPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs>
      milestones: Prisma.$ProjectMilestonePayload<ExtArgs>[]
      tasks: Prisma.$ProjectTaskPayload<ExtArgs>[]
      metrics: Prisma.$ProjectMetricPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      opportunityId: string | null
      clientId: string
      name: string
      description: string | null
      status: $Enums.ProjectStatus
      startDate: Date | null
      endDate: Date | null
      actualEndDate: Date | null
      budget: number
      actualCost: number
      projectManagerId: string | null
      solutionType: string | null
      healthStatus: string
      completionPercentage: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    opportunity<T extends Project$opportunityArgs<ExtArgs> = {}>(args?: Subset<T, Project$opportunityArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    milestones<T extends Project$milestonesArgs<ExtArgs> = {}>(args?: Subset<T, Project$milestonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMilestonePayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends Project$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Project$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "findMany"> | Null>
    metrics<T extends Project$metricsArgs<ExtArgs> = {}>(args?: Subset<T, Project$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMetricPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly opportunityId: FieldRef<"Project", 'String'>
    readonly clientId: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'ProjectStatus'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly actualEndDate: FieldRef<"Project", 'DateTime'>
    readonly budget: FieldRef<"Project", 'Float'>
    readonly actualCost: FieldRef<"Project", 'Float'>
    readonly projectManagerId: FieldRef<"Project", 'String'>
    readonly solutionType: FieldRef<"Project", 'String'>
    readonly healthStatus: FieldRef<"Project", 'String'>
    readonly completionPercentage: FieldRef<"Project", 'Int'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.opportunity
   */
  export type Project$opportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
  }

  /**
   * Project.milestones
   */
  export type Project$milestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMilestone
     */
    select?: ProjectMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMilestoneInclude<ExtArgs> | null
    where?: ProjectMilestoneWhereInput
    orderBy?: ProjectMilestoneOrderByWithRelationInput | ProjectMilestoneOrderByWithRelationInput[]
    cursor?: ProjectMilestoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMilestoneScalarFieldEnum | ProjectMilestoneScalarFieldEnum[]
  }

  /**
   * Project.tasks
   */
  export type Project$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTaskInclude<ExtArgs> | null
    where?: ProjectTaskWhereInput
    orderBy?: ProjectTaskOrderByWithRelationInput | ProjectTaskOrderByWithRelationInput[]
    cursor?: ProjectTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectTaskScalarFieldEnum | ProjectTaskScalarFieldEnum[]
  }

  /**
   * Project.metrics
   */
  export type Project$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetric
     */
    select?: ProjectMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricInclude<ExtArgs> | null
    where?: ProjectMetricWhereInput
    orderBy?: ProjectMetricOrderByWithRelationInput | ProjectMetricOrderByWithRelationInput[]
    cursor?: ProjectMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMetricScalarFieldEnum | ProjectMetricScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMilestone
   */

  export type AggregateProjectMilestone = {
    _count: ProjectMilestoneCountAggregateOutputType | null
    _avg: ProjectMilestoneAvgAggregateOutputType | null
    _sum: ProjectMilestoneSumAggregateOutputType | null
    _min: ProjectMilestoneMinAggregateOutputType | null
    _max: ProjectMilestoneMaxAggregateOutputType | null
  }

  export type ProjectMilestoneAvgAggregateOutputType = {
    order: number | null
  }

  export type ProjectMilestoneSumAggregateOutputType = {
    order: number | null
  }

  export type ProjectMilestoneMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    description: string | null
    status: $Enums.MilestoneStatus | null
    phase: string | null
    order: number | null
    plannedStartDate: Date | null
    plannedEndDate: Date | null
    actualStartDate: Date | null
    actualEndDate: Date | null
    completionCriteria: string | null
    ownerId: string | null
    dependsOnId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMilestoneMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    description: string | null
    status: $Enums.MilestoneStatus | null
    phase: string | null
    order: number | null
    plannedStartDate: Date | null
    plannedEndDate: Date | null
    actualStartDate: Date | null
    actualEndDate: Date | null
    completionCriteria: string | null
    ownerId: string | null
    dependsOnId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMilestoneCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    description: number
    status: number
    phase: number
    order: number
    plannedStartDate: number
    plannedEndDate: number
    actualStartDate: number
    actualEndDate: number
    completionCriteria: number
    ownerId: number
    dependsOnId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMilestoneAvgAggregateInputType = {
    order?: true
  }

  export type ProjectMilestoneSumAggregateInputType = {
    order?: true
  }

  export type ProjectMilestoneMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    status?: true
    phase?: true
    order?: true
    plannedStartDate?: true
    plannedEndDate?: true
    actualStartDate?: true
    actualEndDate?: true
    completionCriteria?: true
    ownerId?: true
    dependsOnId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMilestoneMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    status?: true
    phase?: true
    order?: true
    plannedStartDate?: true
    plannedEndDate?: true
    actualStartDate?: true
    actualEndDate?: true
    completionCriteria?: true
    ownerId?: true
    dependsOnId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMilestoneCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    status?: true
    phase?: true
    order?: true
    plannedStartDate?: true
    plannedEndDate?: true
    actualStartDate?: true
    actualEndDate?: true
    completionCriteria?: true
    ownerId?: true
    dependsOnId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectMilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMilestone to aggregate.
     */
    where?: ProjectMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMilestones to fetch.
     */
    orderBy?: ProjectMilestoneOrderByWithRelationInput | ProjectMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMilestones
    **/
    _count?: true | ProjectMilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectMilestoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectMilestoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMilestoneMaxAggregateInputType
  }

  export type GetProjectMilestoneAggregateType<T extends ProjectMilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMilestone[P]>
      : GetScalarType<T[P], AggregateProjectMilestone[P]>
  }




  export type ProjectMilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMilestoneWhereInput
    orderBy?: ProjectMilestoneOrderByWithAggregationInput | ProjectMilestoneOrderByWithAggregationInput[]
    by: ProjectMilestoneScalarFieldEnum[] | ProjectMilestoneScalarFieldEnum
    having?: ProjectMilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMilestoneCountAggregateInputType | true
    _avg?: ProjectMilestoneAvgAggregateInputType
    _sum?: ProjectMilestoneSumAggregateInputType
    _min?: ProjectMilestoneMinAggregateInputType
    _max?: ProjectMilestoneMaxAggregateInputType
  }

  export type ProjectMilestoneGroupByOutputType = {
    id: string
    projectId: string
    name: string
    description: string | null
    status: $Enums.MilestoneStatus
    phase: string | null
    order: number
    plannedStartDate: Date | null
    plannedEndDate: Date | null
    actualStartDate: Date | null
    actualEndDate: Date | null
    completionCriteria: string | null
    ownerId: string | null
    dependsOnId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectMilestoneCountAggregateOutputType | null
    _avg: ProjectMilestoneAvgAggregateOutputType | null
    _sum: ProjectMilestoneSumAggregateOutputType | null
    _min: ProjectMilestoneMinAggregateOutputType | null
    _max: ProjectMilestoneMaxAggregateOutputType | null
  }

  type GetProjectMilestoneGroupByPayload<T extends ProjectMilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMilestoneGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    phase?: boolean
    order?: boolean
    plannedStartDate?: boolean
    plannedEndDate?: boolean
    actualStartDate?: boolean
    actualEndDate?: boolean
    completionCriteria?: boolean
    ownerId?: boolean
    dependsOnId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    owner?: boolean | ProjectMilestone$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["projectMilestone"]>

  export type ProjectMilestoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    phase?: boolean
    order?: boolean
    plannedStartDate?: boolean
    plannedEndDate?: boolean
    actualStartDate?: boolean
    actualEndDate?: boolean
    completionCriteria?: boolean
    ownerId?: boolean
    dependsOnId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    owner?: boolean | ProjectMilestone$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["projectMilestone"]>

  export type ProjectMilestoneSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    phase?: boolean
    order?: boolean
    plannedStartDate?: boolean
    plannedEndDate?: boolean
    actualStartDate?: boolean
    actualEndDate?: boolean
    completionCriteria?: boolean
    ownerId?: boolean
    dependsOnId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectMilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    owner?: boolean | ProjectMilestone$ownerArgs<ExtArgs>
  }
  export type ProjectMilestoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    owner?: boolean | ProjectMilestone$ownerArgs<ExtArgs>
  }

  export type $ProjectMilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMilestone"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      description: string | null
      status: $Enums.MilestoneStatus
      phase: string | null
      order: number
      plannedStartDate: Date | null
      plannedEndDate: Date | null
      actualStartDate: Date | null
      actualEndDate: Date | null
      completionCriteria: string | null
      ownerId: string | null
      dependsOnId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectMilestone"]>
    composites: {}
  }

  type ProjectMilestoneGetPayload<S extends boolean | null | undefined | ProjectMilestoneDefaultArgs> = $Result.GetResult<Prisma.$ProjectMilestonePayload, S>

  type ProjectMilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectMilestoneFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectMilestoneCountAggregateInputType | true
    }

  export interface ProjectMilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMilestone'], meta: { name: 'ProjectMilestone' } }
    /**
     * Find zero or one ProjectMilestone that matches the filter.
     * @param {ProjectMilestoneFindUniqueArgs} args - Arguments to find a ProjectMilestone
     * @example
     * // Get one ProjectMilestone
     * const projectMilestone = await prisma.projectMilestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMilestoneFindUniqueArgs>(args: SelectSubset<T, ProjectMilestoneFindUniqueArgs<ExtArgs>>): Prisma__ProjectMilestoneClient<$Result.GetResult<Prisma.$ProjectMilestonePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectMilestone that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectMilestoneFindUniqueOrThrowArgs} args - Arguments to find a ProjectMilestone
     * @example
     * // Get one ProjectMilestone
     * const projectMilestone = await prisma.projectMilestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMilestoneClient<$Result.GetResult<Prisma.$ProjectMilestonePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectMilestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMilestoneFindFirstArgs} args - Arguments to find a ProjectMilestone
     * @example
     * // Get one ProjectMilestone
     * const projectMilestone = await prisma.projectMilestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMilestoneFindFirstArgs>(args?: SelectSubset<T, ProjectMilestoneFindFirstArgs<ExtArgs>>): Prisma__ProjectMilestoneClient<$Result.GetResult<Prisma.$ProjectMilestonePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectMilestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMilestoneFindFirstOrThrowArgs} args - Arguments to find a ProjectMilestone
     * @example
     * // Get one ProjectMilestone
     * const projectMilestone = await prisma.projectMilestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMilestoneClient<$Result.GetResult<Prisma.$ProjectMilestonePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectMilestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMilestones
     * const projectMilestones = await prisma.projectMilestone.findMany()
     * 
     * // Get first 10 ProjectMilestones
     * const projectMilestones = await prisma.projectMilestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectMilestoneWithIdOnly = await prisma.projectMilestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectMilestoneFindManyArgs>(args?: SelectSubset<T, ProjectMilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMilestonePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectMilestone.
     * @param {ProjectMilestoneCreateArgs} args - Arguments to create a ProjectMilestone.
     * @example
     * // Create one ProjectMilestone
     * const ProjectMilestone = await prisma.projectMilestone.create({
     *   data: {
     *     // ... data to create a ProjectMilestone
     *   }
     * })
     * 
     */
    create<T extends ProjectMilestoneCreateArgs>(args: SelectSubset<T, ProjectMilestoneCreateArgs<ExtArgs>>): Prisma__ProjectMilestoneClient<$Result.GetResult<Prisma.$ProjectMilestonePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectMilestones.
     * @param {ProjectMilestoneCreateManyArgs} args - Arguments to create many ProjectMilestones.
     * @example
     * // Create many ProjectMilestones
     * const projectMilestone = await prisma.projectMilestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMilestoneCreateManyArgs>(args?: SelectSubset<T, ProjectMilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectMilestones and returns the data saved in the database.
     * @param {ProjectMilestoneCreateManyAndReturnArgs} args - Arguments to create many ProjectMilestones.
     * @example
     * // Create many ProjectMilestones
     * const projectMilestone = await prisma.projectMilestone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectMilestones and only return the `id`
     * const projectMilestoneWithIdOnly = await prisma.projectMilestone.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectMilestoneCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectMilestoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMilestonePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectMilestone.
     * @param {ProjectMilestoneDeleteArgs} args - Arguments to delete one ProjectMilestone.
     * @example
     * // Delete one ProjectMilestone
     * const ProjectMilestone = await prisma.projectMilestone.delete({
     *   where: {
     *     // ... filter to delete one ProjectMilestone
     *   }
     * })
     * 
     */
    delete<T extends ProjectMilestoneDeleteArgs>(args: SelectSubset<T, ProjectMilestoneDeleteArgs<ExtArgs>>): Prisma__ProjectMilestoneClient<$Result.GetResult<Prisma.$ProjectMilestonePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectMilestone.
     * @param {ProjectMilestoneUpdateArgs} args - Arguments to update one ProjectMilestone.
     * @example
     * // Update one ProjectMilestone
     * const projectMilestone = await prisma.projectMilestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMilestoneUpdateArgs>(args: SelectSubset<T, ProjectMilestoneUpdateArgs<ExtArgs>>): Prisma__ProjectMilestoneClient<$Result.GetResult<Prisma.$ProjectMilestonePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectMilestones.
     * @param {ProjectMilestoneDeleteManyArgs} args - Arguments to filter ProjectMilestones to delete.
     * @example
     * // Delete a few ProjectMilestones
     * const { count } = await prisma.projectMilestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMilestoneDeleteManyArgs>(args?: SelectSubset<T, ProjectMilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMilestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMilestones
     * const projectMilestone = await prisma.projectMilestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMilestoneUpdateManyArgs>(args: SelectSubset<T, ProjectMilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectMilestone.
     * @param {ProjectMilestoneUpsertArgs} args - Arguments to update or create a ProjectMilestone.
     * @example
     * // Update or create a ProjectMilestone
     * const projectMilestone = await prisma.projectMilestone.upsert({
     *   create: {
     *     // ... data to create a ProjectMilestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMilestone we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMilestoneUpsertArgs>(args: SelectSubset<T, ProjectMilestoneUpsertArgs<ExtArgs>>): Prisma__ProjectMilestoneClient<$Result.GetResult<Prisma.$ProjectMilestonePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectMilestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMilestoneCountArgs} args - Arguments to filter ProjectMilestones to count.
     * @example
     * // Count the number of ProjectMilestones
     * const count = await prisma.projectMilestone.count({
     *   where: {
     *     // ... the filter for the ProjectMilestones we want to count
     *   }
     * })
    **/
    count<T extends ProjectMilestoneCountArgs>(
      args?: Subset<T, ProjectMilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMilestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMilestoneAggregateArgs>(args: Subset<T, ProjectMilestoneAggregateArgs>): Prisma.PrismaPromise<GetProjectMilestoneAggregateType<T>>

    /**
     * Group by ProjectMilestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMilestoneGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMilestone model
   */
  readonly fields: ProjectMilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMilestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    owner<T extends ProjectMilestone$ownerArgs<ExtArgs> = {}>(args?: Subset<T, ProjectMilestone$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMilestone model
   */ 
  interface ProjectMilestoneFieldRefs {
    readonly id: FieldRef<"ProjectMilestone", 'String'>
    readonly projectId: FieldRef<"ProjectMilestone", 'String'>
    readonly name: FieldRef<"ProjectMilestone", 'String'>
    readonly description: FieldRef<"ProjectMilestone", 'String'>
    readonly status: FieldRef<"ProjectMilestone", 'MilestoneStatus'>
    readonly phase: FieldRef<"ProjectMilestone", 'String'>
    readonly order: FieldRef<"ProjectMilestone", 'Int'>
    readonly plannedStartDate: FieldRef<"ProjectMilestone", 'DateTime'>
    readonly plannedEndDate: FieldRef<"ProjectMilestone", 'DateTime'>
    readonly actualStartDate: FieldRef<"ProjectMilestone", 'DateTime'>
    readonly actualEndDate: FieldRef<"ProjectMilestone", 'DateTime'>
    readonly completionCriteria: FieldRef<"ProjectMilestone", 'String'>
    readonly ownerId: FieldRef<"ProjectMilestone", 'String'>
    readonly dependsOnId: FieldRef<"ProjectMilestone", 'String'>
    readonly createdAt: FieldRef<"ProjectMilestone", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectMilestone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMilestone findUnique
   */
  export type ProjectMilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMilestone
     */
    select?: ProjectMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMilestone to fetch.
     */
    where: ProjectMilestoneWhereUniqueInput
  }

  /**
   * ProjectMilestone findUniqueOrThrow
   */
  export type ProjectMilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMilestone
     */
    select?: ProjectMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMilestone to fetch.
     */
    where: ProjectMilestoneWhereUniqueInput
  }

  /**
   * ProjectMilestone findFirst
   */
  export type ProjectMilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMilestone
     */
    select?: ProjectMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMilestone to fetch.
     */
    where?: ProjectMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMilestones to fetch.
     */
    orderBy?: ProjectMilestoneOrderByWithRelationInput | ProjectMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMilestones.
     */
    cursor?: ProjectMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMilestones.
     */
    distinct?: ProjectMilestoneScalarFieldEnum | ProjectMilestoneScalarFieldEnum[]
  }

  /**
   * ProjectMilestone findFirstOrThrow
   */
  export type ProjectMilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMilestone
     */
    select?: ProjectMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMilestone to fetch.
     */
    where?: ProjectMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMilestones to fetch.
     */
    orderBy?: ProjectMilestoneOrderByWithRelationInput | ProjectMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMilestones.
     */
    cursor?: ProjectMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMilestones.
     */
    distinct?: ProjectMilestoneScalarFieldEnum | ProjectMilestoneScalarFieldEnum[]
  }

  /**
   * ProjectMilestone findMany
   */
  export type ProjectMilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMilestone
     */
    select?: ProjectMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMilestones to fetch.
     */
    where?: ProjectMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMilestones to fetch.
     */
    orderBy?: ProjectMilestoneOrderByWithRelationInput | ProjectMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMilestones.
     */
    cursor?: ProjectMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMilestones.
     */
    skip?: number
    distinct?: ProjectMilestoneScalarFieldEnum | ProjectMilestoneScalarFieldEnum[]
  }

  /**
   * ProjectMilestone create
   */
  export type ProjectMilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMilestone
     */
    select?: ProjectMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMilestone.
     */
    data: XOR<ProjectMilestoneCreateInput, ProjectMilestoneUncheckedCreateInput>
  }

  /**
   * ProjectMilestone createMany
   */
  export type ProjectMilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMilestones.
     */
    data: ProjectMilestoneCreateManyInput | ProjectMilestoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectMilestone createManyAndReturn
   */
  export type ProjectMilestoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMilestone
     */
    select?: ProjectMilestoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectMilestones.
     */
    data: ProjectMilestoneCreateManyInput | ProjectMilestoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMilestoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMilestone update
   */
  export type ProjectMilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMilestone
     */
    select?: ProjectMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMilestone.
     */
    data: XOR<ProjectMilestoneUpdateInput, ProjectMilestoneUncheckedUpdateInput>
    /**
     * Choose, which ProjectMilestone to update.
     */
    where: ProjectMilestoneWhereUniqueInput
  }

  /**
   * ProjectMilestone updateMany
   */
  export type ProjectMilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMilestones.
     */
    data: XOR<ProjectMilestoneUpdateManyMutationInput, ProjectMilestoneUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMilestones to update
     */
    where?: ProjectMilestoneWhereInput
  }

  /**
   * ProjectMilestone upsert
   */
  export type ProjectMilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMilestone
     */
    select?: ProjectMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMilestone to update in case it exists.
     */
    where: ProjectMilestoneWhereUniqueInput
    /**
     * In case the ProjectMilestone found by the `where` argument doesn't exist, create a new ProjectMilestone with this data.
     */
    create: XOR<ProjectMilestoneCreateInput, ProjectMilestoneUncheckedCreateInput>
    /**
     * In case the ProjectMilestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMilestoneUpdateInput, ProjectMilestoneUncheckedUpdateInput>
  }

  /**
   * ProjectMilestone delete
   */
  export type ProjectMilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMilestone
     */
    select?: ProjectMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMilestoneInclude<ExtArgs> | null
    /**
     * Filter which ProjectMilestone to delete.
     */
    where: ProjectMilestoneWhereUniqueInput
  }

  /**
   * ProjectMilestone deleteMany
   */
  export type ProjectMilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMilestones to delete
     */
    where?: ProjectMilestoneWhereInput
  }

  /**
   * ProjectMilestone.owner
   */
  export type ProjectMilestone$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProjectMilestone without action
   */
  export type ProjectMilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMilestone
     */
    select?: ProjectMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMilestoneInclude<ExtArgs> | null
  }


  /**
   * Model ProjectTask
   */

  export type AggregateProjectTask = {
    _count: ProjectTaskCountAggregateOutputType | null
    _avg: ProjectTaskAvgAggregateOutputType | null
    _sum: ProjectTaskSumAggregateOutputType | null
    _min: ProjectTaskMinAggregateOutputType | null
    _max: ProjectTaskMaxAggregateOutputType | null
  }

  export type ProjectTaskAvgAggregateOutputType = {
    plannedHours: number | null
    actualHours: number | null
    order: number | null
  }

  export type ProjectTaskSumAggregateOutputType = {
    plannedHours: number | null
    actualHours: number | null
    order: number | null
  }

  export type ProjectTaskMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    priority: string | null
    phase: string | null
    assigneeId: string | null
    parentTaskId: string | null
    plannedHours: number | null
    actualHours: number | null
    dueDate: Date | null
    completedAt: Date | null
    blockerReason: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectTaskMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    priority: string | null
    phase: string | null
    assigneeId: string | null
    parentTaskId: string | null
    plannedHours: number | null
    actualHours: number | null
    dueDate: Date | null
    completedAt: Date | null
    blockerReason: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectTaskCountAggregateOutputType = {
    id: number
    projectId: number
    title: number
    description: number
    status: number
    priority: number
    phase: number
    assigneeId: number
    parentTaskId: number
    plannedHours: number
    actualHours: number
    dueDate: number
    completedAt: number
    blockerReason: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectTaskAvgAggregateInputType = {
    plannedHours?: true
    actualHours?: true
    order?: true
  }

  export type ProjectTaskSumAggregateInputType = {
    plannedHours?: true
    actualHours?: true
    order?: true
  }

  export type ProjectTaskMinAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    phase?: true
    assigneeId?: true
    parentTaskId?: true
    plannedHours?: true
    actualHours?: true
    dueDate?: true
    completedAt?: true
    blockerReason?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectTaskMaxAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    phase?: true
    assigneeId?: true
    parentTaskId?: true
    plannedHours?: true
    actualHours?: true
    dueDate?: true
    completedAt?: true
    blockerReason?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectTaskCountAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    phase?: true
    assigneeId?: true
    parentTaskId?: true
    plannedHours?: true
    actualHours?: true
    dueDate?: true
    completedAt?: true
    blockerReason?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTask to aggregate.
     */
    where?: ProjectTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTasks to fetch.
     */
    orderBy?: ProjectTaskOrderByWithRelationInput | ProjectTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectTasks
    **/
    _count?: true | ProjectTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectTaskMaxAggregateInputType
  }

  export type GetProjectTaskAggregateType<T extends ProjectTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectTask[P]>
      : GetScalarType<T[P], AggregateProjectTask[P]>
  }




  export type ProjectTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTaskWhereInput
    orderBy?: ProjectTaskOrderByWithAggregationInput | ProjectTaskOrderByWithAggregationInput[]
    by: ProjectTaskScalarFieldEnum[] | ProjectTaskScalarFieldEnum
    having?: ProjectTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectTaskCountAggregateInputType | true
    _avg?: ProjectTaskAvgAggregateInputType
    _sum?: ProjectTaskSumAggregateInputType
    _min?: ProjectTaskMinAggregateInputType
    _max?: ProjectTaskMaxAggregateInputType
  }

  export type ProjectTaskGroupByOutputType = {
    id: string
    projectId: string
    title: string
    description: string | null
    status: $Enums.TaskStatus
    priority: string
    phase: string | null
    assigneeId: string | null
    parentTaskId: string | null
    plannedHours: number | null
    actualHours: number
    dueDate: Date | null
    completedAt: Date | null
    blockerReason: string | null
    order: number
    createdAt: Date
    updatedAt: Date
    _count: ProjectTaskCountAggregateOutputType | null
    _avg: ProjectTaskAvgAggregateOutputType | null
    _sum: ProjectTaskSumAggregateOutputType | null
    _min: ProjectTaskMinAggregateOutputType | null
    _max: ProjectTaskMaxAggregateOutputType | null
  }

  type GetProjectTaskGroupByPayload<T extends ProjectTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectTaskGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectTaskGroupByOutputType[P]>
        }
      >
    >


  export type ProjectTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    phase?: boolean
    assigneeId?: boolean
    parentTaskId?: boolean
    plannedHours?: boolean
    actualHours?: boolean
    dueDate?: boolean
    completedAt?: boolean
    blockerReason?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    assignee?: boolean | ProjectTask$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["projectTask"]>

  export type ProjectTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    phase?: boolean
    assigneeId?: boolean
    parentTaskId?: boolean
    plannedHours?: boolean
    actualHours?: boolean
    dueDate?: boolean
    completedAt?: boolean
    blockerReason?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    assignee?: boolean | ProjectTask$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["projectTask"]>

  export type ProjectTaskSelectScalar = {
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    phase?: boolean
    assigneeId?: boolean
    parentTaskId?: boolean
    plannedHours?: boolean
    actualHours?: boolean
    dueDate?: boolean
    completedAt?: boolean
    blockerReason?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    assignee?: boolean | ProjectTask$assigneeArgs<ExtArgs>
  }
  export type ProjectTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    assignee?: boolean | ProjectTask$assigneeArgs<ExtArgs>
  }

  export type $ProjectTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectTask"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      assignee: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      title: string
      description: string | null
      status: $Enums.TaskStatus
      priority: string
      phase: string | null
      assigneeId: string | null
      parentTaskId: string | null
      plannedHours: number | null
      actualHours: number
      dueDate: Date | null
      completedAt: Date | null
      blockerReason: string | null
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectTask"]>
    composites: {}
  }

  type ProjectTaskGetPayload<S extends boolean | null | undefined | ProjectTaskDefaultArgs> = $Result.GetResult<Prisma.$ProjectTaskPayload, S>

  type ProjectTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectTaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectTaskCountAggregateInputType | true
    }

  export interface ProjectTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectTask'], meta: { name: 'ProjectTask' } }
    /**
     * Find zero or one ProjectTask that matches the filter.
     * @param {ProjectTaskFindUniqueArgs} args - Arguments to find a ProjectTask
     * @example
     * // Get one ProjectTask
     * const projectTask = await prisma.projectTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectTaskFindUniqueArgs>(args: SelectSubset<T, ProjectTaskFindUniqueArgs<ExtArgs>>): Prisma__ProjectTaskClient<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectTask that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectTaskFindUniqueOrThrowArgs} args - Arguments to find a ProjectTask
     * @example
     * // Get one ProjectTask
     * const projectTask = await prisma.projectTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectTaskClient<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskFindFirstArgs} args - Arguments to find a ProjectTask
     * @example
     * // Get one ProjectTask
     * const projectTask = await prisma.projectTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectTaskFindFirstArgs>(args?: SelectSubset<T, ProjectTaskFindFirstArgs<ExtArgs>>): Prisma__ProjectTaskClient<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskFindFirstOrThrowArgs} args - Arguments to find a ProjectTask
     * @example
     * // Get one ProjectTask
     * const projectTask = await prisma.projectTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectTaskClient<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectTasks
     * const projectTasks = await prisma.projectTask.findMany()
     * 
     * // Get first 10 ProjectTasks
     * const projectTasks = await prisma.projectTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectTaskWithIdOnly = await prisma.projectTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectTaskFindManyArgs>(args?: SelectSubset<T, ProjectTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectTask.
     * @param {ProjectTaskCreateArgs} args - Arguments to create a ProjectTask.
     * @example
     * // Create one ProjectTask
     * const ProjectTask = await prisma.projectTask.create({
     *   data: {
     *     // ... data to create a ProjectTask
     *   }
     * })
     * 
     */
    create<T extends ProjectTaskCreateArgs>(args: SelectSubset<T, ProjectTaskCreateArgs<ExtArgs>>): Prisma__ProjectTaskClient<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectTasks.
     * @param {ProjectTaskCreateManyArgs} args - Arguments to create many ProjectTasks.
     * @example
     * // Create many ProjectTasks
     * const projectTask = await prisma.projectTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectTaskCreateManyArgs>(args?: SelectSubset<T, ProjectTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectTasks and returns the data saved in the database.
     * @param {ProjectTaskCreateManyAndReturnArgs} args - Arguments to create many ProjectTasks.
     * @example
     * // Create many ProjectTasks
     * const projectTask = await prisma.projectTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectTasks and only return the `id`
     * const projectTaskWithIdOnly = await prisma.projectTask.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectTask.
     * @param {ProjectTaskDeleteArgs} args - Arguments to delete one ProjectTask.
     * @example
     * // Delete one ProjectTask
     * const ProjectTask = await prisma.projectTask.delete({
     *   where: {
     *     // ... filter to delete one ProjectTask
     *   }
     * })
     * 
     */
    delete<T extends ProjectTaskDeleteArgs>(args: SelectSubset<T, ProjectTaskDeleteArgs<ExtArgs>>): Prisma__ProjectTaskClient<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectTask.
     * @param {ProjectTaskUpdateArgs} args - Arguments to update one ProjectTask.
     * @example
     * // Update one ProjectTask
     * const projectTask = await prisma.projectTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectTaskUpdateArgs>(args: SelectSubset<T, ProjectTaskUpdateArgs<ExtArgs>>): Prisma__ProjectTaskClient<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectTasks.
     * @param {ProjectTaskDeleteManyArgs} args - Arguments to filter ProjectTasks to delete.
     * @example
     * // Delete a few ProjectTasks
     * const { count } = await prisma.projectTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectTaskDeleteManyArgs>(args?: SelectSubset<T, ProjectTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectTasks
     * const projectTask = await prisma.projectTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectTaskUpdateManyArgs>(args: SelectSubset<T, ProjectTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectTask.
     * @param {ProjectTaskUpsertArgs} args - Arguments to update or create a ProjectTask.
     * @example
     * // Update or create a ProjectTask
     * const projectTask = await prisma.projectTask.upsert({
     *   create: {
     *     // ... data to create a ProjectTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectTask we want to update
     *   }
     * })
     */
    upsert<T extends ProjectTaskUpsertArgs>(args: SelectSubset<T, ProjectTaskUpsertArgs<ExtArgs>>): Prisma__ProjectTaskClient<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskCountArgs} args - Arguments to filter ProjectTasks to count.
     * @example
     * // Count the number of ProjectTasks
     * const count = await prisma.projectTask.count({
     *   where: {
     *     // ... the filter for the ProjectTasks we want to count
     *   }
     * })
    **/
    count<T extends ProjectTaskCountArgs>(
      args?: Subset<T, ProjectTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectTaskAggregateArgs>(args: Subset<T, ProjectTaskAggregateArgs>): Prisma.PrismaPromise<GetProjectTaskAggregateType<T>>

    /**
     * Group by ProjectTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectTaskGroupByArgs['orderBy'] }
        : { orderBy?: ProjectTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectTask model
   */
  readonly fields: ProjectTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignee<T extends ProjectTask$assigneeArgs<ExtArgs> = {}>(args?: Subset<T, ProjectTask$assigneeArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectTask model
   */ 
  interface ProjectTaskFieldRefs {
    readonly id: FieldRef<"ProjectTask", 'String'>
    readonly projectId: FieldRef<"ProjectTask", 'String'>
    readonly title: FieldRef<"ProjectTask", 'String'>
    readonly description: FieldRef<"ProjectTask", 'String'>
    readonly status: FieldRef<"ProjectTask", 'TaskStatus'>
    readonly priority: FieldRef<"ProjectTask", 'String'>
    readonly phase: FieldRef<"ProjectTask", 'String'>
    readonly assigneeId: FieldRef<"ProjectTask", 'String'>
    readonly parentTaskId: FieldRef<"ProjectTask", 'String'>
    readonly plannedHours: FieldRef<"ProjectTask", 'Float'>
    readonly actualHours: FieldRef<"ProjectTask", 'Float'>
    readonly dueDate: FieldRef<"ProjectTask", 'DateTime'>
    readonly completedAt: FieldRef<"ProjectTask", 'DateTime'>
    readonly blockerReason: FieldRef<"ProjectTask", 'String'>
    readonly order: FieldRef<"ProjectTask", 'Int'>
    readonly createdAt: FieldRef<"ProjectTask", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectTask findUnique
   */
  export type ProjectTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTaskInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTask to fetch.
     */
    where: ProjectTaskWhereUniqueInput
  }

  /**
   * ProjectTask findUniqueOrThrow
   */
  export type ProjectTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTaskInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTask to fetch.
     */
    where: ProjectTaskWhereUniqueInput
  }

  /**
   * ProjectTask findFirst
   */
  export type ProjectTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTaskInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTask to fetch.
     */
    where?: ProjectTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTasks to fetch.
     */
    orderBy?: ProjectTaskOrderByWithRelationInput | ProjectTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTasks.
     */
    cursor?: ProjectTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTasks.
     */
    distinct?: ProjectTaskScalarFieldEnum | ProjectTaskScalarFieldEnum[]
  }

  /**
   * ProjectTask findFirstOrThrow
   */
  export type ProjectTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTaskInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTask to fetch.
     */
    where?: ProjectTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTasks to fetch.
     */
    orderBy?: ProjectTaskOrderByWithRelationInput | ProjectTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTasks.
     */
    cursor?: ProjectTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTasks.
     */
    distinct?: ProjectTaskScalarFieldEnum | ProjectTaskScalarFieldEnum[]
  }

  /**
   * ProjectTask findMany
   */
  export type ProjectTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTaskInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTasks to fetch.
     */
    where?: ProjectTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTasks to fetch.
     */
    orderBy?: ProjectTaskOrderByWithRelationInput | ProjectTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectTasks.
     */
    cursor?: ProjectTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTasks.
     */
    skip?: number
    distinct?: ProjectTaskScalarFieldEnum | ProjectTaskScalarFieldEnum[]
  }

  /**
   * ProjectTask create
   */
  export type ProjectTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectTask.
     */
    data: XOR<ProjectTaskCreateInput, ProjectTaskUncheckedCreateInput>
  }

  /**
   * ProjectTask createMany
   */
  export type ProjectTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectTasks.
     */
    data: ProjectTaskCreateManyInput | ProjectTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectTask createManyAndReturn
   */
  export type ProjectTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectTasks.
     */
    data: ProjectTaskCreateManyInput | ProjectTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectTask update
   */
  export type ProjectTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectTask.
     */
    data: XOR<ProjectTaskUpdateInput, ProjectTaskUncheckedUpdateInput>
    /**
     * Choose, which ProjectTask to update.
     */
    where: ProjectTaskWhereUniqueInput
  }

  /**
   * ProjectTask updateMany
   */
  export type ProjectTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectTasks.
     */
    data: XOR<ProjectTaskUpdateManyMutationInput, ProjectTaskUncheckedUpdateManyInput>
    /**
     * Filter which ProjectTasks to update
     */
    where?: ProjectTaskWhereInput
  }

  /**
   * ProjectTask upsert
   */
  export type ProjectTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectTask to update in case it exists.
     */
    where: ProjectTaskWhereUniqueInput
    /**
     * In case the ProjectTask found by the `where` argument doesn't exist, create a new ProjectTask with this data.
     */
    create: XOR<ProjectTaskCreateInput, ProjectTaskUncheckedCreateInput>
    /**
     * In case the ProjectTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectTaskUpdateInput, ProjectTaskUncheckedUpdateInput>
  }

  /**
   * ProjectTask delete
   */
  export type ProjectTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTaskInclude<ExtArgs> | null
    /**
     * Filter which ProjectTask to delete.
     */
    where: ProjectTaskWhereUniqueInput
  }

  /**
   * ProjectTask deleteMany
   */
  export type ProjectTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTasks to delete
     */
    where?: ProjectTaskWhereInput
  }

  /**
   * ProjectTask.assignee
   */
  export type ProjectTask$assigneeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProjectTask without action
   */
  export type ProjectTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTaskInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMetric
   */

  export type AggregateProjectMetric = {
    _count: ProjectMetricCountAggregateOutputType | null
    _avg: ProjectMetricAvgAggregateOutputType | null
    _sum: ProjectMetricSumAggregateOutputType | null
    _min: ProjectMetricMinAggregateOutputType | null
    _max: ProjectMetricMaxAggregateOutputType | null
  }

  export type ProjectMetricAvgAggregateOutputType = {
    value: number | null
    baselineValue: number | null
    targetValue: number | null
  }

  export type ProjectMetricSumAggregateOutputType = {
    value: number | null
    baselineValue: number | null
    targetValue: number | null
  }

  export type ProjectMetricMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    metricName: string | null
    metricCategory: string | null
    value: number | null
    unit: string | null
    baselineValue: number | null
    targetValue: number | null
    recordedAt: Date | null
  }

  export type ProjectMetricMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    metricName: string | null
    metricCategory: string | null
    value: number | null
    unit: string | null
    baselineValue: number | null
    targetValue: number | null
    recordedAt: Date | null
  }

  export type ProjectMetricCountAggregateOutputType = {
    id: number
    projectId: number
    metricName: number
    metricCategory: number
    value: number
    unit: number
    baselineValue: number
    targetValue: number
    recordedAt: number
    _all: number
  }


  export type ProjectMetricAvgAggregateInputType = {
    value?: true
    baselineValue?: true
    targetValue?: true
  }

  export type ProjectMetricSumAggregateInputType = {
    value?: true
    baselineValue?: true
    targetValue?: true
  }

  export type ProjectMetricMinAggregateInputType = {
    id?: true
    projectId?: true
    metricName?: true
    metricCategory?: true
    value?: true
    unit?: true
    baselineValue?: true
    targetValue?: true
    recordedAt?: true
  }

  export type ProjectMetricMaxAggregateInputType = {
    id?: true
    projectId?: true
    metricName?: true
    metricCategory?: true
    value?: true
    unit?: true
    baselineValue?: true
    targetValue?: true
    recordedAt?: true
  }

  export type ProjectMetricCountAggregateInputType = {
    id?: true
    projectId?: true
    metricName?: true
    metricCategory?: true
    value?: true
    unit?: true
    baselineValue?: true
    targetValue?: true
    recordedAt?: true
    _all?: true
  }

  export type ProjectMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMetric to aggregate.
     */
    where?: ProjectMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMetrics to fetch.
     */
    orderBy?: ProjectMetricOrderByWithRelationInput | ProjectMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMetrics
    **/
    _count?: true | ProjectMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMetricMaxAggregateInputType
  }

  export type GetProjectMetricAggregateType<T extends ProjectMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMetric[P]>
      : GetScalarType<T[P], AggregateProjectMetric[P]>
  }




  export type ProjectMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMetricWhereInput
    orderBy?: ProjectMetricOrderByWithAggregationInput | ProjectMetricOrderByWithAggregationInput[]
    by: ProjectMetricScalarFieldEnum[] | ProjectMetricScalarFieldEnum
    having?: ProjectMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMetricCountAggregateInputType | true
    _avg?: ProjectMetricAvgAggregateInputType
    _sum?: ProjectMetricSumAggregateInputType
    _min?: ProjectMetricMinAggregateInputType
    _max?: ProjectMetricMaxAggregateInputType
  }

  export type ProjectMetricGroupByOutputType = {
    id: string
    projectId: string
    metricName: string
    metricCategory: string
    value: number
    unit: string | null
    baselineValue: number | null
    targetValue: number | null
    recordedAt: Date
    _count: ProjectMetricCountAggregateOutputType | null
    _avg: ProjectMetricAvgAggregateOutputType | null
    _sum: ProjectMetricSumAggregateOutputType | null
    _min: ProjectMetricMinAggregateOutputType | null
    _max: ProjectMetricMaxAggregateOutputType | null
  }

  type GetProjectMetricGroupByPayload<T extends ProjectMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMetricGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMetricGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    metricName?: boolean
    metricCategory?: boolean
    value?: boolean
    unit?: boolean
    baselineValue?: boolean
    targetValue?: boolean
    recordedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMetric"]>

  export type ProjectMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    metricName?: boolean
    metricCategory?: boolean
    value?: boolean
    unit?: boolean
    baselineValue?: boolean
    targetValue?: boolean
    recordedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMetric"]>

  export type ProjectMetricSelectScalar = {
    id?: boolean
    projectId?: boolean
    metricName?: boolean
    metricCategory?: boolean
    value?: boolean
    unit?: boolean
    baselineValue?: boolean
    targetValue?: boolean
    recordedAt?: boolean
  }

  export type ProjectMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMetric"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      metricName: string
      metricCategory: string
      value: number
      unit: string | null
      baselineValue: number | null
      targetValue: number | null
      recordedAt: Date
    }, ExtArgs["result"]["projectMetric"]>
    composites: {}
  }

  type ProjectMetricGetPayload<S extends boolean | null | undefined | ProjectMetricDefaultArgs> = $Result.GetResult<Prisma.$ProjectMetricPayload, S>

  type ProjectMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectMetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectMetricCountAggregateInputType | true
    }

  export interface ProjectMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMetric'], meta: { name: 'ProjectMetric' } }
    /**
     * Find zero or one ProjectMetric that matches the filter.
     * @param {ProjectMetricFindUniqueArgs} args - Arguments to find a ProjectMetric
     * @example
     * // Get one ProjectMetric
     * const projectMetric = await prisma.projectMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMetricFindUniqueArgs>(args: SelectSubset<T, ProjectMetricFindUniqueArgs<ExtArgs>>): Prisma__ProjectMetricClient<$Result.GetResult<Prisma.$ProjectMetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectMetric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectMetricFindUniqueOrThrowArgs} args - Arguments to find a ProjectMetric
     * @example
     * // Get one ProjectMetric
     * const projectMetric = await prisma.projectMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMetricClient<$Result.GetResult<Prisma.$ProjectMetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMetricFindFirstArgs} args - Arguments to find a ProjectMetric
     * @example
     * // Get one ProjectMetric
     * const projectMetric = await prisma.projectMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMetricFindFirstArgs>(args?: SelectSubset<T, ProjectMetricFindFirstArgs<ExtArgs>>): Prisma__ProjectMetricClient<$Result.GetResult<Prisma.$ProjectMetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMetricFindFirstOrThrowArgs} args - Arguments to find a ProjectMetric
     * @example
     * // Get one ProjectMetric
     * const projectMetric = await prisma.projectMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMetricClient<$Result.GetResult<Prisma.$ProjectMetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMetrics
     * const projectMetrics = await prisma.projectMetric.findMany()
     * 
     * // Get first 10 ProjectMetrics
     * const projectMetrics = await prisma.projectMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectMetricWithIdOnly = await prisma.projectMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectMetricFindManyArgs>(args?: SelectSubset<T, ProjectMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectMetric.
     * @param {ProjectMetricCreateArgs} args - Arguments to create a ProjectMetric.
     * @example
     * // Create one ProjectMetric
     * const ProjectMetric = await prisma.projectMetric.create({
     *   data: {
     *     // ... data to create a ProjectMetric
     *   }
     * })
     * 
     */
    create<T extends ProjectMetricCreateArgs>(args: SelectSubset<T, ProjectMetricCreateArgs<ExtArgs>>): Prisma__ProjectMetricClient<$Result.GetResult<Prisma.$ProjectMetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectMetrics.
     * @param {ProjectMetricCreateManyArgs} args - Arguments to create many ProjectMetrics.
     * @example
     * // Create many ProjectMetrics
     * const projectMetric = await prisma.projectMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMetricCreateManyArgs>(args?: SelectSubset<T, ProjectMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectMetrics and returns the data saved in the database.
     * @param {ProjectMetricCreateManyAndReturnArgs} args - Arguments to create many ProjectMetrics.
     * @example
     * // Create many ProjectMetrics
     * const projectMetric = await prisma.projectMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectMetrics and only return the `id`
     * const projectMetricWithIdOnly = await prisma.projectMetric.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMetricPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectMetric.
     * @param {ProjectMetricDeleteArgs} args - Arguments to delete one ProjectMetric.
     * @example
     * // Delete one ProjectMetric
     * const ProjectMetric = await prisma.projectMetric.delete({
     *   where: {
     *     // ... filter to delete one ProjectMetric
     *   }
     * })
     * 
     */
    delete<T extends ProjectMetricDeleteArgs>(args: SelectSubset<T, ProjectMetricDeleteArgs<ExtArgs>>): Prisma__ProjectMetricClient<$Result.GetResult<Prisma.$ProjectMetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectMetric.
     * @param {ProjectMetricUpdateArgs} args - Arguments to update one ProjectMetric.
     * @example
     * // Update one ProjectMetric
     * const projectMetric = await prisma.projectMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMetricUpdateArgs>(args: SelectSubset<T, ProjectMetricUpdateArgs<ExtArgs>>): Prisma__ProjectMetricClient<$Result.GetResult<Prisma.$ProjectMetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectMetrics.
     * @param {ProjectMetricDeleteManyArgs} args - Arguments to filter ProjectMetrics to delete.
     * @example
     * // Delete a few ProjectMetrics
     * const { count } = await prisma.projectMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMetricDeleteManyArgs>(args?: SelectSubset<T, ProjectMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMetrics
     * const projectMetric = await prisma.projectMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMetricUpdateManyArgs>(args: SelectSubset<T, ProjectMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectMetric.
     * @param {ProjectMetricUpsertArgs} args - Arguments to update or create a ProjectMetric.
     * @example
     * // Update or create a ProjectMetric
     * const projectMetric = await prisma.projectMetric.upsert({
     *   create: {
     *     // ... data to create a ProjectMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMetric we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMetricUpsertArgs>(args: SelectSubset<T, ProjectMetricUpsertArgs<ExtArgs>>): Prisma__ProjectMetricClient<$Result.GetResult<Prisma.$ProjectMetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMetricCountArgs} args - Arguments to filter ProjectMetrics to count.
     * @example
     * // Count the number of ProjectMetrics
     * const count = await prisma.projectMetric.count({
     *   where: {
     *     // ... the filter for the ProjectMetrics we want to count
     *   }
     * })
    **/
    count<T extends ProjectMetricCountArgs>(
      args?: Subset<T, ProjectMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMetricAggregateArgs>(args: Subset<T, ProjectMetricAggregateArgs>): Prisma.PrismaPromise<GetProjectMetricAggregateType<T>>

    /**
     * Group by ProjectMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMetricGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMetric model
   */
  readonly fields: ProjectMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMetric model
   */ 
  interface ProjectMetricFieldRefs {
    readonly id: FieldRef<"ProjectMetric", 'String'>
    readonly projectId: FieldRef<"ProjectMetric", 'String'>
    readonly metricName: FieldRef<"ProjectMetric", 'String'>
    readonly metricCategory: FieldRef<"ProjectMetric", 'String'>
    readonly value: FieldRef<"ProjectMetric", 'Float'>
    readonly unit: FieldRef<"ProjectMetric", 'String'>
    readonly baselineValue: FieldRef<"ProjectMetric", 'Float'>
    readonly targetValue: FieldRef<"ProjectMetric", 'Float'>
    readonly recordedAt: FieldRef<"ProjectMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMetric findUnique
   */
  export type ProjectMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetric
     */
    select?: ProjectMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMetric to fetch.
     */
    where: ProjectMetricWhereUniqueInput
  }

  /**
   * ProjectMetric findUniqueOrThrow
   */
  export type ProjectMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetric
     */
    select?: ProjectMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMetric to fetch.
     */
    where: ProjectMetricWhereUniqueInput
  }

  /**
   * ProjectMetric findFirst
   */
  export type ProjectMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetric
     */
    select?: ProjectMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMetric to fetch.
     */
    where?: ProjectMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMetrics to fetch.
     */
    orderBy?: ProjectMetricOrderByWithRelationInput | ProjectMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMetrics.
     */
    cursor?: ProjectMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMetrics.
     */
    distinct?: ProjectMetricScalarFieldEnum | ProjectMetricScalarFieldEnum[]
  }

  /**
   * ProjectMetric findFirstOrThrow
   */
  export type ProjectMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetric
     */
    select?: ProjectMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMetric to fetch.
     */
    where?: ProjectMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMetrics to fetch.
     */
    orderBy?: ProjectMetricOrderByWithRelationInput | ProjectMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMetrics.
     */
    cursor?: ProjectMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMetrics.
     */
    distinct?: ProjectMetricScalarFieldEnum | ProjectMetricScalarFieldEnum[]
  }

  /**
   * ProjectMetric findMany
   */
  export type ProjectMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetric
     */
    select?: ProjectMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMetrics to fetch.
     */
    where?: ProjectMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMetrics to fetch.
     */
    orderBy?: ProjectMetricOrderByWithRelationInput | ProjectMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMetrics.
     */
    cursor?: ProjectMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMetrics.
     */
    skip?: number
    distinct?: ProjectMetricScalarFieldEnum | ProjectMetricScalarFieldEnum[]
  }

  /**
   * ProjectMetric create
   */
  export type ProjectMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetric
     */
    select?: ProjectMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMetric.
     */
    data: XOR<ProjectMetricCreateInput, ProjectMetricUncheckedCreateInput>
  }

  /**
   * ProjectMetric createMany
   */
  export type ProjectMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMetrics.
     */
    data: ProjectMetricCreateManyInput | ProjectMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectMetric createManyAndReturn
   */
  export type ProjectMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetric
     */
    select?: ProjectMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectMetrics.
     */
    data: ProjectMetricCreateManyInput | ProjectMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMetric update
   */
  export type ProjectMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetric
     */
    select?: ProjectMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMetric.
     */
    data: XOR<ProjectMetricUpdateInput, ProjectMetricUncheckedUpdateInput>
    /**
     * Choose, which ProjectMetric to update.
     */
    where: ProjectMetricWhereUniqueInput
  }

  /**
   * ProjectMetric updateMany
   */
  export type ProjectMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMetrics.
     */
    data: XOR<ProjectMetricUpdateManyMutationInput, ProjectMetricUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMetrics to update
     */
    where?: ProjectMetricWhereInput
  }

  /**
   * ProjectMetric upsert
   */
  export type ProjectMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetric
     */
    select?: ProjectMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMetric to update in case it exists.
     */
    where: ProjectMetricWhereUniqueInput
    /**
     * In case the ProjectMetric found by the `where` argument doesn't exist, create a new ProjectMetric with this data.
     */
    create: XOR<ProjectMetricCreateInput, ProjectMetricUncheckedCreateInput>
    /**
     * In case the ProjectMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMetricUpdateInput, ProjectMetricUncheckedUpdateInput>
  }

  /**
   * ProjectMetric delete
   */
  export type ProjectMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetric
     */
    select?: ProjectMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricInclude<ExtArgs> | null
    /**
     * Filter which ProjectMetric to delete.
     */
    where: ProjectMetricWhereUniqueInput
  }

  /**
   * ProjectMetric deleteMany
   */
  export type ProjectMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMetrics to delete
     */
    where?: ProjectMetricWhereInput
  }

  /**
   * ProjectMetric without action
   */
  export type ProjectMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetric
     */
    select?: ProjectMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricInclude<ExtArgs> | null
  }


  /**
   * Model AISolution
   */

  export type AggregateAISolution = {
    _count: AISolutionCountAggregateOutputType | null
    _avg: AISolutionAvgAggregateOutputType | null
    _sum: AISolutionSumAggregateOutputType | null
    _min: AISolutionMinAggregateOutputType | null
    _max: AISolutionMaxAggregateOutputType | null
  }

  export type AISolutionAvgAggregateOutputType = {
    typicalTimelineWeeks: number | null
    displayOrder: number | null
  }

  export type AISolutionSumAggregateOutputType = {
    typicalTimelineWeeks: number | null
    displayOrder: number | null
  }

  export type AISolutionMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    description: string | null
    tagline: string | null
    longDescription: string | null
    typicalTimelineWeeks: number | null
    isActive: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AISolutionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    description: string | null
    tagline: string | null
    longDescription: string | null
    typicalTimelineWeeks: number | null
    isActive: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AISolutionCountAggregateOutputType = {
    id: number
    name: number
    category: number
    description: number
    tagline: number
    longDescription: number
    targetIndustries: number
    targetFunctions: number
    technicalRequirements: number
    integrationPoints: number
    pricingModels: number
    typicalTimelineWeeks: number
    useCases: number
    caseStudies: number
    isActive: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AISolutionAvgAggregateInputType = {
    typicalTimelineWeeks?: true
    displayOrder?: true
  }

  export type AISolutionSumAggregateInputType = {
    typicalTimelineWeeks?: true
    displayOrder?: true
  }

  export type AISolutionMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    tagline?: true
    longDescription?: true
    typicalTimelineWeeks?: true
    isActive?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AISolutionMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    tagline?: true
    longDescription?: true
    typicalTimelineWeeks?: true
    isActive?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AISolutionCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    tagline?: true
    longDescription?: true
    targetIndustries?: true
    targetFunctions?: true
    technicalRequirements?: true
    integrationPoints?: true
    pricingModels?: true
    typicalTimelineWeeks?: true
    useCases?: true
    caseStudies?: true
    isActive?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AISolutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AISolution to aggregate.
     */
    where?: AISolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AISolutions to fetch.
     */
    orderBy?: AISolutionOrderByWithRelationInput | AISolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AISolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AISolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AISolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AISolutions
    **/
    _count?: true | AISolutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AISolutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AISolutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AISolutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AISolutionMaxAggregateInputType
  }

  export type GetAISolutionAggregateType<T extends AISolutionAggregateArgs> = {
        [P in keyof T & keyof AggregateAISolution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAISolution[P]>
      : GetScalarType<T[P], AggregateAISolution[P]>
  }




  export type AISolutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AISolutionWhereInput
    orderBy?: AISolutionOrderByWithAggregationInput | AISolutionOrderByWithAggregationInput[]
    by: AISolutionScalarFieldEnum[] | AISolutionScalarFieldEnum
    having?: AISolutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AISolutionCountAggregateInputType | true
    _avg?: AISolutionAvgAggregateInputType
    _sum?: AISolutionSumAggregateInputType
    _min?: AISolutionMinAggregateInputType
    _max?: AISolutionMaxAggregateInputType
  }

  export type AISolutionGroupByOutputType = {
    id: string
    name: string
    category: string
    description: string | null
    tagline: string | null
    longDescription: string | null
    targetIndustries: string[]
    targetFunctions: string[]
    technicalRequirements: string[]
    integrationPoints: string[]
    pricingModels: string[]
    typicalTimelineWeeks: number | null
    useCases: string[]
    caseStudies: JsonValue | null
    isActive: boolean
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: AISolutionCountAggregateOutputType | null
    _avg: AISolutionAvgAggregateOutputType | null
    _sum: AISolutionSumAggregateOutputType | null
    _min: AISolutionMinAggregateOutputType | null
    _max: AISolutionMaxAggregateOutputType | null
  }

  type GetAISolutionGroupByPayload<T extends AISolutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AISolutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AISolutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AISolutionGroupByOutputType[P]>
            : GetScalarType<T[P], AISolutionGroupByOutputType[P]>
        }
      >
    >


  export type AISolutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    tagline?: boolean
    longDescription?: boolean
    targetIndustries?: boolean
    targetFunctions?: boolean
    technicalRequirements?: boolean
    integrationPoints?: boolean
    pricingModels?: boolean
    typicalTimelineWeeks?: boolean
    useCases?: boolean
    caseStudies?: boolean
    isActive?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    modules?: boolean | AISolution$modulesArgs<ExtArgs>
    quotes?: boolean | AISolution$quotesArgs<ExtArgs>
    clientSolutions?: boolean | AISolution$clientSolutionsArgs<ExtArgs>
    _count?: boolean | AISolutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aISolution"]>

  export type AISolutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    tagline?: boolean
    longDescription?: boolean
    targetIndustries?: boolean
    targetFunctions?: boolean
    technicalRequirements?: boolean
    integrationPoints?: boolean
    pricingModels?: boolean
    typicalTimelineWeeks?: boolean
    useCases?: boolean
    caseStudies?: boolean
    isActive?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aISolution"]>

  export type AISolutionSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    tagline?: boolean
    longDescription?: boolean
    targetIndustries?: boolean
    targetFunctions?: boolean
    technicalRequirements?: boolean
    integrationPoints?: boolean
    pricingModels?: boolean
    typicalTimelineWeeks?: boolean
    useCases?: boolean
    caseStudies?: boolean
    isActive?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AISolutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | AISolution$modulesArgs<ExtArgs>
    quotes?: boolean | AISolution$quotesArgs<ExtArgs>
    clientSolutions?: boolean | AISolution$clientSolutionsArgs<ExtArgs>
    _count?: boolean | AISolutionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AISolutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AISolutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AISolution"
    objects: {
      modules: Prisma.$AISolutionModulePayload<ExtArgs>[]
      quotes: Prisma.$QuotePayload<ExtArgs>[]
      clientSolutions: Prisma.$ClientSolutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string
      description: string | null
      tagline: string | null
      longDescription: string | null
      targetIndustries: string[]
      targetFunctions: string[]
      technicalRequirements: string[]
      integrationPoints: string[]
      pricingModels: string[]
      typicalTimelineWeeks: number | null
      useCases: string[]
      caseStudies: Prisma.JsonValue | null
      isActive: boolean
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aISolution"]>
    composites: {}
  }

  type AISolutionGetPayload<S extends boolean | null | undefined | AISolutionDefaultArgs> = $Result.GetResult<Prisma.$AISolutionPayload, S>

  type AISolutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AISolutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AISolutionCountAggregateInputType | true
    }

  export interface AISolutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AISolution'], meta: { name: 'AISolution' } }
    /**
     * Find zero or one AISolution that matches the filter.
     * @param {AISolutionFindUniqueArgs} args - Arguments to find a AISolution
     * @example
     * // Get one AISolution
     * const aISolution = await prisma.aISolution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AISolutionFindUniqueArgs>(args: SelectSubset<T, AISolutionFindUniqueArgs<ExtArgs>>): Prisma__AISolutionClient<$Result.GetResult<Prisma.$AISolutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AISolution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AISolutionFindUniqueOrThrowArgs} args - Arguments to find a AISolution
     * @example
     * // Get one AISolution
     * const aISolution = await prisma.aISolution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AISolutionFindUniqueOrThrowArgs>(args: SelectSubset<T, AISolutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AISolutionClient<$Result.GetResult<Prisma.$AISolutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AISolution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AISolutionFindFirstArgs} args - Arguments to find a AISolution
     * @example
     * // Get one AISolution
     * const aISolution = await prisma.aISolution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AISolutionFindFirstArgs>(args?: SelectSubset<T, AISolutionFindFirstArgs<ExtArgs>>): Prisma__AISolutionClient<$Result.GetResult<Prisma.$AISolutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AISolution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AISolutionFindFirstOrThrowArgs} args - Arguments to find a AISolution
     * @example
     * // Get one AISolution
     * const aISolution = await prisma.aISolution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AISolutionFindFirstOrThrowArgs>(args?: SelectSubset<T, AISolutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AISolutionClient<$Result.GetResult<Prisma.$AISolutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AISolutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AISolutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AISolutions
     * const aISolutions = await prisma.aISolution.findMany()
     * 
     * // Get first 10 AISolutions
     * const aISolutions = await prisma.aISolution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aISolutionWithIdOnly = await prisma.aISolution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AISolutionFindManyArgs>(args?: SelectSubset<T, AISolutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AISolutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AISolution.
     * @param {AISolutionCreateArgs} args - Arguments to create a AISolution.
     * @example
     * // Create one AISolution
     * const AISolution = await prisma.aISolution.create({
     *   data: {
     *     // ... data to create a AISolution
     *   }
     * })
     * 
     */
    create<T extends AISolutionCreateArgs>(args: SelectSubset<T, AISolutionCreateArgs<ExtArgs>>): Prisma__AISolutionClient<$Result.GetResult<Prisma.$AISolutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AISolutions.
     * @param {AISolutionCreateManyArgs} args - Arguments to create many AISolutions.
     * @example
     * // Create many AISolutions
     * const aISolution = await prisma.aISolution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AISolutionCreateManyArgs>(args?: SelectSubset<T, AISolutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AISolutions and returns the data saved in the database.
     * @param {AISolutionCreateManyAndReturnArgs} args - Arguments to create many AISolutions.
     * @example
     * // Create many AISolutions
     * const aISolution = await prisma.aISolution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AISolutions and only return the `id`
     * const aISolutionWithIdOnly = await prisma.aISolution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AISolutionCreateManyAndReturnArgs>(args?: SelectSubset<T, AISolutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AISolutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AISolution.
     * @param {AISolutionDeleteArgs} args - Arguments to delete one AISolution.
     * @example
     * // Delete one AISolution
     * const AISolution = await prisma.aISolution.delete({
     *   where: {
     *     // ... filter to delete one AISolution
     *   }
     * })
     * 
     */
    delete<T extends AISolutionDeleteArgs>(args: SelectSubset<T, AISolutionDeleteArgs<ExtArgs>>): Prisma__AISolutionClient<$Result.GetResult<Prisma.$AISolutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AISolution.
     * @param {AISolutionUpdateArgs} args - Arguments to update one AISolution.
     * @example
     * // Update one AISolution
     * const aISolution = await prisma.aISolution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AISolutionUpdateArgs>(args: SelectSubset<T, AISolutionUpdateArgs<ExtArgs>>): Prisma__AISolutionClient<$Result.GetResult<Prisma.$AISolutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AISolutions.
     * @param {AISolutionDeleteManyArgs} args - Arguments to filter AISolutions to delete.
     * @example
     * // Delete a few AISolutions
     * const { count } = await prisma.aISolution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AISolutionDeleteManyArgs>(args?: SelectSubset<T, AISolutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AISolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AISolutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AISolutions
     * const aISolution = await prisma.aISolution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AISolutionUpdateManyArgs>(args: SelectSubset<T, AISolutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AISolution.
     * @param {AISolutionUpsertArgs} args - Arguments to update or create a AISolution.
     * @example
     * // Update or create a AISolution
     * const aISolution = await prisma.aISolution.upsert({
     *   create: {
     *     // ... data to create a AISolution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AISolution we want to update
     *   }
     * })
     */
    upsert<T extends AISolutionUpsertArgs>(args: SelectSubset<T, AISolutionUpsertArgs<ExtArgs>>): Prisma__AISolutionClient<$Result.GetResult<Prisma.$AISolutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AISolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AISolutionCountArgs} args - Arguments to filter AISolutions to count.
     * @example
     * // Count the number of AISolutions
     * const count = await prisma.aISolution.count({
     *   where: {
     *     // ... the filter for the AISolutions we want to count
     *   }
     * })
    **/
    count<T extends AISolutionCountArgs>(
      args?: Subset<T, AISolutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AISolutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AISolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AISolutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AISolutionAggregateArgs>(args: Subset<T, AISolutionAggregateArgs>): Prisma.PrismaPromise<GetAISolutionAggregateType<T>>

    /**
     * Group by AISolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AISolutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AISolutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AISolutionGroupByArgs['orderBy'] }
        : { orderBy?: AISolutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AISolutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAISolutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AISolution model
   */
  readonly fields: AISolutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AISolution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AISolutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    modules<T extends AISolution$modulesArgs<ExtArgs> = {}>(args?: Subset<T, AISolution$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AISolutionModulePayload<ExtArgs>, T, "findMany"> | Null>
    quotes<T extends AISolution$quotesArgs<ExtArgs> = {}>(args?: Subset<T, AISolution$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany"> | Null>
    clientSolutions<T extends AISolution$clientSolutionsArgs<ExtArgs> = {}>(args?: Subset<T, AISolution$clientSolutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSolutionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AISolution model
   */ 
  interface AISolutionFieldRefs {
    readonly id: FieldRef<"AISolution", 'String'>
    readonly name: FieldRef<"AISolution", 'String'>
    readonly category: FieldRef<"AISolution", 'String'>
    readonly description: FieldRef<"AISolution", 'String'>
    readonly tagline: FieldRef<"AISolution", 'String'>
    readonly longDescription: FieldRef<"AISolution", 'String'>
    readonly targetIndustries: FieldRef<"AISolution", 'String[]'>
    readonly targetFunctions: FieldRef<"AISolution", 'String[]'>
    readonly technicalRequirements: FieldRef<"AISolution", 'String[]'>
    readonly integrationPoints: FieldRef<"AISolution", 'String[]'>
    readonly pricingModels: FieldRef<"AISolution", 'String[]'>
    readonly typicalTimelineWeeks: FieldRef<"AISolution", 'Int'>
    readonly useCases: FieldRef<"AISolution", 'String[]'>
    readonly caseStudies: FieldRef<"AISolution", 'Json'>
    readonly isActive: FieldRef<"AISolution", 'Boolean'>
    readonly displayOrder: FieldRef<"AISolution", 'Int'>
    readonly createdAt: FieldRef<"AISolution", 'DateTime'>
    readonly updatedAt: FieldRef<"AISolution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AISolution findUnique
   */
  export type AISolutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolution
     */
    select?: AISolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionInclude<ExtArgs> | null
    /**
     * Filter, which AISolution to fetch.
     */
    where: AISolutionWhereUniqueInput
  }

  /**
   * AISolution findUniqueOrThrow
   */
  export type AISolutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolution
     */
    select?: AISolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionInclude<ExtArgs> | null
    /**
     * Filter, which AISolution to fetch.
     */
    where: AISolutionWhereUniqueInput
  }

  /**
   * AISolution findFirst
   */
  export type AISolutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolution
     */
    select?: AISolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionInclude<ExtArgs> | null
    /**
     * Filter, which AISolution to fetch.
     */
    where?: AISolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AISolutions to fetch.
     */
    orderBy?: AISolutionOrderByWithRelationInput | AISolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AISolutions.
     */
    cursor?: AISolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AISolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AISolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AISolutions.
     */
    distinct?: AISolutionScalarFieldEnum | AISolutionScalarFieldEnum[]
  }

  /**
   * AISolution findFirstOrThrow
   */
  export type AISolutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolution
     */
    select?: AISolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionInclude<ExtArgs> | null
    /**
     * Filter, which AISolution to fetch.
     */
    where?: AISolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AISolutions to fetch.
     */
    orderBy?: AISolutionOrderByWithRelationInput | AISolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AISolutions.
     */
    cursor?: AISolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AISolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AISolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AISolutions.
     */
    distinct?: AISolutionScalarFieldEnum | AISolutionScalarFieldEnum[]
  }

  /**
   * AISolution findMany
   */
  export type AISolutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolution
     */
    select?: AISolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionInclude<ExtArgs> | null
    /**
     * Filter, which AISolutions to fetch.
     */
    where?: AISolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AISolutions to fetch.
     */
    orderBy?: AISolutionOrderByWithRelationInput | AISolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AISolutions.
     */
    cursor?: AISolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AISolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AISolutions.
     */
    skip?: number
    distinct?: AISolutionScalarFieldEnum | AISolutionScalarFieldEnum[]
  }

  /**
   * AISolution create
   */
  export type AISolutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolution
     */
    select?: AISolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionInclude<ExtArgs> | null
    /**
     * The data needed to create a AISolution.
     */
    data: XOR<AISolutionCreateInput, AISolutionUncheckedCreateInput>
  }

  /**
   * AISolution createMany
   */
  export type AISolutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AISolutions.
     */
    data: AISolutionCreateManyInput | AISolutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AISolution createManyAndReturn
   */
  export type AISolutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolution
     */
    select?: AISolutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AISolutions.
     */
    data: AISolutionCreateManyInput | AISolutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AISolution update
   */
  export type AISolutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolution
     */
    select?: AISolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionInclude<ExtArgs> | null
    /**
     * The data needed to update a AISolution.
     */
    data: XOR<AISolutionUpdateInput, AISolutionUncheckedUpdateInput>
    /**
     * Choose, which AISolution to update.
     */
    where: AISolutionWhereUniqueInput
  }

  /**
   * AISolution updateMany
   */
  export type AISolutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AISolutions.
     */
    data: XOR<AISolutionUpdateManyMutationInput, AISolutionUncheckedUpdateManyInput>
    /**
     * Filter which AISolutions to update
     */
    where?: AISolutionWhereInput
  }

  /**
   * AISolution upsert
   */
  export type AISolutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolution
     */
    select?: AISolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionInclude<ExtArgs> | null
    /**
     * The filter to search for the AISolution to update in case it exists.
     */
    where: AISolutionWhereUniqueInput
    /**
     * In case the AISolution found by the `where` argument doesn't exist, create a new AISolution with this data.
     */
    create: XOR<AISolutionCreateInput, AISolutionUncheckedCreateInput>
    /**
     * In case the AISolution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AISolutionUpdateInput, AISolutionUncheckedUpdateInput>
  }

  /**
   * AISolution delete
   */
  export type AISolutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolution
     */
    select?: AISolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionInclude<ExtArgs> | null
    /**
     * Filter which AISolution to delete.
     */
    where: AISolutionWhereUniqueInput
  }

  /**
   * AISolution deleteMany
   */
  export type AISolutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AISolutions to delete
     */
    where?: AISolutionWhereInput
  }

  /**
   * AISolution.modules
   */
  export type AISolution$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolutionModule
     */
    select?: AISolutionModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionModuleInclude<ExtArgs> | null
    where?: AISolutionModuleWhereInput
    orderBy?: AISolutionModuleOrderByWithRelationInput | AISolutionModuleOrderByWithRelationInput[]
    cursor?: AISolutionModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AISolutionModuleScalarFieldEnum | AISolutionModuleScalarFieldEnum[]
  }

  /**
   * AISolution.quotes
   */
  export type AISolution$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * AISolution.clientSolutions
   */
  export type AISolution$clientSolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSolution
     */
    select?: ClientSolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSolutionInclude<ExtArgs> | null
    where?: ClientSolutionWhereInput
    orderBy?: ClientSolutionOrderByWithRelationInput | ClientSolutionOrderByWithRelationInput[]
    cursor?: ClientSolutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientSolutionScalarFieldEnum | ClientSolutionScalarFieldEnum[]
  }

  /**
   * AISolution without action
   */
  export type AISolutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolution
     */
    select?: AISolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionInclude<ExtArgs> | null
  }


  /**
   * Model AISolutionModule
   */

  export type AggregateAISolutionModule = {
    _count: AISolutionModuleCountAggregateOutputType | null
    _avg: AISolutionModuleAvgAggregateOutputType | null
    _sum: AISolutionModuleSumAggregateOutputType | null
    _min: AISolutionModuleMinAggregateOutputType | null
    _max: AISolutionModuleMaxAggregateOutputType | null
  }

  export type AISolutionModuleAvgAggregateOutputType = {
    basePrice: number | null
  }

  export type AISolutionModuleSumAggregateOutputType = {
    basePrice: number | null
  }

  export type AISolutionModuleMinAggregateOutputType = {
    id: string | null
    solutionId: string | null
    name: string | null
    description: string | null
    basePrice: number | null
    isOptional: boolean | null
  }

  export type AISolutionModuleMaxAggregateOutputType = {
    id: string | null
    solutionId: string | null
    name: string | null
    description: string | null
    basePrice: number | null
    isOptional: boolean | null
  }

  export type AISolutionModuleCountAggregateOutputType = {
    id: number
    solutionId: number
    name: number
    description: number
    basePrice: number
    isOptional: number
    _all: number
  }


  export type AISolutionModuleAvgAggregateInputType = {
    basePrice?: true
  }

  export type AISolutionModuleSumAggregateInputType = {
    basePrice?: true
  }

  export type AISolutionModuleMinAggregateInputType = {
    id?: true
    solutionId?: true
    name?: true
    description?: true
    basePrice?: true
    isOptional?: true
  }

  export type AISolutionModuleMaxAggregateInputType = {
    id?: true
    solutionId?: true
    name?: true
    description?: true
    basePrice?: true
    isOptional?: true
  }

  export type AISolutionModuleCountAggregateInputType = {
    id?: true
    solutionId?: true
    name?: true
    description?: true
    basePrice?: true
    isOptional?: true
    _all?: true
  }

  export type AISolutionModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AISolutionModule to aggregate.
     */
    where?: AISolutionModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AISolutionModules to fetch.
     */
    orderBy?: AISolutionModuleOrderByWithRelationInput | AISolutionModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AISolutionModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AISolutionModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AISolutionModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AISolutionModules
    **/
    _count?: true | AISolutionModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AISolutionModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AISolutionModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AISolutionModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AISolutionModuleMaxAggregateInputType
  }

  export type GetAISolutionModuleAggregateType<T extends AISolutionModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateAISolutionModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAISolutionModule[P]>
      : GetScalarType<T[P], AggregateAISolutionModule[P]>
  }




  export type AISolutionModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AISolutionModuleWhereInput
    orderBy?: AISolutionModuleOrderByWithAggregationInput | AISolutionModuleOrderByWithAggregationInput[]
    by: AISolutionModuleScalarFieldEnum[] | AISolutionModuleScalarFieldEnum
    having?: AISolutionModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AISolutionModuleCountAggregateInputType | true
    _avg?: AISolutionModuleAvgAggregateInputType
    _sum?: AISolutionModuleSumAggregateInputType
    _min?: AISolutionModuleMinAggregateInputType
    _max?: AISolutionModuleMaxAggregateInputType
  }

  export type AISolutionModuleGroupByOutputType = {
    id: string
    solutionId: string
    name: string
    description: string | null
    basePrice: number
    isOptional: boolean
    _count: AISolutionModuleCountAggregateOutputType | null
    _avg: AISolutionModuleAvgAggregateOutputType | null
    _sum: AISolutionModuleSumAggregateOutputType | null
    _min: AISolutionModuleMinAggregateOutputType | null
    _max: AISolutionModuleMaxAggregateOutputType | null
  }

  type GetAISolutionModuleGroupByPayload<T extends AISolutionModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AISolutionModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AISolutionModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AISolutionModuleGroupByOutputType[P]>
            : GetScalarType<T[P], AISolutionModuleGroupByOutputType[P]>
        }
      >
    >


  export type AISolutionModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    solutionId?: boolean
    name?: boolean
    description?: boolean
    basePrice?: boolean
    isOptional?: boolean
    solution?: boolean | AISolutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aISolutionModule"]>

  export type AISolutionModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    solutionId?: boolean
    name?: boolean
    description?: boolean
    basePrice?: boolean
    isOptional?: boolean
    solution?: boolean | AISolutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aISolutionModule"]>

  export type AISolutionModuleSelectScalar = {
    id?: boolean
    solutionId?: boolean
    name?: boolean
    description?: boolean
    basePrice?: boolean
    isOptional?: boolean
  }

  export type AISolutionModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    solution?: boolean | AISolutionDefaultArgs<ExtArgs>
  }
  export type AISolutionModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    solution?: boolean | AISolutionDefaultArgs<ExtArgs>
  }

  export type $AISolutionModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AISolutionModule"
    objects: {
      solution: Prisma.$AISolutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      solutionId: string
      name: string
      description: string | null
      basePrice: number
      isOptional: boolean
    }, ExtArgs["result"]["aISolutionModule"]>
    composites: {}
  }

  type AISolutionModuleGetPayload<S extends boolean | null | undefined | AISolutionModuleDefaultArgs> = $Result.GetResult<Prisma.$AISolutionModulePayload, S>

  type AISolutionModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AISolutionModuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AISolutionModuleCountAggregateInputType | true
    }

  export interface AISolutionModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AISolutionModule'], meta: { name: 'AISolutionModule' } }
    /**
     * Find zero or one AISolutionModule that matches the filter.
     * @param {AISolutionModuleFindUniqueArgs} args - Arguments to find a AISolutionModule
     * @example
     * // Get one AISolutionModule
     * const aISolutionModule = await prisma.aISolutionModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AISolutionModuleFindUniqueArgs>(args: SelectSubset<T, AISolutionModuleFindUniqueArgs<ExtArgs>>): Prisma__AISolutionModuleClient<$Result.GetResult<Prisma.$AISolutionModulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AISolutionModule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AISolutionModuleFindUniqueOrThrowArgs} args - Arguments to find a AISolutionModule
     * @example
     * // Get one AISolutionModule
     * const aISolutionModule = await prisma.aISolutionModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AISolutionModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, AISolutionModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AISolutionModuleClient<$Result.GetResult<Prisma.$AISolutionModulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AISolutionModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AISolutionModuleFindFirstArgs} args - Arguments to find a AISolutionModule
     * @example
     * // Get one AISolutionModule
     * const aISolutionModule = await prisma.aISolutionModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AISolutionModuleFindFirstArgs>(args?: SelectSubset<T, AISolutionModuleFindFirstArgs<ExtArgs>>): Prisma__AISolutionModuleClient<$Result.GetResult<Prisma.$AISolutionModulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AISolutionModule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AISolutionModuleFindFirstOrThrowArgs} args - Arguments to find a AISolutionModule
     * @example
     * // Get one AISolutionModule
     * const aISolutionModule = await prisma.aISolutionModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AISolutionModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, AISolutionModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AISolutionModuleClient<$Result.GetResult<Prisma.$AISolutionModulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AISolutionModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AISolutionModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AISolutionModules
     * const aISolutionModules = await prisma.aISolutionModule.findMany()
     * 
     * // Get first 10 AISolutionModules
     * const aISolutionModules = await prisma.aISolutionModule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aISolutionModuleWithIdOnly = await prisma.aISolutionModule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AISolutionModuleFindManyArgs>(args?: SelectSubset<T, AISolutionModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AISolutionModulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AISolutionModule.
     * @param {AISolutionModuleCreateArgs} args - Arguments to create a AISolutionModule.
     * @example
     * // Create one AISolutionModule
     * const AISolutionModule = await prisma.aISolutionModule.create({
     *   data: {
     *     // ... data to create a AISolutionModule
     *   }
     * })
     * 
     */
    create<T extends AISolutionModuleCreateArgs>(args: SelectSubset<T, AISolutionModuleCreateArgs<ExtArgs>>): Prisma__AISolutionModuleClient<$Result.GetResult<Prisma.$AISolutionModulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AISolutionModules.
     * @param {AISolutionModuleCreateManyArgs} args - Arguments to create many AISolutionModules.
     * @example
     * // Create many AISolutionModules
     * const aISolutionModule = await prisma.aISolutionModule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AISolutionModuleCreateManyArgs>(args?: SelectSubset<T, AISolutionModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AISolutionModules and returns the data saved in the database.
     * @param {AISolutionModuleCreateManyAndReturnArgs} args - Arguments to create many AISolutionModules.
     * @example
     * // Create many AISolutionModules
     * const aISolutionModule = await prisma.aISolutionModule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AISolutionModules and only return the `id`
     * const aISolutionModuleWithIdOnly = await prisma.aISolutionModule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AISolutionModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, AISolutionModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AISolutionModulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AISolutionModule.
     * @param {AISolutionModuleDeleteArgs} args - Arguments to delete one AISolutionModule.
     * @example
     * // Delete one AISolutionModule
     * const AISolutionModule = await prisma.aISolutionModule.delete({
     *   where: {
     *     // ... filter to delete one AISolutionModule
     *   }
     * })
     * 
     */
    delete<T extends AISolutionModuleDeleteArgs>(args: SelectSubset<T, AISolutionModuleDeleteArgs<ExtArgs>>): Prisma__AISolutionModuleClient<$Result.GetResult<Prisma.$AISolutionModulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AISolutionModule.
     * @param {AISolutionModuleUpdateArgs} args - Arguments to update one AISolutionModule.
     * @example
     * // Update one AISolutionModule
     * const aISolutionModule = await prisma.aISolutionModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AISolutionModuleUpdateArgs>(args: SelectSubset<T, AISolutionModuleUpdateArgs<ExtArgs>>): Prisma__AISolutionModuleClient<$Result.GetResult<Prisma.$AISolutionModulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AISolutionModules.
     * @param {AISolutionModuleDeleteManyArgs} args - Arguments to filter AISolutionModules to delete.
     * @example
     * // Delete a few AISolutionModules
     * const { count } = await prisma.aISolutionModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AISolutionModuleDeleteManyArgs>(args?: SelectSubset<T, AISolutionModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AISolutionModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AISolutionModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AISolutionModules
     * const aISolutionModule = await prisma.aISolutionModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AISolutionModuleUpdateManyArgs>(args: SelectSubset<T, AISolutionModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AISolutionModule.
     * @param {AISolutionModuleUpsertArgs} args - Arguments to update or create a AISolutionModule.
     * @example
     * // Update or create a AISolutionModule
     * const aISolutionModule = await prisma.aISolutionModule.upsert({
     *   create: {
     *     // ... data to create a AISolutionModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AISolutionModule we want to update
     *   }
     * })
     */
    upsert<T extends AISolutionModuleUpsertArgs>(args: SelectSubset<T, AISolutionModuleUpsertArgs<ExtArgs>>): Prisma__AISolutionModuleClient<$Result.GetResult<Prisma.$AISolutionModulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AISolutionModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AISolutionModuleCountArgs} args - Arguments to filter AISolutionModules to count.
     * @example
     * // Count the number of AISolutionModules
     * const count = await prisma.aISolutionModule.count({
     *   where: {
     *     // ... the filter for the AISolutionModules we want to count
     *   }
     * })
    **/
    count<T extends AISolutionModuleCountArgs>(
      args?: Subset<T, AISolutionModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AISolutionModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AISolutionModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AISolutionModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AISolutionModuleAggregateArgs>(args: Subset<T, AISolutionModuleAggregateArgs>): Prisma.PrismaPromise<GetAISolutionModuleAggregateType<T>>

    /**
     * Group by AISolutionModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AISolutionModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AISolutionModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AISolutionModuleGroupByArgs['orderBy'] }
        : { orderBy?: AISolutionModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AISolutionModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAISolutionModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AISolutionModule model
   */
  readonly fields: AISolutionModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AISolutionModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AISolutionModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    solution<T extends AISolutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AISolutionDefaultArgs<ExtArgs>>): Prisma__AISolutionClient<$Result.GetResult<Prisma.$AISolutionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AISolutionModule model
   */ 
  interface AISolutionModuleFieldRefs {
    readonly id: FieldRef<"AISolutionModule", 'String'>
    readonly solutionId: FieldRef<"AISolutionModule", 'String'>
    readonly name: FieldRef<"AISolutionModule", 'String'>
    readonly description: FieldRef<"AISolutionModule", 'String'>
    readonly basePrice: FieldRef<"AISolutionModule", 'Float'>
    readonly isOptional: FieldRef<"AISolutionModule", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AISolutionModule findUnique
   */
  export type AISolutionModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolutionModule
     */
    select?: AISolutionModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionModuleInclude<ExtArgs> | null
    /**
     * Filter, which AISolutionModule to fetch.
     */
    where: AISolutionModuleWhereUniqueInput
  }

  /**
   * AISolutionModule findUniqueOrThrow
   */
  export type AISolutionModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolutionModule
     */
    select?: AISolutionModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionModuleInclude<ExtArgs> | null
    /**
     * Filter, which AISolutionModule to fetch.
     */
    where: AISolutionModuleWhereUniqueInput
  }

  /**
   * AISolutionModule findFirst
   */
  export type AISolutionModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolutionModule
     */
    select?: AISolutionModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionModuleInclude<ExtArgs> | null
    /**
     * Filter, which AISolutionModule to fetch.
     */
    where?: AISolutionModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AISolutionModules to fetch.
     */
    orderBy?: AISolutionModuleOrderByWithRelationInput | AISolutionModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AISolutionModules.
     */
    cursor?: AISolutionModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AISolutionModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AISolutionModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AISolutionModules.
     */
    distinct?: AISolutionModuleScalarFieldEnum | AISolutionModuleScalarFieldEnum[]
  }

  /**
   * AISolutionModule findFirstOrThrow
   */
  export type AISolutionModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolutionModule
     */
    select?: AISolutionModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionModuleInclude<ExtArgs> | null
    /**
     * Filter, which AISolutionModule to fetch.
     */
    where?: AISolutionModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AISolutionModules to fetch.
     */
    orderBy?: AISolutionModuleOrderByWithRelationInput | AISolutionModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AISolutionModules.
     */
    cursor?: AISolutionModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AISolutionModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AISolutionModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AISolutionModules.
     */
    distinct?: AISolutionModuleScalarFieldEnum | AISolutionModuleScalarFieldEnum[]
  }

  /**
   * AISolutionModule findMany
   */
  export type AISolutionModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolutionModule
     */
    select?: AISolutionModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionModuleInclude<ExtArgs> | null
    /**
     * Filter, which AISolutionModules to fetch.
     */
    where?: AISolutionModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AISolutionModules to fetch.
     */
    orderBy?: AISolutionModuleOrderByWithRelationInput | AISolutionModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AISolutionModules.
     */
    cursor?: AISolutionModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AISolutionModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AISolutionModules.
     */
    skip?: number
    distinct?: AISolutionModuleScalarFieldEnum | AISolutionModuleScalarFieldEnum[]
  }

  /**
   * AISolutionModule create
   */
  export type AISolutionModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolutionModule
     */
    select?: AISolutionModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a AISolutionModule.
     */
    data: XOR<AISolutionModuleCreateInput, AISolutionModuleUncheckedCreateInput>
  }

  /**
   * AISolutionModule createMany
   */
  export type AISolutionModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AISolutionModules.
     */
    data: AISolutionModuleCreateManyInput | AISolutionModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AISolutionModule createManyAndReturn
   */
  export type AISolutionModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolutionModule
     */
    select?: AISolutionModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AISolutionModules.
     */
    data: AISolutionModuleCreateManyInput | AISolutionModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AISolutionModule update
   */
  export type AISolutionModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolutionModule
     */
    select?: AISolutionModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a AISolutionModule.
     */
    data: XOR<AISolutionModuleUpdateInput, AISolutionModuleUncheckedUpdateInput>
    /**
     * Choose, which AISolutionModule to update.
     */
    where: AISolutionModuleWhereUniqueInput
  }

  /**
   * AISolutionModule updateMany
   */
  export type AISolutionModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AISolutionModules.
     */
    data: XOR<AISolutionModuleUpdateManyMutationInput, AISolutionModuleUncheckedUpdateManyInput>
    /**
     * Filter which AISolutionModules to update
     */
    where?: AISolutionModuleWhereInput
  }

  /**
   * AISolutionModule upsert
   */
  export type AISolutionModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolutionModule
     */
    select?: AISolutionModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the AISolutionModule to update in case it exists.
     */
    where: AISolutionModuleWhereUniqueInput
    /**
     * In case the AISolutionModule found by the `where` argument doesn't exist, create a new AISolutionModule with this data.
     */
    create: XOR<AISolutionModuleCreateInput, AISolutionModuleUncheckedCreateInput>
    /**
     * In case the AISolutionModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AISolutionModuleUpdateInput, AISolutionModuleUncheckedUpdateInput>
  }

  /**
   * AISolutionModule delete
   */
  export type AISolutionModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolutionModule
     */
    select?: AISolutionModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionModuleInclude<ExtArgs> | null
    /**
     * Filter which AISolutionModule to delete.
     */
    where: AISolutionModuleWhereUniqueInput
  }

  /**
   * AISolutionModule deleteMany
   */
  export type AISolutionModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AISolutionModules to delete
     */
    where?: AISolutionModuleWhereInput
  }

  /**
   * AISolutionModule without action
   */
  export type AISolutionModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AISolutionModule
     */
    select?: AISolutionModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AISolutionModuleInclude<ExtArgs> | null
  }


  /**
   * Model Quote
   */

  export type AggregateQuote = {
    _count: QuoteCountAggregateOutputType | null
    _avg: QuoteAvgAggregateOutputType | null
    _sum: QuoteSumAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  export type QuoteAvgAggregateOutputType = {
    version: number | null
    timelineWeeks: number | null
    totalPrice: number | null
  }

  export type QuoteSumAggregateOutputType = {
    version: number | null
    timelineWeeks: number | null
    totalPrice: number | null
  }

  export type QuoteMinAggregateOutputType = {
    id: string | null
    solutionId: string | null
    clientId: string | null
    quoteNumber: string | null
    version: number | null
    status: string | null
    scope: string | null
    timelineWeeks: number | null
    totalPrice: number | null
    validUntil: Date | null
    requestedBy: string | null
    requestedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteMaxAggregateOutputType = {
    id: string | null
    solutionId: string | null
    clientId: string | null
    quoteNumber: string | null
    version: number | null
    status: string | null
    scope: string | null
    timelineWeeks: number | null
    totalPrice: number | null
    validUntil: Date | null
    requestedBy: string | null
    requestedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteCountAggregateOutputType = {
    id: number
    solutionId: number
    clientId: number
    quoteNumber: number
    version: number
    status: number
    scope: number
    timelineWeeks: number
    totalPrice: number
    validUntil: number
    requestedBy: number
    requestedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuoteAvgAggregateInputType = {
    version?: true
    timelineWeeks?: true
    totalPrice?: true
  }

  export type QuoteSumAggregateInputType = {
    version?: true
    timelineWeeks?: true
    totalPrice?: true
  }

  export type QuoteMinAggregateInputType = {
    id?: true
    solutionId?: true
    clientId?: true
    quoteNumber?: true
    version?: true
    status?: true
    scope?: true
    timelineWeeks?: true
    totalPrice?: true
    validUntil?: true
    requestedBy?: true
    requestedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteMaxAggregateInputType = {
    id?: true
    solutionId?: true
    clientId?: true
    quoteNumber?: true
    version?: true
    status?: true
    scope?: true
    timelineWeeks?: true
    totalPrice?: true
    validUntil?: true
    requestedBy?: true
    requestedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteCountAggregateInputType = {
    id?: true
    solutionId?: true
    clientId?: true
    quoteNumber?: true
    version?: true
    status?: true
    scope?: true
    timelineWeeks?: true
    totalPrice?: true
    validUntil?: true
    requestedBy?: true
    requestedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quote to aggregate.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotes
    **/
    _count?: true | QuoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteMaxAggregateInputType
  }

  export type GetQuoteAggregateType<T extends QuoteAggregateArgs> = {
        [P in keyof T & keyof AggregateQuote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuote[P]>
      : GetScalarType<T[P], AggregateQuote[P]>
  }




  export type QuoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithAggregationInput | QuoteOrderByWithAggregationInput[]
    by: QuoteScalarFieldEnum[] | QuoteScalarFieldEnum
    having?: QuoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteCountAggregateInputType | true
    _avg?: QuoteAvgAggregateInputType
    _sum?: QuoteSumAggregateInputType
    _min?: QuoteMinAggregateInputType
    _max?: QuoteMaxAggregateInputType
  }

  export type QuoteGroupByOutputType = {
    id: string
    solutionId: string
    clientId: string | null
    quoteNumber: string
    version: number
    status: string
    scope: string | null
    timelineWeeks: number | null
    totalPrice: number
    validUntil: Date | null
    requestedBy: string | null
    requestedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: QuoteCountAggregateOutputType | null
    _avg: QuoteAvgAggregateOutputType | null
    _sum: QuoteSumAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  type GetQuoteGroupByPayload<T extends QuoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteGroupByOutputType[P]>
        }
      >
    >


  export type QuoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    solutionId?: boolean
    clientId?: boolean
    quoteNumber?: boolean
    version?: boolean
    status?: boolean
    scope?: boolean
    timelineWeeks?: boolean
    totalPrice?: boolean
    validUntil?: boolean
    requestedBy?: boolean
    requestedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    solution?: boolean | AISolutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    solutionId?: boolean
    clientId?: boolean
    quoteNumber?: boolean
    version?: boolean
    status?: boolean
    scope?: boolean
    timelineWeeks?: boolean
    totalPrice?: boolean
    validUntil?: boolean
    requestedBy?: boolean
    requestedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    solution?: boolean | AISolutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectScalar = {
    id?: boolean
    solutionId?: boolean
    clientId?: boolean
    quoteNumber?: boolean
    version?: boolean
    status?: boolean
    scope?: boolean
    timelineWeeks?: boolean
    totalPrice?: boolean
    validUntil?: boolean
    requestedBy?: boolean
    requestedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    solution?: boolean | AISolutionDefaultArgs<ExtArgs>
  }
  export type QuoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    solution?: boolean | AISolutionDefaultArgs<ExtArgs>
  }

  export type $QuotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quote"
    objects: {
      solution: Prisma.$AISolutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      solutionId: string
      clientId: string | null
      quoteNumber: string
      version: number
      status: string
      scope: string | null
      timelineWeeks: number | null
      totalPrice: number
      validUntil: Date | null
      requestedBy: string | null
      requestedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quote"]>
    composites: {}
  }

  type QuoteGetPayload<S extends boolean | null | undefined | QuoteDefaultArgs> = $Result.GetResult<Prisma.$QuotePayload, S>

  type QuoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuoteCountAggregateInputType | true
    }

  export interface QuoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quote'], meta: { name: 'Quote' } }
    /**
     * Find zero or one Quote that matches the filter.
     * @param {QuoteFindUniqueArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteFindUniqueArgs>(args: SelectSubset<T, QuoteFindUniqueArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Quote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuoteFindUniqueOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Quote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteFindFirstArgs>(args?: SelectSubset<T, QuoteFindFirstArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Quote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotes
     * const quotes = await prisma.quote.findMany()
     * 
     * // Get first 10 Quotes
     * const quotes = await prisma.quote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteWithIdOnly = await prisma.quote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteFindManyArgs>(args?: SelectSubset<T, QuoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Quote.
     * @param {QuoteCreateArgs} args - Arguments to create a Quote.
     * @example
     * // Create one Quote
     * const Quote = await prisma.quote.create({
     *   data: {
     *     // ... data to create a Quote
     *   }
     * })
     * 
     */
    create<T extends QuoteCreateArgs>(args: SelectSubset<T, QuoteCreateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Quotes.
     * @param {QuoteCreateManyArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteCreateManyArgs>(args?: SelectSubset<T, QuoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quotes and returns the data saved in the database.
     * @param {QuoteCreateManyAndReturnArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quotes and only return the `id`
     * const quoteWithIdOnly = await prisma.quote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Quote.
     * @param {QuoteDeleteArgs} args - Arguments to delete one Quote.
     * @example
     * // Delete one Quote
     * const Quote = await prisma.quote.delete({
     *   where: {
     *     // ... filter to delete one Quote
     *   }
     * })
     * 
     */
    delete<T extends QuoteDeleteArgs>(args: SelectSubset<T, QuoteDeleteArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Quote.
     * @param {QuoteUpdateArgs} args - Arguments to update one Quote.
     * @example
     * // Update one Quote
     * const quote = await prisma.quote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteUpdateArgs>(args: SelectSubset<T, QuoteUpdateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Quotes.
     * @param {QuoteDeleteManyArgs} args - Arguments to filter Quotes to delete.
     * @example
     * // Delete a few Quotes
     * const { count } = await prisma.quote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteDeleteManyArgs>(args?: SelectSubset<T, QuoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotes
     * const quote = await prisma.quote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteUpdateManyArgs>(args: SelectSubset<T, QuoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quote.
     * @param {QuoteUpsertArgs} args - Arguments to update or create a Quote.
     * @example
     * // Update or create a Quote
     * const quote = await prisma.quote.upsert({
     *   create: {
     *     // ... data to create a Quote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quote we want to update
     *   }
     * })
     */
    upsert<T extends QuoteUpsertArgs>(args: SelectSubset<T, QuoteUpsertArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteCountArgs} args - Arguments to filter Quotes to count.
     * @example
     * // Count the number of Quotes
     * const count = await prisma.quote.count({
     *   where: {
     *     // ... the filter for the Quotes we want to count
     *   }
     * })
    **/
    count<T extends QuoteCountArgs>(
      args?: Subset<T, QuoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteAggregateArgs>(args: Subset<T, QuoteAggregateArgs>): Prisma.PrismaPromise<GetQuoteAggregateType<T>>

    /**
     * Group by Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteGroupByArgs['orderBy'] }
        : { orderBy?: QuoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quote model
   */
  readonly fields: QuoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    solution<T extends AISolutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AISolutionDefaultArgs<ExtArgs>>): Prisma__AISolutionClient<$Result.GetResult<Prisma.$AISolutionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quote model
   */ 
  interface QuoteFieldRefs {
    readonly id: FieldRef<"Quote", 'String'>
    readonly solutionId: FieldRef<"Quote", 'String'>
    readonly clientId: FieldRef<"Quote", 'String'>
    readonly quoteNumber: FieldRef<"Quote", 'String'>
    readonly version: FieldRef<"Quote", 'Int'>
    readonly status: FieldRef<"Quote", 'String'>
    readonly scope: FieldRef<"Quote", 'String'>
    readonly timelineWeeks: FieldRef<"Quote", 'Int'>
    readonly totalPrice: FieldRef<"Quote", 'Float'>
    readonly validUntil: FieldRef<"Quote", 'DateTime'>
    readonly requestedBy: FieldRef<"Quote", 'String'>
    readonly requestedAt: FieldRef<"Quote", 'DateTime'>
    readonly createdAt: FieldRef<"Quote", 'DateTime'>
    readonly updatedAt: FieldRef<"Quote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quote findUnique
   */
  export type QuoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findUniqueOrThrow
   */
  export type QuoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findFirst
   */
  export type QuoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findFirstOrThrow
   */
  export type QuoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findMany
   */
  export type QuoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote create
   */
  export type QuoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Quote.
     */
    data: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
  }

  /**
   * Quote createMany
   */
  export type QuoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quote createManyAndReturn
   */
  export type QuoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quote update
   */
  export type QuoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Quote.
     */
    data: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
    /**
     * Choose, which Quote to update.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote updateMany
   */
  export type QuoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuoteWhereInput
  }

  /**
   * Quote upsert
   */
  export type QuoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Quote to update in case it exists.
     */
    where: QuoteWhereUniqueInput
    /**
     * In case the Quote found by the `where` argument doesn't exist, create a new Quote with this data.
     */
    create: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
    /**
     * In case the Quote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
  }

  /**
   * Quote delete
   */
  export type QuoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter which Quote to delete.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote deleteMany
   */
  export type QuoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotes to delete
     */
    where?: QuoteWhereInput
  }

  /**
   * Quote without action
   */
  export type QuoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityAvgAggregateOutputType = {
    durationMinutes: number | null
  }

  export type ActivitySumAggregateOutputType = {
    durationMinutes: number | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    leadId: string | null
    opportunityId: string | null
    contactId: string | null
    type: string | null
    subject: string | null
    description: string | null
    scheduledAt: Date | null
    completedAt: Date | null
    durationMinutes: number | null
    outcome: string | null
    sentiment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    leadId: string | null
    opportunityId: string | null
    contactId: string | null
    type: string | null
    subject: string | null
    description: string | null
    scheduledAt: Date | null
    completedAt: Date | null
    durationMinutes: number | null
    outcome: string | null
    sentiment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    ownerId: number
    leadId: number
    opportunityId: number
    contactId: number
    type: number
    subject: number
    description: number
    scheduledAt: number
    completedAt: number
    durationMinutes: number
    outcome: number
    sentiment: number
    keyTopics: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActivityAvgAggregateInputType = {
    durationMinutes?: true
  }

  export type ActivitySumAggregateInputType = {
    durationMinutes?: true
  }

  export type ActivityMinAggregateInputType = {
    id?: true
    ownerId?: true
    leadId?: true
    opportunityId?: true
    contactId?: true
    type?: true
    subject?: true
    description?: true
    scheduledAt?: true
    completedAt?: true
    durationMinutes?: true
    outcome?: true
    sentiment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    ownerId?: true
    leadId?: true
    opportunityId?: true
    contactId?: true
    type?: true
    subject?: true
    description?: true
    scheduledAt?: true
    completedAt?: true
    durationMinutes?: true
    outcome?: true
    sentiment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    ownerId?: true
    leadId?: true
    opportunityId?: true
    contactId?: true
    type?: true
    subject?: true
    description?: true
    scheduledAt?: true
    completedAt?: true
    durationMinutes?: true
    outcome?: true
    sentiment?: true
    keyTopics?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _avg?: ActivityAvgAggregateInputType
    _sum?: ActivitySumAggregateInputType
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    ownerId: string
    leadId: string | null
    opportunityId: string | null
    contactId: string | null
    type: string
    subject: string
    description: string | null
    scheduledAt: Date | null
    completedAt: Date | null
    durationMinutes: number | null
    outcome: string | null
    sentiment: string | null
    keyTopics: string[]
    createdAt: Date
    updatedAt: Date
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    leadId?: boolean
    opportunityId?: boolean
    contactId?: boolean
    type?: boolean
    subject?: boolean
    description?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    durationMinutes?: boolean
    outcome?: boolean
    sentiment?: boolean
    keyTopics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    lead?: boolean | Activity$leadArgs<ExtArgs>
    opportunity?: boolean | Activity$opportunityArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    leadId?: boolean
    opportunityId?: boolean
    contactId?: boolean
    type?: boolean
    subject?: boolean
    description?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    durationMinutes?: boolean
    outcome?: boolean
    sentiment?: boolean
    keyTopics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    lead?: boolean | Activity$leadArgs<ExtArgs>
    opportunity?: boolean | Activity$opportunityArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    ownerId?: boolean
    leadId?: boolean
    opportunityId?: boolean
    contactId?: boolean
    type?: boolean
    subject?: boolean
    description?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    durationMinutes?: boolean
    outcome?: boolean
    sentiment?: boolean
    keyTopics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    lead?: boolean | Activity$leadArgs<ExtArgs>
    opportunity?: boolean | Activity$opportunityArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    lead?: boolean | Activity$leadArgs<ExtArgs>
    opportunity?: boolean | Activity$opportunityArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      lead: Prisma.$LeadPayload<ExtArgs> | null
      opportunity: Prisma.$OpportunityPayload<ExtArgs> | null
      contact: Prisma.$ContactPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      leadId: string | null
      opportunityId: string | null
      contactId: string | null
      type: string
      subject: string
      description: string | null
      scheduledAt: Date | null
      completedAt: Date | null
      durationMinutes: number | null
      outcome: string | null
      sentiment: string | null
      keyTopics: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lead<T extends Activity$leadArgs<ExtArgs> = {}>(args?: Subset<T, Activity$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    opportunity<T extends Activity$opportunityArgs<ExtArgs> = {}>(args?: Subset<T, Activity$opportunityArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    contact<T extends Activity$contactArgs<ExtArgs> = {}>(args?: Subset<T, Activity$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */ 
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly ownerId: FieldRef<"Activity", 'String'>
    readonly leadId: FieldRef<"Activity", 'String'>
    readonly opportunityId: FieldRef<"Activity", 'String'>
    readonly contactId: FieldRef<"Activity", 'String'>
    readonly type: FieldRef<"Activity", 'String'>
    readonly subject: FieldRef<"Activity", 'String'>
    readonly description: FieldRef<"Activity", 'String'>
    readonly scheduledAt: FieldRef<"Activity", 'DateTime'>
    readonly completedAt: FieldRef<"Activity", 'DateTime'>
    readonly durationMinutes: FieldRef<"Activity", 'Int'>
    readonly outcome: FieldRef<"Activity", 'String'>
    readonly sentiment: FieldRef<"Activity", 'String'>
    readonly keyTopics: FieldRef<"Activity", 'String[]'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
    readonly updatedAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
  }

  /**
   * Activity.lead
   */
  export type Activity$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * Activity.opportunity
   */
  export type Activity$opportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
  }

  /**
   * Activity.contact
   */
  export type Activity$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    rating: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    rating: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    projectId: string | null
    milestoneId: string | null
    type: string | null
    rating: number | null
    comments: string | null
    deliveredOnTime: boolean | null
    metExpectations: boolean | null
    wouldRecommend: boolean | null
    responderName: string | null
    responderEmail: string | null
    createdAt: Date | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    projectId: string | null
    milestoneId: string | null
    type: string | null
    rating: number | null
    comments: string | null
    deliveredOnTime: boolean | null
    metExpectations: boolean | null
    wouldRecommend: boolean | null
    responderName: string | null
    responderEmail: string | null
    createdAt: Date | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    clientId: number
    projectId: number
    milestoneId: number
    type: number
    rating: number
    comments: number
    deliveredOnTime: number
    metExpectations: number
    wouldRecommend: number
    responderName: number
    responderEmail: number
    createdAt: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    rating?: true
  }

  export type FeedbackSumAggregateInputType = {
    rating?: true
  }

  export type FeedbackMinAggregateInputType = {
    id?: true
    clientId?: true
    projectId?: true
    milestoneId?: true
    type?: true
    rating?: true
    comments?: true
    deliveredOnTime?: true
    metExpectations?: true
    wouldRecommend?: true
    responderName?: true
    responderEmail?: true
    createdAt?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    clientId?: true
    projectId?: true
    milestoneId?: true
    type?: true
    rating?: true
    comments?: true
    deliveredOnTime?: true
    metExpectations?: true
    wouldRecommend?: true
    responderName?: true
    responderEmail?: true
    createdAt?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    clientId?: true
    projectId?: true
    milestoneId?: true
    type?: true
    rating?: true
    comments?: true
    deliveredOnTime?: true
    metExpectations?: true
    wouldRecommend?: true
    responderName?: true
    responderEmail?: true
    createdAt?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: string
    clientId: string
    projectId: string | null
    milestoneId: string | null
    type: string
    rating: number
    comments: string | null
    deliveredOnTime: boolean | null
    metExpectations: boolean | null
    wouldRecommend: boolean | null
    responderName: string | null
    responderEmail: string | null
    createdAt: Date
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    projectId?: boolean
    milestoneId?: boolean
    type?: boolean
    rating?: boolean
    comments?: boolean
    deliveredOnTime?: boolean
    metExpectations?: boolean
    wouldRecommend?: boolean
    responderName?: boolean
    responderEmail?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    projectId?: boolean
    milestoneId?: boolean
    type?: boolean
    rating?: boolean
    comments?: boolean
    deliveredOnTime?: boolean
    metExpectations?: boolean
    wouldRecommend?: boolean
    responderName?: boolean
    responderEmail?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectScalar = {
    id?: boolean
    clientId?: boolean
    projectId?: boolean
    milestoneId?: boolean
    type?: boolean
    rating?: boolean
    comments?: boolean
    deliveredOnTime?: boolean
    metExpectations?: boolean
    wouldRecommend?: boolean
    responderName?: boolean
    responderEmail?: boolean
    createdAt?: boolean
  }

  export type FeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type FeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $FeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      projectId: string | null
      milestoneId: string | null
      type: string
      rating: number
      comments: string | null
      deliveredOnTime: boolean | null
      metExpectations: boolean | null
      wouldRecommend: boolean | null
      responderName: string | null
      responderEmail: string | null
      createdAt: Date
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }

  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackFindUniqueArgs>(args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Feedback that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackFindFirstArgs>(args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackFindManyArgs>(args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
     */
    create<T extends FeedbackCreateArgs>(args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Feedbacks.
     * @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackCreateManyArgs>(args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feedbacks and returns the data saved in the database.
     * @param {FeedbackCreateManyAndReturnArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
     */
    delete<T extends FeedbackDeleteArgs>(args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackUpdateArgs>(args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackDeleteManyArgs>(args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackUpdateManyArgs>(args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackUpsertArgs>(args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feedback model
   */ 
  interface FeedbackFieldRefs {
    readonly id: FieldRef<"Feedback", 'String'>
    readonly clientId: FieldRef<"Feedback", 'String'>
    readonly projectId: FieldRef<"Feedback", 'String'>
    readonly milestoneId: FieldRef<"Feedback", 'String'>
    readonly type: FieldRef<"Feedback", 'String'>
    readonly rating: FieldRef<"Feedback", 'Int'>
    readonly comments: FieldRef<"Feedback", 'String'>
    readonly deliveredOnTime: FieldRef<"Feedback", 'Boolean'>
    readonly metExpectations: FieldRef<"Feedback", 'Boolean'>
    readonly wouldRecommend: FieldRef<"Feedback", 'Boolean'>
    readonly responderName: FieldRef<"Feedback", 'String'>
    readonly responderEmail: FieldRef<"Feedback", 'String'>
    readonly createdAt: FieldRef<"Feedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }

  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feedback createManyAndReturn
   */
  export type FeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
  }

  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }

  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
  }

  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    assigneeId: string | null
    ticketNumber: string | null
    title: string | null
    description: string | null
    type: $Enums.TicketType | null
    severity: $Enums.TicketSeverity | null
    status: $Enums.TicketStatus | null
    resolution: string | null
    rootCause: string | null
    slaResponseDue: Date | null
    slaResolutionDue: Date | null
    respondedAt: Date | null
    resolvedAt: Date | null
    closedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    assigneeId: string | null
    ticketNumber: string | null
    title: string | null
    description: string | null
    type: $Enums.TicketType | null
    severity: $Enums.TicketSeverity | null
    status: $Enums.TicketStatus | null
    resolution: string | null
    rootCause: string | null
    slaResponseDue: Date | null
    slaResolutionDue: Date | null
    respondedAt: Date | null
    resolvedAt: Date | null
    closedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    clientId: number
    assigneeId: number
    ticketNumber: number
    title: number
    description: number
    type: number
    severity: number
    status: number
    resolution: number
    rootCause: number
    slaResponseDue: number
    slaResolutionDue: number
    respondedAt: number
    resolvedAt: number
    closedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TicketMinAggregateInputType = {
    id?: true
    clientId?: true
    assigneeId?: true
    ticketNumber?: true
    title?: true
    description?: true
    type?: true
    severity?: true
    status?: true
    resolution?: true
    rootCause?: true
    slaResponseDue?: true
    slaResolutionDue?: true
    respondedAt?: true
    resolvedAt?: true
    closedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    clientId?: true
    assigneeId?: true
    ticketNumber?: true
    title?: true
    description?: true
    type?: true
    severity?: true
    status?: true
    resolution?: true
    rootCause?: true
    slaResponseDue?: true
    slaResolutionDue?: true
    respondedAt?: true
    resolvedAt?: true
    closedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    clientId?: true
    assigneeId?: true
    ticketNumber?: true
    title?: true
    description?: true
    type?: true
    severity?: true
    status?: true
    resolution?: true
    rootCause?: true
    slaResponseDue?: true
    slaResolutionDue?: true
    respondedAt?: true
    resolvedAt?: true
    closedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: string
    clientId: string
    assigneeId: string | null
    ticketNumber: string
    title: string
    description: string
    type: $Enums.TicketType
    severity: $Enums.TicketSeverity
    status: $Enums.TicketStatus
    resolution: string | null
    rootCause: string | null
    slaResponseDue: Date | null
    slaResolutionDue: Date | null
    respondedAt: Date | null
    resolvedAt: Date | null
    closedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    assigneeId?: boolean
    ticketNumber?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    severity?: boolean
    status?: boolean
    resolution?: boolean
    rootCause?: boolean
    slaResponseDue?: boolean
    slaResolutionDue?: boolean
    respondedAt?: boolean
    resolvedAt?: boolean
    closedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    assignee?: boolean | Ticket$assigneeArgs<ExtArgs>
    comments?: boolean | Ticket$commentsArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    assigneeId?: boolean
    ticketNumber?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    severity?: boolean
    status?: boolean
    resolution?: boolean
    rootCause?: boolean
    slaResponseDue?: boolean
    slaResolutionDue?: boolean
    respondedAt?: boolean
    resolvedAt?: boolean
    closedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    assignee?: boolean | Ticket$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectScalar = {
    id?: boolean
    clientId?: boolean
    assigneeId?: boolean
    ticketNumber?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    severity?: boolean
    status?: boolean
    resolution?: boolean
    rootCause?: boolean
    slaResponseDue?: boolean
    slaResolutionDue?: boolean
    respondedAt?: boolean
    resolvedAt?: boolean
    closedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    assignee?: boolean | Ticket$assigneeArgs<ExtArgs>
    comments?: boolean | Ticket$commentsArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    assignee?: boolean | Ticket$assigneeArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      assignee: Prisma.$UserPayload<ExtArgs> | null
      comments: Prisma.$TicketCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      assigneeId: string | null
      ticketNumber: string
      title: string
      description: string
      type: $Enums.TicketType
      severity: $Enums.TicketSeverity
      status: $Enums.TicketStatus
      resolution: string | null
      rootCause: string | null
      slaResponseDue: Date | null
      slaResolutionDue: Date | null
      respondedAt: Date | null
      resolvedAt: Date | null
      closedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignee<T extends Ticket$assigneeArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$assigneeArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comments<T extends Ticket$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */ 
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'String'>
    readonly clientId: FieldRef<"Ticket", 'String'>
    readonly assigneeId: FieldRef<"Ticket", 'String'>
    readonly ticketNumber: FieldRef<"Ticket", 'String'>
    readonly title: FieldRef<"Ticket", 'String'>
    readonly description: FieldRef<"Ticket", 'String'>
    readonly type: FieldRef<"Ticket", 'TicketType'>
    readonly severity: FieldRef<"Ticket", 'TicketSeverity'>
    readonly status: FieldRef<"Ticket", 'TicketStatus'>
    readonly resolution: FieldRef<"Ticket", 'String'>
    readonly rootCause: FieldRef<"Ticket", 'String'>
    readonly slaResponseDue: FieldRef<"Ticket", 'DateTime'>
    readonly slaResolutionDue: FieldRef<"Ticket", 'DateTime'>
    readonly respondedAt: FieldRef<"Ticket", 'DateTime'>
    readonly resolvedAt: FieldRef<"Ticket", 'DateTime'>
    readonly closedAt: FieldRef<"Ticket", 'DateTime'>
    readonly createdAt: FieldRef<"Ticket", 'DateTime'>
    readonly updatedAt: FieldRef<"Ticket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket createManyAndReturn
   */
  export type TicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
  }

  /**
   * Ticket.assignee
   */
  export type Ticket$assigneeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Ticket.comments
   */
  export type Ticket$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    cursor?: TicketCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model TicketComment
   */

  export type AggregateTicketComment = {
    _count: TicketCommentCountAggregateOutputType | null
    _min: TicketCommentMinAggregateOutputType | null
    _max: TicketCommentMaxAggregateOutputType | null
  }

  export type TicketCommentMinAggregateOutputType = {
    id: string | null
    ticketId: string | null
    authorId: string | null
    content: string | null
    isInternal: boolean | null
    createdAt: Date | null
  }

  export type TicketCommentMaxAggregateOutputType = {
    id: string | null
    ticketId: string | null
    authorId: string | null
    content: string | null
    isInternal: boolean | null
    createdAt: Date | null
  }

  export type TicketCommentCountAggregateOutputType = {
    id: number
    ticketId: number
    authorId: number
    content: number
    isInternal: number
    createdAt: number
    _all: number
  }


  export type TicketCommentMinAggregateInputType = {
    id?: true
    ticketId?: true
    authorId?: true
    content?: true
    isInternal?: true
    createdAt?: true
  }

  export type TicketCommentMaxAggregateInputType = {
    id?: true
    ticketId?: true
    authorId?: true
    content?: true
    isInternal?: true
    createdAt?: true
  }

  export type TicketCommentCountAggregateInputType = {
    id?: true
    ticketId?: true
    authorId?: true
    content?: true
    isInternal?: true
    createdAt?: true
    _all?: true
  }

  export type TicketCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketComment to aggregate.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketComments
    **/
    _count?: true | TicketCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketCommentMaxAggregateInputType
  }

  export type GetTicketCommentAggregateType<T extends TicketCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketComment[P]>
      : GetScalarType<T[P], AggregateTicketComment[P]>
  }




  export type TicketCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithAggregationInput | TicketCommentOrderByWithAggregationInput[]
    by: TicketCommentScalarFieldEnum[] | TicketCommentScalarFieldEnum
    having?: TicketCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCommentCountAggregateInputType | true
    _min?: TicketCommentMinAggregateInputType
    _max?: TicketCommentMaxAggregateInputType
  }

  export type TicketCommentGroupByOutputType = {
    id: string
    ticketId: string
    authorId: string
    content: string
    isInternal: boolean
    createdAt: Date
    _count: TicketCommentCountAggregateOutputType | null
    _min: TicketCommentMinAggregateOutputType | null
    _max: TicketCommentMaxAggregateOutputType | null
  }

  type GetTicketCommentGroupByPayload<T extends TicketCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketCommentGroupByOutputType[P]>
            : GetScalarType<T[P], TicketCommentGroupByOutputType[P]>
        }
      >
    >


  export type TicketCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    authorId?: boolean
    content?: boolean
    isInternal?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>

  export type TicketCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    authorId?: boolean
    content?: boolean
    isInternal?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>

  export type TicketCommentSelectScalar = {
    id?: boolean
    ticketId?: boolean
    authorId?: boolean
    content?: boolean
    isInternal?: boolean
    createdAt?: boolean
  }

  export type TicketCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type TicketCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }

  export type $TicketCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketComment"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketId: string
      authorId: string
      content: string
      isInternal: boolean
      createdAt: Date
    }, ExtArgs["result"]["ticketComment"]>
    composites: {}
  }

  type TicketCommentGetPayload<S extends boolean | null | undefined | TicketCommentDefaultArgs> = $Result.GetResult<Prisma.$TicketCommentPayload, S>

  type TicketCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketCommentCountAggregateInputType | true
    }

  export interface TicketCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketComment'], meta: { name: 'TicketComment' } }
    /**
     * Find zero or one TicketComment that matches the filter.
     * @param {TicketCommentFindUniqueArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketCommentFindUniqueArgs>(args: SelectSubset<T, TicketCommentFindUniqueArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TicketComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketCommentFindUniqueOrThrowArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TicketComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindFirstArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketCommentFindFirstArgs>(args?: SelectSubset<T, TicketCommentFindFirstArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TicketComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindFirstOrThrowArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TicketComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketComments
     * const ticketComments = await prisma.ticketComment.findMany()
     * 
     * // Get first 10 TicketComments
     * const ticketComments = await prisma.ticketComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketCommentFindManyArgs>(args?: SelectSubset<T, TicketCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TicketComment.
     * @param {TicketCommentCreateArgs} args - Arguments to create a TicketComment.
     * @example
     * // Create one TicketComment
     * const TicketComment = await prisma.ticketComment.create({
     *   data: {
     *     // ... data to create a TicketComment
     *   }
     * })
     * 
     */
    create<T extends TicketCommentCreateArgs>(args: SelectSubset<T, TicketCommentCreateArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TicketComments.
     * @param {TicketCommentCreateManyArgs} args - Arguments to create many TicketComments.
     * @example
     * // Create many TicketComments
     * const ticketComment = await prisma.ticketComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCommentCreateManyArgs>(args?: SelectSubset<T, TicketCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketComments and returns the data saved in the database.
     * @param {TicketCommentCreateManyAndReturnArgs} args - Arguments to create many TicketComments.
     * @example
     * // Create many TicketComments
     * const ticketComment = await prisma.ticketComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketComments and only return the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TicketComment.
     * @param {TicketCommentDeleteArgs} args - Arguments to delete one TicketComment.
     * @example
     * // Delete one TicketComment
     * const TicketComment = await prisma.ticketComment.delete({
     *   where: {
     *     // ... filter to delete one TicketComment
     *   }
     * })
     * 
     */
    delete<T extends TicketCommentDeleteArgs>(args: SelectSubset<T, TicketCommentDeleteArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TicketComment.
     * @param {TicketCommentUpdateArgs} args - Arguments to update one TicketComment.
     * @example
     * // Update one TicketComment
     * const ticketComment = await prisma.ticketComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketCommentUpdateArgs>(args: SelectSubset<T, TicketCommentUpdateArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TicketComments.
     * @param {TicketCommentDeleteManyArgs} args - Arguments to filter TicketComments to delete.
     * @example
     * // Delete a few TicketComments
     * const { count } = await prisma.ticketComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketCommentDeleteManyArgs>(args?: SelectSubset<T, TicketCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketComments
     * const ticketComment = await prisma.ticketComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketCommentUpdateManyArgs>(args: SelectSubset<T, TicketCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketComment.
     * @param {TicketCommentUpsertArgs} args - Arguments to update or create a TicketComment.
     * @example
     * // Update or create a TicketComment
     * const ticketComment = await prisma.ticketComment.upsert({
     *   create: {
     *     // ... data to create a TicketComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketComment we want to update
     *   }
     * })
     */
    upsert<T extends TicketCommentUpsertArgs>(args: SelectSubset<T, TicketCommentUpsertArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TicketComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentCountArgs} args - Arguments to filter TicketComments to count.
     * @example
     * // Count the number of TicketComments
     * const count = await prisma.ticketComment.count({
     *   where: {
     *     // ... the filter for the TicketComments we want to count
     *   }
     * })
    **/
    count<T extends TicketCommentCountArgs>(
      args?: Subset<T, TicketCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketCommentAggregateArgs>(args: Subset<T, TicketCommentAggregateArgs>): Prisma.PrismaPromise<GetTicketCommentAggregateType<T>>

    /**
     * Group by TicketComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketCommentGroupByArgs['orderBy'] }
        : { orderBy?: TicketCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketComment model
   */
  readonly fields: TicketCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketComment model
   */ 
  interface TicketCommentFieldRefs {
    readonly id: FieldRef<"TicketComment", 'String'>
    readonly ticketId: FieldRef<"TicketComment", 'String'>
    readonly authorId: FieldRef<"TicketComment", 'String'>
    readonly content: FieldRef<"TicketComment", 'String'>
    readonly isInternal: FieldRef<"TicketComment", 'Boolean'>
    readonly createdAt: FieldRef<"TicketComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketComment findUnique
   */
  export type TicketCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment findUniqueOrThrow
   */
  export type TicketCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment findFirst
   */
  export type TicketCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketComments.
     */
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment findFirstOrThrow
   */
  export type TicketCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketComments.
     */
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment findMany
   */
  export type TicketCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComments to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment create
   */
  export type TicketCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketComment.
     */
    data: XOR<TicketCommentCreateInput, TicketCommentUncheckedCreateInput>
  }

  /**
   * TicketComment createMany
   */
  export type TicketCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketComments.
     */
    data: TicketCommentCreateManyInput | TicketCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketComment createManyAndReturn
   */
  export type TicketCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TicketComments.
     */
    data: TicketCommentCreateManyInput | TicketCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketComment update
   */
  export type TicketCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketComment.
     */
    data: XOR<TicketCommentUpdateInput, TicketCommentUncheckedUpdateInput>
    /**
     * Choose, which TicketComment to update.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment updateMany
   */
  export type TicketCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketComments.
     */
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyInput>
    /**
     * Filter which TicketComments to update
     */
    where?: TicketCommentWhereInput
  }

  /**
   * TicketComment upsert
   */
  export type TicketCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketComment to update in case it exists.
     */
    where: TicketCommentWhereUniqueInput
    /**
     * In case the TicketComment found by the `where` argument doesn't exist, create a new TicketComment with this data.
     */
    create: XOR<TicketCommentCreateInput, TicketCommentUncheckedCreateInput>
    /**
     * In case the TicketComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketCommentUpdateInput, TicketCommentUncheckedUpdateInput>
  }

  /**
   * TicketComment delete
   */
  export type TicketCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter which TicketComment to delete.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment deleteMany
   */
  export type TicketCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketComments to delete
     */
    where?: TicketCommentWhereInput
  }

  /**
   * TicketComment without action
   */
  export type TicketCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    authorId: string | null
    entityType: string | null
    entityId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    authorId: string | null
    entityType: string | null
    entityId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    authorId: number
    entityType: number
    entityId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    authorId?: true
    entityType?: true
    entityId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    authorId?: true
    entityType?: true
    entityId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    authorId?: true
    entityType?: true
    entityId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    authorId: string
    entityType: string
    entityId: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    entityType?: boolean
    entityId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    entityType?: boolean
    entityId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    authorId?: boolean
    entityType?: boolean
    entityId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authorId: string
      entityType: string
      entityId: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly authorId: FieldRef<"Comment", 'String'>
    readonly entityType: FieldRef<"Comment", 'String'>
    readonly entityId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    changes: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    changes?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    entityType: string
    entityId: string
    changes: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      entityType: string
      entityId: string
      changes: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    createdAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }


  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */ 
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    isActive: 'isActive',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientId: 'clientId',
    managerId: 'managerId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    legalName: 'legalName',
    industry: 'industry',
    industryCode: 'industryCode',
    size: 'size',
    revenueBand: 'revenueBand',
    address: 'address',
    city: 'city',
    country: 'country',
    phone: 'phone',
    website: 'website',
    aiMaturityLevel: 'aiMaturityLevel',
    aiReadinessScore: 'aiReadinessScore',
    technologyStack: 'technologyStack',
    lifecycleStage: 'lifecycleStage',
    healthScore: 'healthScore',
    npsScore: 'npsScore',
    accountExecutiveId: 'accountExecutiveId',
    contractStartDate: 'contractStartDate',
    contractEndDate: 'contractEndDate',
    autoRenewal: 'autoRenewal',
    renewalNoticeDays: 'renewalNoticeDays',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ClientSolutionScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    solutionId: 'solutionId',
    deployedAt: 'deployedAt',
    status: 'status'
  };

  export type ClientSolutionScalarFieldEnum = (typeof ClientSolutionScalarFieldEnum)[keyof typeof ClientSolutionScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    jobTitle: 'jobTitle',
    isDecisionMaker: 'isDecisionMaker',
    isInfluencer: 'isInfluencer',
    isTechnicalLead: 'isTechnicalLead',
    isEndUser: 'isEndUser',
    isBudgetHolder: 'isBudgetHolder',
    influenceLevel: 'influenceLevel',
    relationshipScore: 'relationshipScore',
    lastInteraction: 'lastInteraction',
    preferredChannel: 'preferredChannel',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    ownerId: 'ownerId',
    source: 'source',
    sourceDetails: 'sourceDetails',
    status: 'status',
    companyName: 'companyName',
    contactName: 'contactName',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    industry: 'industry',
    companySize: 'companySize',
    leadScore: 'leadScore',
    scoreTier: 'scoreTier',
    scoreReason: 'scoreReason',
    budgetRange: 'budgetRange',
    timeline: 'timeline',
    needDescription: 'needDescription',
    convertedAt: 'convertedAt',
    lostAt: 'lostAt',
    lossReason: 'lossReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const OpportunityScalarFieldEnum: {
    id: 'id',
    leadId: 'leadId',
    clientId: 'clientId',
    ownerId: 'ownerId',
    name: 'name',
    stage: 'stage',
    probability: 'probability',
    expectedCloseDate: 'expectedCloseDate',
    actualCloseDate: 'actualCloseDate',
    estimatedValue: 'estimatedValue',
    weightedValue: 'weightedValue',
    nextStep: 'nextStep',
    nextStepDate: 'nextStepDate',
    lostReason: 'lostReason',
    wonReason: 'wonReason',
    solutionType: 'solutionType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OpportunityScalarFieldEnum = (typeof OpportunityScalarFieldEnum)[keyof typeof OpportunityScalarFieldEnum]


  export const ProposalScalarFieldEnum: {
    id: 'id',
    opportunityId: 'opportunityId',
    version: 'version',
    title: 'title',
    content: 'content',
    solutionDescription: 'solutionDescription',
    implementationPlan: 'implementationPlan',
    timelineWeeks: 'timelineWeeks',
    basePrice: 'basePrice',
    discount: 'discount',
    finalPrice: 'finalPrice',
    terms: 'terms',
    status: 'status',
    approvalStatus: 'approvalStatus',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    signedAt: 'signedAt',
    documentUrl: 'documentUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProposalScalarFieldEnum = (typeof ProposalScalarFieldEnum)[keyof typeof ProposalScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    opportunityId: 'opportunityId',
    clientId: 'clientId',
    name: 'name',
    description: 'description',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    actualEndDate: 'actualEndDate',
    budget: 'budget',
    actualCost: 'actualCost',
    projectManagerId: 'projectManagerId',
    solutionType: 'solutionType',
    healthStatus: 'healthStatus',
    completionPercentage: 'completionPercentage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectMilestoneScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    description: 'description',
    status: 'status',
    phase: 'phase',
    order: 'order',
    plannedStartDate: 'plannedStartDate',
    plannedEndDate: 'plannedEndDate',
    actualStartDate: 'actualStartDate',
    actualEndDate: 'actualEndDate',
    completionCriteria: 'completionCriteria',
    ownerId: 'ownerId',
    dependsOnId: 'dependsOnId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectMilestoneScalarFieldEnum = (typeof ProjectMilestoneScalarFieldEnum)[keyof typeof ProjectMilestoneScalarFieldEnum]


  export const ProjectTaskScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    phase: 'phase',
    assigneeId: 'assigneeId',
    parentTaskId: 'parentTaskId',
    plannedHours: 'plannedHours',
    actualHours: 'actualHours',
    dueDate: 'dueDate',
    completedAt: 'completedAt',
    blockerReason: 'blockerReason',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectTaskScalarFieldEnum = (typeof ProjectTaskScalarFieldEnum)[keyof typeof ProjectTaskScalarFieldEnum]


  export const ProjectMetricScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    metricName: 'metricName',
    metricCategory: 'metricCategory',
    value: 'value',
    unit: 'unit',
    baselineValue: 'baselineValue',
    targetValue: 'targetValue',
    recordedAt: 'recordedAt'
  };

  export type ProjectMetricScalarFieldEnum = (typeof ProjectMetricScalarFieldEnum)[keyof typeof ProjectMetricScalarFieldEnum]


  export const AISolutionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    description: 'description',
    tagline: 'tagline',
    longDescription: 'longDescription',
    targetIndustries: 'targetIndustries',
    targetFunctions: 'targetFunctions',
    technicalRequirements: 'technicalRequirements',
    integrationPoints: 'integrationPoints',
    pricingModels: 'pricingModels',
    typicalTimelineWeeks: 'typicalTimelineWeeks',
    useCases: 'useCases',
    caseStudies: 'caseStudies',
    isActive: 'isActive',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AISolutionScalarFieldEnum = (typeof AISolutionScalarFieldEnum)[keyof typeof AISolutionScalarFieldEnum]


  export const AISolutionModuleScalarFieldEnum: {
    id: 'id',
    solutionId: 'solutionId',
    name: 'name',
    description: 'description',
    basePrice: 'basePrice',
    isOptional: 'isOptional'
  };

  export type AISolutionModuleScalarFieldEnum = (typeof AISolutionModuleScalarFieldEnum)[keyof typeof AISolutionModuleScalarFieldEnum]


  export const QuoteScalarFieldEnum: {
    id: 'id',
    solutionId: 'solutionId',
    clientId: 'clientId',
    quoteNumber: 'quoteNumber',
    version: 'version',
    status: 'status',
    scope: 'scope',
    timelineWeeks: 'timelineWeeks',
    totalPrice: 'totalPrice',
    validUntil: 'validUntil',
    requestedBy: 'requestedBy',
    requestedAt: 'requestedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuoteScalarFieldEnum = (typeof QuoteScalarFieldEnum)[keyof typeof QuoteScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    leadId: 'leadId',
    opportunityId: 'opportunityId',
    contactId: 'contactId',
    type: 'type',
    subject: 'subject',
    description: 'description',
    scheduledAt: 'scheduledAt',
    completedAt: 'completedAt',
    durationMinutes: 'durationMinutes',
    outcome: 'outcome',
    sentiment: 'sentiment',
    keyTopics: 'keyTopics',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    projectId: 'projectId',
    milestoneId: 'milestoneId',
    type: 'type',
    rating: 'rating',
    comments: 'comments',
    deliveredOnTime: 'deliveredOnTime',
    metExpectations: 'metExpectations',
    wouldRecommend: 'wouldRecommend',
    responderName: 'responderName',
    responderEmail: 'responderEmail',
    createdAt: 'createdAt'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    assigneeId: 'assigneeId',
    ticketNumber: 'ticketNumber',
    title: 'title',
    description: 'description',
    type: 'type',
    severity: 'severity',
    status: 'status',
    resolution: 'resolution',
    rootCause: 'rootCause',
    slaResponseDue: 'slaResponseDue',
    slaResolutionDue: 'slaResolutionDue',
    respondedAt: 'respondedAt',
    resolvedAt: 'resolvedAt',
    closedAt: 'closedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const TicketCommentScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    authorId: 'authorId',
    content: 'content',
    isInternal: 'isInternal',
    createdAt: 'createdAt'
  };

  export type TicketCommentScalarFieldEnum = (typeof TicketCommentScalarFieldEnum)[keyof typeof TicketCommentScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    entityType: 'entityType',
    entityId: 'entityId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    changes: 'changes',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ClientLifecycleStage'
   */
  export type EnumClientLifecycleStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientLifecycleStage'>
    


  /**
   * Reference to a field of type 'ClientLifecycleStage[]'
   */
  export type ListEnumClientLifecycleStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientLifecycleStage[]'>
    


  /**
   * Reference to a field of type 'LeadStatus'
   */
  export type EnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus'>
    


  /**
   * Reference to a field of type 'LeadStatus[]'
   */
  export type ListEnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus[]'>
    


  /**
   * Reference to a field of type 'OpportunityStage'
   */
  export type EnumOpportunityStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OpportunityStage'>
    


  /**
   * Reference to a field of type 'OpportunityStage[]'
   */
  export type ListEnumOpportunityStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OpportunityStage[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'MilestoneStatus'
   */
  export type EnumMilestoneStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MilestoneStatus'>
    


  /**
   * Reference to a field of type 'MilestoneStatus[]'
   */
  export type ListEnumMilestoneStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MilestoneStatus[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'TicketType'
   */
  export type EnumTicketTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketType'>
    


  /**
   * Reference to a field of type 'TicketType[]'
   */
  export type ListEnumTicketTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketType[]'>
    


  /**
   * Reference to a field of type 'TicketSeverity'
   */
  export type EnumTicketSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketSeverity'>
    


  /**
   * Reference to a field of type 'TicketSeverity[]'
   */
  export type ListEnumTicketSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketSeverity[]'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    


  /**
   * Reference to a field of type 'TicketStatus[]'
   */
  export type ListEnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    clientId?: StringNullableFilter<"User"> | string | null
    managerId?: StringNullableFilter<"User"> | string | null
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    managedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    subordinates?: UserListRelationFilter
    leads?: LeadListRelationFilter
    opportunities?: OpportunityListRelationFilter
    activities?: ActivityListRelationFilter
    projectTasks?: ProjectTaskListRelationFilter
    projectMilestones?: ProjectMilestoneListRelationFilter
    tickets?: TicketListRelationFilter
    comments?: CommentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
    managedBy?: UserOrderByWithRelationInput
    subordinates?: UserOrderByRelationAggregateInput
    leads?: LeadOrderByRelationAggregateInput
    opportunities?: OpportunityOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    projectTasks?: ProjectTaskOrderByRelationAggregateInput
    projectMilestones?: ProjectMilestoneOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    clientId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    managerId?: StringNullableFilter<"User"> | string | null
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    managedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    subordinates?: UserListRelationFilter
    leads?: LeadListRelationFilter
    opportunities?: OpportunityListRelationFilter
    activities?: ActivityListRelationFilter
    projectTasks?: ProjectTaskListRelationFilter
    projectMilestones?: ProjectMilestoneListRelationFilter
    tickets?: TicketListRelationFilter
    comments?: CommentListRelationFilter
  }, "id" | "email" | "clientId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    clientId?: StringNullableWithAggregatesFilter<"User"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    legalName?: StringNullableFilter<"Client"> | string | null
    industry?: StringNullableFilter<"Client"> | string | null
    industryCode?: StringNullableFilter<"Client"> | string | null
    size?: StringNullableFilter<"Client"> | string | null
    revenueBand?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    city?: StringNullableFilter<"Client"> | string | null
    country?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    website?: StringNullableFilter<"Client"> | string | null
    aiMaturityLevel?: StringNullableFilter<"Client"> | string | null
    aiReadinessScore?: IntNullableFilter<"Client"> | number | null
    technologyStack?: StringNullableListFilter<"Client">
    lifecycleStage?: EnumClientLifecycleStageFilter<"Client"> | $Enums.ClientLifecycleStage
    healthScore?: IntFilter<"Client"> | number
    npsScore?: IntNullableFilter<"Client"> | number | null
    accountExecutiveId?: StringNullableFilter<"Client"> | string | null
    contractStartDate?: DateTimeNullableFilter<"Client"> | Date | string | null
    contractEndDate?: DateTimeNullableFilter<"Client"> | Date | string | null
    autoRenewal?: BoolFilter<"Client"> | boolean
    renewalNoticeDays?: IntFilter<"Client"> | number
    isActive?: BoolFilter<"Client"> | boolean
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    contacts?: ContactListRelationFilter
    leads?: LeadListRelationFilter
    opportunities?: OpportunityListRelationFilter
    projects?: ProjectListRelationFilter
    tickets?: TicketListRelationFilter
    feedback?: FeedbackListRelationFilter
    aiSolutions?: ClientSolutionListRelationFilter
    users?: UserListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    industryCode?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    revenueBand?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    aiMaturityLevel?: SortOrderInput | SortOrder
    aiReadinessScore?: SortOrderInput | SortOrder
    technologyStack?: SortOrder
    lifecycleStage?: SortOrder
    healthScore?: SortOrder
    npsScore?: SortOrderInput | SortOrder
    accountExecutiveId?: SortOrderInput | SortOrder
    contractStartDate?: SortOrderInput | SortOrder
    contractEndDate?: SortOrderInput | SortOrder
    autoRenewal?: SortOrder
    renewalNoticeDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contacts?: ContactOrderByRelationAggregateInput
    leads?: LeadOrderByRelationAggregateInput
    opportunities?: OpportunityOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
    feedback?: FeedbackOrderByRelationAggregateInput
    aiSolutions?: ClientSolutionOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    name?: StringFilter<"Client"> | string
    legalName?: StringNullableFilter<"Client"> | string | null
    industry?: StringNullableFilter<"Client"> | string | null
    industryCode?: StringNullableFilter<"Client"> | string | null
    size?: StringNullableFilter<"Client"> | string | null
    revenueBand?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    city?: StringNullableFilter<"Client"> | string | null
    country?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    website?: StringNullableFilter<"Client"> | string | null
    aiMaturityLevel?: StringNullableFilter<"Client"> | string | null
    aiReadinessScore?: IntNullableFilter<"Client"> | number | null
    technologyStack?: StringNullableListFilter<"Client">
    lifecycleStage?: EnumClientLifecycleStageFilter<"Client"> | $Enums.ClientLifecycleStage
    healthScore?: IntFilter<"Client"> | number
    npsScore?: IntNullableFilter<"Client"> | number | null
    accountExecutiveId?: StringNullableFilter<"Client"> | string | null
    contractStartDate?: DateTimeNullableFilter<"Client"> | Date | string | null
    contractEndDate?: DateTimeNullableFilter<"Client"> | Date | string | null
    autoRenewal?: BoolFilter<"Client"> | boolean
    renewalNoticeDays?: IntFilter<"Client"> | number
    isActive?: BoolFilter<"Client"> | boolean
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    contacts?: ContactListRelationFilter
    leads?: LeadListRelationFilter
    opportunities?: OpportunityListRelationFilter
    projects?: ProjectListRelationFilter
    tickets?: TicketListRelationFilter
    feedback?: FeedbackListRelationFilter
    aiSolutions?: ClientSolutionListRelationFilter
    users?: UserListRelationFilter
  }, "id">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    industryCode?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    revenueBand?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    aiMaturityLevel?: SortOrderInput | SortOrder
    aiReadinessScore?: SortOrderInput | SortOrder
    technologyStack?: SortOrder
    lifecycleStage?: SortOrder
    healthScore?: SortOrder
    npsScore?: SortOrderInput | SortOrder
    accountExecutiveId?: SortOrderInput | SortOrder
    contractStartDate?: SortOrderInput | SortOrder
    contractEndDate?: SortOrderInput | SortOrder
    autoRenewal?: SortOrder
    renewalNoticeDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    name?: StringWithAggregatesFilter<"Client"> | string
    legalName?: StringNullableWithAggregatesFilter<"Client"> | string | null
    industry?: StringNullableWithAggregatesFilter<"Client"> | string | null
    industryCode?: StringNullableWithAggregatesFilter<"Client"> | string | null
    size?: StringNullableWithAggregatesFilter<"Client"> | string | null
    revenueBand?: StringNullableWithAggregatesFilter<"Client"> | string | null
    address?: StringNullableWithAggregatesFilter<"Client"> | string | null
    city?: StringNullableWithAggregatesFilter<"Client"> | string | null
    country?: StringNullableWithAggregatesFilter<"Client"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Client"> | string | null
    website?: StringNullableWithAggregatesFilter<"Client"> | string | null
    aiMaturityLevel?: StringNullableWithAggregatesFilter<"Client"> | string | null
    aiReadinessScore?: IntNullableWithAggregatesFilter<"Client"> | number | null
    technologyStack?: StringNullableListFilter<"Client">
    lifecycleStage?: EnumClientLifecycleStageWithAggregatesFilter<"Client"> | $Enums.ClientLifecycleStage
    healthScore?: IntWithAggregatesFilter<"Client"> | number
    npsScore?: IntNullableWithAggregatesFilter<"Client"> | number | null
    accountExecutiveId?: StringNullableWithAggregatesFilter<"Client"> | string | null
    contractStartDate?: DateTimeNullableWithAggregatesFilter<"Client"> | Date | string | null
    contractEndDate?: DateTimeNullableWithAggregatesFilter<"Client"> | Date | string | null
    autoRenewal?: BoolWithAggregatesFilter<"Client"> | boolean
    renewalNoticeDays?: IntWithAggregatesFilter<"Client"> | number
    isActive?: BoolWithAggregatesFilter<"Client"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type ClientSolutionWhereInput = {
    AND?: ClientSolutionWhereInput | ClientSolutionWhereInput[]
    OR?: ClientSolutionWhereInput[]
    NOT?: ClientSolutionWhereInput | ClientSolutionWhereInput[]
    id?: StringFilter<"ClientSolution"> | string
    clientId?: StringFilter<"ClientSolution"> | string
    solutionId?: StringFilter<"ClientSolution"> | string
    deployedAt?: DateTimeNullableFilter<"ClientSolution"> | Date | string | null
    status?: StringFilter<"ClientSolution"> | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    solution?: XOR<AISolutionRelationFilter, AISolutionWhereInput>
  }

  export type ClientSolutionOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    solutionId?: SortOrder
    deployedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    client?: ClientOrderByWithRelationInput
    solution?: AISolutionOrderByWithRelationInput
  }

  export type ClientSolutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_solutionId?: ClientSolutionClientIdSolutionIdCompoundUniqueInput
    AND?: ClientSolutionWhereInput | ClientSolutionWhereInput[]
    OR?: ClientSolutionWhereInput[]
    NOT?: ClientSolutionWhereInput | ClientSolutionWhereInput[]
    clientId?: StringFilter<"ClientSolution"> | string
    solutionId?: StringFilter<"ClientSolution"> | string
    deployedAt?: DateTimeNullableFilter<"ClientSolution"> | Date | string | null
    status?: StringFilter<"ClientSolution"> | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    solution?: XOR<AISolutionRelationFilter, AISolutionWhereInput>
  }, "id" | "clientId_solutionId">

  export type ClientSolutionOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    solutionId?: SortOrder
    deployedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: ClientSolutionCountOrderByAggregateInput
    _max?: ClientSolutionMaxOrderByAggregateInput
    _min?: ClientSolutionMinOrderByAggregateInput
  }

  export type ClientSolutionScalarWhereWithAggregatesInput = {
    AND?: ClientSolutionScalarWhereWithAggregatesInput | ClientSolutionScalarWhereWithAggregatesInput[]
    OR?: ClientSolutionScalarWhereWithAggregatesInput[]
    NOT?: ClientSolutionScalarWhereWithAggregatesInput | ClientSolutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientSolution"> | string
    clientId?: StringWithAggregatesFilter<"ClientSolution"> | string
    solutionId?: StringWithAggregatesFilter<"ClientSolution"> | string
    deployedAt?: DateTimeNullableWithAggregatesFilter<"ClientSolution"> | Date | string | null
    status?: StringWithAggregatesFilter<"ClientSolution"> | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    clientId?: StringFilter<"Contact"> | string
    firstName?: StringFilter<"Contact"> | string
    lastName?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    phone?: StringNullableFilter<"Contact"> | string | null
    jobTitle?: StringNullableFilter<"Contact"> | string | null
    isDecisionMaker?: BoolFilter<"Contact"> | boolean
    isInfluencer?: BoolFilter<"Contact"> | boolean
    isTechnicalLead?: BoolFilter<"Contact"> | boolean
    isEndUser?: BoolFilter<"Contact"> | boolean
    isBudgetHolder?: BoolFilter<"Contact"> | boolean
    influenceLevel?: IntFilter<"Contact"> | number
    relationshipScore?: IntFilter<"Contact"> | number
    lastInteraction?: DateTimeNullableFilter<"Contact"> | Date | string | null
    preferredChannel?: StringNullableFilter<"Contact"> | string | null
    isActive?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    activities?: ActivityListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    jobTitle?: SortOrderInput | SortOrder
    isDecisionMaker?: SortOrder
    isInfluencer?: SortOrder
    isTechnicalLead?: SortOrder
    isEndUser?: SortOrder
    isBudgetHolder?: SortOrder
    influenceLevel?: SortOrder
    relationshipScore?: SortOrder
    lastInteraction?: SortOrderInput | SortOrder
    preferredChannel?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    activities?: ActivityOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    clientId?: StringFilter<"Contact"> | string
    firstName?: StringFilter<"Contact"> | string
    lastName?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    phone?: StringNullableFilter<"Contact"> | string | null
    jobTitle?: StringNullableFilter<"Contact"> | string | null
    isDecisionMaker?: BoolFilter<"Contact"> | boolean
    isInfluencer?: BoolFilter<"Contact"> | boolean
    isTechnicalLead?: BoolFilter<"Contact"> | boolean
    isEndUser?: BoolFilter<"Contact"> | boolean
    isBudgetHolder?: BoolFilter<"Contact"> | boolean
    influenceLevel?: IntFilter<"Contact"> | number
    relationshipScore?: IntFilter<"Contact"> | number
    lastInteraction?: DateTimeNullableFilter<"Contact"> | Date | string | null
    preferredChannel?: StringNullableFilter<"Contact"> | string | null
    isActive?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    activities?: ActivityListRelationFilter
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    jobTitle?: SortOrderInput | SortOrder
    isDecisionMaker?: SortOrder
    isInfluencer?: SortOrder
    isTechnicalLead?: SortOrder
    isEndUser?: SortOrder
    isBudgetHolder?: SortOrder
    influenceLevel?: SortOrder
    relationshipScore?: SortOrder
    lastInteraction?: SortOrderInput | SortOrder
    preferredChannel?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _avg?: ContactAvgOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
    _sum?: ContactSumOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    clientId?: StringWithAggregatesFilter<"Contact"> | string
    firstName?: StringWithAggregatesFilter<"Contact"> | string
    lastName?: StringWithAggregatesFilter<"Contact"> | string
    email?: StringWithAggregatesFilter<"Contact"> | string
    phone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    jobTitle?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    isDecisionMaker?: BoolWithAggregatesFilter<"Contact"> | boolean
    isInfluencer?: BoolWithAggregatesFilter<"Contact"> | boolean
    isTechnicalLead?: BoolWithAggregatesFilter<"Contact"> | boolean
    isEndUser?: BoolWithAggregatesFilter<"Contact"> | boolean
    isBudgetHolder?: BoolWithAggregatesFilter<"Contact"> | boolean
    influenceLevel?: IntWithAggregatesFilter<"Contact"> | number
    relationshipScore?: IntWithAggregatesFilter<"Contact"> | number
    lastInteraction?: DateTimeNullableWithAggregatesFilter<"Contact"> | Date | string | null
    preferredChannel?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    isActive?: BoolWithAggregatesFilter<"Contact"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    clientId?: StringNullableFilter<"Lead"> | string | null
    ownerId?: StringFilter<"Lead"> | string
    source?: StringFilter<"Lead"> | string
    sourceDetails?: StringNullableFilter<"Lead"> | string | null
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    companyName?: StringFilter<"Lead"> | string
    contactName?: StringFilter<"Lead"> | string
    contactEmail?: StringFilter<"Lead"> | string
    contactPhone?: StringNullableFilter<"Lead"> | string | null
    industry?: StringNullableFilter<"Lead"> | string | null
    companySize?: StringNullableFilter<"Lead"> | string | null
    leadScore?: IntFilter<"Lead"> | number
    scoreTier?: StringFilter<"Lead"> | string
    scoreReason?: StringNullableFilter<"Lead"> | string | null
    budgetRange?: StringNullableFilter<"Lead"> | string | null
    timeline?: StringNullableFilter<"Lead"> | string | null
    needDescription?: StringNullableFilter<"Lead"> | string | null
    convertedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    lostAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    lossReason?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    owner?: XOR<UserRelationFilter, UserWhereInput>
    activities?: ActivityListRelationFilter
    opportunities?: OpportunityListRelationFilter
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    source?: SortOrder
    sourceDetails?: SortOrderInput | SortOrder
    status?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    companySize?: SortOrderInput | SortOrder
    leadScore?: SortOrder
    scoreTier?: SortOrder
    scoreReason?: SortOrderInput | SortOrder
    budgetRange?: SortOrderInput | SortOrder
    timeline?: SortOrderInput | SortOrder
    needDescription?: SortOrderInput | SortOrder
    convertedAt?: SortOrderInput | SortOrder
    lostAt?: SortOrderInput | SortOrder
    lossReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    activities?: ActivityOrderByRelationAggregateInput
    opportunities?: OpportunityOrderByRelationAggregateInput
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    clientId?: StringNullableFilter<"Lead"> | string | null
    ownerId?: StringFilter<"Lead"> | string
    source?: StringFilter<"Lead"> | string
    sourceDetails?: StringNullableFilter<"Lead"> | string | null
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    companyName?: StringFilter<"Lead"> | string
    contactName?: StringFilter<"Lead"> | string
    contactEmail?: StringFilter<"Lead"> | string
    contactPhone?: StringNullableFilter<"Lead"> | string | null
    industry?: StringNullableFilter<"Lead"> | string | null
    companySize?: StringNullableFilter<"Lead"> | string | null
    leadScore?: IntFilter<"Lead"> | number
    scoreTier?: StringFilter<"Lead"> | string
    scoreReason?: StringNullableFilter<"Lead"> | string | null
    budgetRange?: StringNullableFilter<"Lead"> | string | null
    timeline?: StringNullableFilter<"Lead"> | string | null
    needDescription?: StringNullableFilter<"Lead"> | string | null
    convertedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    lostAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    lossReason?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    owner?: XOR<UserRelationFilter, UserWhereInput>
    activities?: ActivityListRelationFilter
    opportunities?: OpportunityListRelationFilter
  }, "id">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    source?: SortOrder
    sourceDetails?: SortOrderInput | SortOrder
    status?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    companySize?: SortOrderInput | SortOrder
    leadScore?: SortOrder
    scoreTier?: SortOrder
    scoreReason?: SortOrderInput | SortOrder
    budgetRange?: SortOrderInput | SortOrder
    timeline?: SortOrderInput | SortOrder
    needDescription?: SortOrderInput | SortOrder
    convertedAt?: SortOrderInput | SortOrder
    lostAt?: SortOrderInput | SortOrder
    lossReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeadCountOrderByAggregateInput
    _avg?: LeadAvgOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
    _sum?: LeadSumOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    clientId?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    ownerId?: StringWithAggregatesFilter<"Lead"> | string
    source?: StringWithAggregatesFilter<"Lead"> | string
    sourceDetails?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    status?: EnumLeadStatusWithAggregatesFilter<"Lead"> | $Enums.LeadStatus
    companyName?: StringWithAggregatesFilter<"Lead"> | string
    contactName?: StringWithAggregatesFilter<"Lead"> | string
    contactEmail?: StringWithAggregatesFilter<"Lead"> | string
    contactPhone?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    industry?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    companySize?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    leadScore?: IntWithAggregatesFilter<"Lead"> | number
    scoreTier?: StringWithAggregatesFilter<"Lead"> | string
    scoreReason?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    budgetRange?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    timeline?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    needDescription?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    convertedAt?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    lostAt?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    lossReason?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
  }

  export type OpportunityWhereInput = {
    AND?: OpportunityWhereInput | OpportunityWhereInput[]
    OR?: OpportunityWhereInput[]
    NOT?: OpportunityWhereInput | OpportunityWhereInput[]
    id?: StringFilter<"Opportunity"> | string
    leadId?: StringNullableFilter<"Opportunity"> | string | null
    clientId?: StringNullableFilter<"Opportunity"> | string | null
    ownerId?: StringFilter<"Opportunity"> | string
    name?: StringFilter<"Opportunity"> | string
    stage?: EnumOpportunityStageFilter<"Opportunity"> | $Enums.OpportunityStage
    probability?: IntFilter<"Opportunity"> | number
    expectedCloseDate?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    actualCloseDate?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    estimatedValue?: FloatFilter<"Opportunity"> | number
    weightedValue?: FloatFilter<"Opportunity"> | number
    nextStep?: StringNullableFilter<"Opportunity"> | string | null
    nextStepDate?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    lostReason?: StringNullableFilter<"Opportunity"> | string | null
    wonReason?: StringNullableFilter<"Opportunity"> | string | null
    solutionType?: StringNullableFilter<"Opportunity"> | string | null
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeFilter<"Opportunity"> | Date | string
    lead?: XOR<LeadNullableRelationFilter, LeadWhereInput> | null
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    owner?: XOR<UserRelationFilter, UserWhereInput>
    activities?: ActivityListRelationFilter
    proposals?: ProposalListRelationFilter
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }

  export type OpportunityOrderByWithRelationInput = {
    id?: SortOrder
    leadId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    stage?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrderInput | SortOrder
    actualCloseDate?: SortOrderInput | SortOrder
    estimatedValue?: SortOrder
    weightedValue?: SortOrder
    nextStep?: SortOrderInput | SortOrder
    nextStepDate?: SortOrderInput | SortOrder
    lostReason?: SortOrderInput | SortOrder
    wonReason?: SortOrderInput | SortOrder
    solutionType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lead?: LeadOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    activities?: ActivityOrderByRelationAggregateInput
    proposals?: ProposalOrderByRelationAggregateInput
    project?: ProjectOrderByWithRelationInput
  }

  export type OpportunityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OpportunityWhereInput | OpportunityWhereInput[]
    OR?: OpportunityWhereInput[]
    NOT?: OpportunityWhereInput | OpportunityWhereInput[]
    leadId?: StringNullableFilter<"Opportunity"> | string | null
    clientId?: StringNullableFilter<"Opportunity"> | string | null
    ownerId?: StringFilter<"Opportunity"> | string
    name?: StringFilter<"Opportunity"> | string
    stage?: EnumOpportunityStageFilter<"Opportunity"> | $Enums.OpportunityStage
    probability?: IntFilter<"Opportunity"> | number
    expectedCloseDate?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    actualCloseDate?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    estimatedValue?: FloatFilter<"Opportunity"> | number
    weightedValue?: FloatFilter<"Opportunity"> | number
    nextStep?: StringNullableFilter<"Opportunity"> | string | null
    nextStepDate?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    lostReason?: StringNullableFilter<"Opportunity"> | string | null
    wonReason?: StringNullableFilter<"Opportunity"> | string | null
    solutionType?: StringNullableFilter<"Opportunity"> | string | null
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeFilter<"Opportunity"> | Date | string
    lead?: XOR<LeadNullableRelationFilter, LeadWhereInput> | null
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    owner?: XOR<UserRelationFilter, UserWhereInput>
    activities?: ActivityListRelationFilter
    proposals?: ProposalListRelationFilter
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }, "id">

  export type OpportunityOrderByWithAggregationInput = {
    id?: SortOrder
    leadId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    stage?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrderInput | SortOrder
    actualCloseDate?: SortOrderInput | SortOrder
    estimatedValue?: SortOrder
    weightedValue?: SortOrder
    nextStep?: SortOrderInput | SortOrder
    nextStepDate?: SortOrderInput | SortOrder
    lostReason?: SortOrderInput | SortOrder
    wonReason?: SortOrderInput | SortOrder
    solutionType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OpportunityCountOrderByAggregateInput
    _avg?: OpportunityAvgOrderByAggregateInput
    _max?: OpportunityMaxOrderByAggregateInput
    _min?: OpportunityMinOrderByAggregateInput
    _sum?: OpportunitySumOrderByAggregateInput
  }

  export type OpportunityScalarWhereWithAggregatesInput = {
    AND?: OpportunityScalarWhereWithAggregatesInput | OpportunityScalarWhereWithAggregatesInput[]
    OR?: OpportunityScalarWhereWithAggregatesInput[]
    NOT?: OpportunityScalarWhereWithAggregatesInput | OpportunityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Opportunity"> | string
    leadId?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    ownerId?: StringWithAggregatesFilter<"Opportunity"> | string
    name?: StringWithAggregatesFilter<"Opportunity"> | string
    stage?: EnumOpportunityStageWithAggregatesFilter<"Opportunity"> | $Enums.OpportunityStage
    probability?: IntWithAggregatesFilter<"Opportunity"> | number
    expectedCloseDate?: DateTimeNullableWithAggregatesFilter<"Opportunity"> | Date | string | null
    actualCloseDate?: DateTimeNullableWithAggregatesFilter<"Opportunity"> | Date | string | null
    estimatedValue?: FloatWithAggregatesFilter<"Opportunity"> | number
    weightedValue?: FloatWithAggregatesFilter<"Opportunity"> | number
    nextStep?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    nextStepDate?: DateTimeNullableWithAggregatesFilter<"Opportunity"> | Date | string | null
    lostReason?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    wonReason?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    solutionType?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Opportunity"> | Date | string
  }

  export type ProposalWhereInput = {
    AND?: ProposalWhereInput | ProposalWhereInput[]
    OR?: ProposalWhereInput[]
    NOT?: ProposalWhereInput | ProposalWhereInput[]
    id?: StringFilter<"Proposal"> | string
    opportunityId?: StringFilter<"Proposal"> | string
    version?: IntFilter<"Proposal"> | number
    title?: StringFilter<"Proposal"> | string
    content?: JsonNullableFilter<"Proposal">
    solutionDescription?: StringNullableFilter<"Proposal"> | string | null
    implementationPlan?: StringNullableFilter<"Proposal"> | string | null
    timelineWeeks?: IntNullableFilter<"Proposal"> | number | null
    basePrice?: FloatFilter<"Proposal"> | number
    discount?: FloatFilter<"Proposal"> | number
    finalPrice?: FloatFilter<"Proposal"> | number
    terms?: StringNullableFilter<"Proposal"> | string | null
    status?: StringFilter<"Proposal"> | string
    approvalStatus?: StringFilter<"Proposal"> | string
    approvedBy?: StringNullableFilter<"Proposal"> | string | null
    approvedAt?: DateTimeNullableFilter<"Proposal"> | Date | string | null
    signedAt?: DateTimeNullableFilter<"Proposal"> | Date | string | null
    documentUrl?: StringNullableFilter<"Proposal"> | string | null
    createdAt?: DateTimeFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeFilter<"Proposal"> | Date | string
    opportunity?: XOR<OpportunityRelationFilter, OpportunityWhereInput>
  }

  export type ProposalOrderByWithRelationInput = {
    id?: SortOrder
    opportunityId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    solutionDescription?: SortOrderInput | SortOrder
    implementationPlan?: SortOrderInput | SortOrder
    timelineWeeks?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    discount?: SortOrder
    finalPrice?: SortOrder
    terms?: SortOrderInput | SortOrder
    status?: SortOrder
    approvalStatus?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    signedAt?: SortOrderInput | SortOrder
    documentUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    opportunity?: OpportunityOrderByWithRelationInput
  }

  export type ProposalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProposalWhereInput | ProposalWhereInput[]
    OR?: ProposalWhereInput[]
    NOT?: ProposalWhereInput | ProposalWhereInput[]
    opportunityId?: StringFilter<"Proposal"> | string
    version?: IntFilter<"Proposal"> | number
    title?: StringFilter<"Proposal"> | string
    content?: JsonNullableFilter<"Proposal">
    solutionDescription?: StringNullableFilter<"Proposal"> | string | null
    implementationPlan?: StringNullableFilter<"Proposal"> | string | null
    timelineWeeks?: IntNullableFilter<"Proposal"> | number | null
    basePrice?: FloatFilter<"Proposal"> | number
    discount?: FloatFilter<"Proposal"> | number
    finalPrice?: FloatFilter<"Proposal"> | number
    terms?: StringNullableFilter<"Proposal"> | string | null
    status?: StringFilter<"Proposal"> | string
    approvalStatus?: StringFilter<"Proposal"> | string
    approvedBy?: StringNullableFilter<"Proposal"> | string | null
    approvedAt?: DateTimeNullableFilter<"Proposal"> | Date | string | null
    signedAt?: DateTimeNullableFilter<"Proposal"> | Date | string | null
    documentUrl?: StringNullableFilter<"Proposal"> | string | null
    createdAt?: DateTimeFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeFilter<"Proposal"> | Date | string
    opportunity?: XOR<OpportunityRelationFilter, OpportunityWhereInput>
  }, "id">

  export type ProposalOrderByWithAggregationInput = {
    id?: SortOrder
    opportunityId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    solutionDescription?: SortOrderInput | SortOrder
    implementationPlan?: SortOrderInput | SortOrder
    timelineWeeks?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    discount?: SortOrder
    finalPrice?: SortOrder
    terms?: SortOrderInput | SortOrder
    status?: SortOrder
    approvalStatus?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    signedAt?: SortOrderInput | SortOrder
    documentUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProposalCountOrderByAggregateInput
    _avg?: ProposalAvgOrderByAggregateInput
    _max?: ProposalMaxOrderByAggregateInput
    _min?: ProposalMinOrderByAggregateInput
    _sum?: ProposalSumOrderByAggregateInput
  }

  export type ProposalScalarWhereWithAggregatesInput = {
    AND?: ProposalScalarWhereWithAggregatesInput | ProposalScalarWhereWithAggregatesInput[]
    OR?: ProposalScalarWhereWithAggregatesInput[]
    NOT?: ProposalScalarWhereWithAggregatesInput | ProposalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Proposal"> | string
    opportunityId?: StringWithAggregatesFilter<"Proposal"> | string
    version?: IntWithAggregatesFilter<"Proposal"> | number
    title?: StringWithAggregatesFilter<"Proposal"> | string
    content?: JsonNullableWithAggregatesFilter<"Proposal">
    solutionDescription?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    implementationPlan?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    timelineWeeks?: IntNullableWithAggregatesFilter<"Proposal"> | number | null
    basePrice?: FloatWithAggregatesFilter<"Proposal"> | number
    discount?: FloatWithAggregatesFilter<"Proposal"> | number
    finalPrice?: FloatWithAggregatesFilter<"Proposal"> | number
    terms?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    status?: StringWithAggregatesFilter<"Proposal"> | string
    approvalStatus?: StringWithAggregatesFilter<"Proposal"> | string
    approvedBy?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Proposal"> | Date | string | null
    signedAt?: DateTimeNullableWithAggregatesFilter<"Proposal"> | Date | string | null
    documentUrl?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Proposal"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    opportunityId?: StringNullableFilter<"Project"> | string | null
    clientId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    actualEndDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    budget?: FloatFilter<"Project"> | number
    actualCost?: FloatFilter<"Project"> | number
    projectManagerId?: StringNullableFilter<"Project"> | string | null
    solutionType?: StringNullableFilter<"Project"> | string | null
    healthStatus?: StringFilter<"Project"> | string
    completionPercentage?: IntFilter<"Project"> | number
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    opportunity?: XOR<OpportunityNullableRelationFilter, OpportunityWhereInput> | null
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    milestones?: ProjectMilestoneListRelationFilter
    tasks?: ProjectTaskListRelationFilter
    metrics?: ProjectMetricListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    opportunityId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    actualEndDate?: SortOrderInput | SortOrder
    budget?: SortOrder
    actualCost?: SortOrder
    projectManagerId?: SortOrderInput | SortOrder
    solutionType?: SortOrderInput | SortOrder
    healthStatus?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    opportunity?: OpportunityOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    milestones?: ProjectMilestoneOrderByRelationAggregateInput
    tasks?: ProjectTaskOrderByRelationAggregateInput
    metrics?: ProjectMetricOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    opportunityId?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    clientId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    actualEndDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    budget?: FloatFilter<"Project"> | number
    actualCost?: FloatFilter<"Project"> | number
    projectManagerId?: StringNullableFilter<"Project"> | string | null
    solutionType?: StringNullableFilter<"Project"> | string | null
    healthStatus?: StringFilter<"Project"> | string
    completionPercentage?: IntFilter<"Project"> | number
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    opportunity?: XOR<OpportunityNullableRelationFilter, OpportunityWhereInput> | null
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    milestones?: ProjectMilestoneListRelationFilter
    tasks?: ProjectTaskListRelationFilter
    metrics?: ProjectMetricListRelationFilter
  }, "id" | "opportunityId">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    opportunityId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    actualEndDate?: SortOrderInput | SortOrder
    budget?: SortOrder
    actualCost?: SortOrder
    projectManagerId?: SortOrderInput | SortOrder
    solutionType?: SortOrderInput | SortOrder
    healthStatus?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    opportunityId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    clientId?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    status?: EnumProjectStatusWithAggregatesFilter<"Project"> | $Enums.ProjectStatus
    startDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    actualEndDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    budget?: FloatWithAggregatesFilter<"Project"> | number
    actualCost?: FloatWithAggregatesFilter<"Project"> | number
    projectManagerId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    solutionType?: StringNullableWithAggregatesFilter<"Project"> | string | null
    healthStatus?: StringWithAggregatesFilter<"Project"> | string
    completionPercentage?: IntWithAggregatesFilter<"Project"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type ProjectMilestoneWhereInput = {
    AND?: ProjectMilestoneWhereInput | ProjectMilestoneWhereInput[]
    OR?: ProjectMilestoneWhereInput[]
    NOT?: ProjectMilestoneWhereInput | ProjectMilestoneWhereInput[]
    id?: StringFilter<"ProjectMilestone"> | string
    projectId?: StringFilter<"ProjectMilestone"> | string
    name?: StringFilter<"ProjectMilestone"> | string
    description?: StringNullableFilter<"ProjectMilestone"> | string | null
    status?: EnumMilestoneStatusFilter<"ProjectMilestone"> | $Enums.MilestoneStatus
    phase?: StringNullableFilter<"ProjectMilestone"> | string | null
    order?: IntFilter<"ProjectMilestone"> | number
    plannedStartDate?: DateTimeNullableFilter<"ProjectMilestone"> | Date | string | null
    plannedEndDate?: DateTimeNullableFilter<"ProjectMilestone"> | Date | string | null
    actualStartDate?: DateTimeNullableFilter<"ProjectMilestone"> | Date | string | null
    actualEndDate?: DateTimeNullableFilter<"ProjectMilestone"> | Date | string | null
    completionCriteria?: StringNullableFilter<"ProjectMilestone"> | string | null
    ownerId?: StringNullableFilter<"ProjectMilestone"> | string | null
    dependsOnId?: StringNullableFilter<"ProjectMilestone"> | string | null
    createdAt?: DateTimeFilter<"ProjectMilestone"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMilestone"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ProjectMilestoneOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    phase?: SortOrderInput | SortOrder
    order?: SortOrder
    plannedStartDate?: SortOrderInput | SortOrder
    plannedEndDate?: SortOrderInput | SortOrder
    actualStartDate?: SortOrderInput | SortOrder
    actualEndDate?: SortOrderInput | SortOrder
    completionCriteria?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    dependsOnId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
  }

  export type ProjectMilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectMilestoneWhereInput | ProjectMilestoneWhereInput[]
    OR?: ProjectMilestoneWhereInput[]
    NOT?: ProjectMilestoneWhereInput | ProjectMilestoneWhereInput[]
    projectId?: StringFilter<"ProjectMilestone"> | string
    name?: StringFilter<"ProjectMilestone"> | string
    description?: StringNullableFilter<"ProjectMilestone"> | string | null
    status?: EnumMilestoneStatusFilter<"ProjectMilestone"> | $Enums.MilestoneStatus
    phase?: StringNullableFilter<"ProjectMilestone"> | string | null
    order?: IntFilter<"ProjectMilestone"> | number
    plannedStartDate?: DateTimeNullableFilter<"ProjectMilestone"> | Date | string | null
    plannedEndDate?: DateTimeNullableFilter<"ProjectMilestone"> | Date | string | null
    actualStartDate?: DateTimeNullableFilter<"ProjectMilestone"> | Date | string | null
    actualEndDate?: DateTimeNullableFilter<"ProjectMilestone"> | Date | string | null
    completionCriteria?: StringNullableFilter<"ProjectMilestone"> | string | null
    ownerId?: StringNullableFilter<"ProjectMilestone"> | string | null
    dependsOnId?: StringNullableFilter<"ProjectMilestone"> | string | null
    createdAt?: DateTimeFilter<"ProjectMilestone"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMilestone"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ProjectMilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    phase?: SortOrderInput | SortOrder
    order?: SortOrder
    plannedStartDate?: SortOrderInput | SortOrder
    plannedEndDate?: SortOrderInput | SortOrder
    actualStartDate?: SortOrderInput | SortOrder
    actualEndDate?: SortOrderInput | SortOrder
    completionCriteria?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    dependsOnId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectMilestoneCountOrderByAggregateInput
    _avg?: ProjectMilestoneAvgOrderByAggregateInput
    _max?: ProjectMilestoneMaxOrderByAggregateInput
    _min?: ProjectMilestoneMinOrderByAggregateInput
    _sum?: ProjectMilestoneSumOrderByAggregateInput
  }

  export type ProjectMilestoneScalarWhereWithAggregatesInput = {
    AND?: ProjectMilestoneScalarWhereWithAggregatesInput | ProjectMilestoneScalarWhereWithAggregatesInput[]
    OR?: ProjectMilestoneScalarWhereWithAggregatesInput[]
    NOT?: ProjectMilestoneScalarWhereWithAggregatesInput | ProjectMilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectMilestone"> | string
    projectId?: StringWithAggregatesFilter<"ProjectMilestone"> | string
    name?: StringWithAggregatesFilter<"ProjectMilestone"> | string
    description?: StringNullableWithAggregatesFilter<"ProjectMilestone"> | string | null
    status?: EnumMilestoneStatusWithAggregatesFilter<"ProjectMilestone"> | $Enums.MilestoneStatus
    phase?: StringNullableWithAggregatesFilter<"ProjectMilestone"> | string | null
    order?: IntWithAggregatesFilter<"ProjectMilestone"> | number
    plannedStartDate?: DateTimeNullableWithAggregatesFilter<"ProjectMilestone"> | Date | string | null
    plannedEndDate?: DateTimeNullableWithAggregatesFilter<"ProjectMilestone"> | Date | string | null
    actualStartDate?: DateTimeNullableWithAggregatesFilter<"ProjectMilestone"> | Date | string | null
    actualEndDate?: DateTimeNullableWithAggregatesFilter<"ProjectMilestone"> | Date | string | null
    completionCriteria?: StringNullableWithAggregatesFilter<"ProjectMilestone"> | string | null
    ownerId?: StringNullableWithAggregatesFilter<"ProjectMilestone"> | string | null
    dependsOnId?: StringNullableWithAggregatesFilter<"ProjectMilestone"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProjectMilestone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectMilestone"> | Date | string
  }

  export type ProjectTaskWhereInput = {
    AND?: ProjectTaskWhereInput | ProjectTaskWhereInput[]
    OR?: ProjectTaskWhereInput[]
    NOT?: ProjectTaskWhereInput | ProjectTaskWhereInput[]
    id?: StringFilter<"ProjectTask"> | string
    projectId?: StringFilter<"ProjectTask"> | string
    title?: StringFilter<"ProjectTask"> | string
    description?: StringNullableFilter<"ProjectTask"> | string | null
    status?: EnumTaskStatusFilter<"ProjectTask"> | $Enums.TaskStatus
    priority?: StringFilter<"ProjectTask"> | string
    phase?: StringNullableFilter<"ProjectTask"> | string | null
    assigneeId?: StringNullableFilter<"ProjectTask"> | string | null
    parentTaskId?: StringNullableFilter<"ProjectTask"> | string | null
    plannedHours?: FloatNullableFilter<"ProjectTask"> | number | null
    actualHours?: FloatFilter<"ProjectTask"> | number
    dueDate?: DateTimeNullableFilter<"ProjectTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ProjectTask"> | Date | string | null
    blockerReason?: StringNullableFilter<"ProjectTask"> | string | null
    order?: IntFilter<"ProjectTask"> | number
    createdAt?: DateTimeFilter<"ProjectTask"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectTask"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    assignee?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ProjectTaskOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    phase?: SortOrderInput | SortOrder
    assigneeId?: SortOrderInput | SortOrder
    parentTaskId?: SortOrderInput | SortOrder
    plannedHours?: SortOrderInput | SortOrder
    actualHours?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    blockerReason?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    assignee?: UserOrderByWithRelationInput
  }

  export type ProjectTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectTaskWhereInput | ProjectTaskWhereInput[]
    OR?: ProjectTaskWhereInput[]
    NOT?: ProjectTaskWhereInput | ProjectTaskWhereInput[]
    projectId?: StringFilter<"ProjectTask"> | string
    title?: StringFilter<"ProjectTask"> | string
    description?: StringNullableFilter<"ProjectTask"> | string | null
    status?: EnumTaskStatusFilter<"ProjectTask"> | $Enums.TaskStatus
    priority?: StringFilter<"ProjectTask"> | string
    phase?: StringNullableFilter<"ProjectTask"> | string | null
    assigneeId?: StringNullableFilter<"ProjectTask"> | string | null
    parentTaskId?: StringNullableFilter<"ProjectTask"> | string | null
    plannedHours?: FloatNullableFilter<"ProjectTask"> | number | null
    actualHours?: FloatFilter<"ProjectTask"> | number
    dueDate?: DateTimeNullableFilter<"ProjectTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ProjectTask"> | Date | string | null
    blockerReason?: StringNullableFilter<"ProjectTask"> | string | null
    order?: IntFilter<"ProjectTask"> | number
    createdAt?: DateTimeFilter<"ProjectTask"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectTask"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    assignee?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ProjectTaskOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    phase?: SortOrderInput | SortOrder
    assigneeId?: SortOrderInput | SortOrder
    parentTaskId?: SortOrderInput | SortOrder
    plannedHours?: SortOrderInput | SortOrder
    actualHours?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    blockerReason?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectTaskCountOrderByAggregateInput
    _avg?: ProjectTaskAvgOrderByAggregateInput
    _max?: ProjectTaskMaxOrderByAggregateInput
    _min?: ProjectTaskMinOrderByAggregateInput
    _sum?: ProjectTaskSumOrderByAggregateInput
  }

  export type ProjectTaskScalarWhereWithAggregatesInput = {
    AND?: ProjectTaskScalarWhereWithAggregatesInput | ProjectTaskScalarWhereWithAggregatesInput[]
    OR?: ProjectTaskScalarWhereWithAggregatesInput[]
    NOT?: ProjectTaskScalarWhereWithAggregatesInput | ProjectTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectTask"> | string
    projectId?: StringWithAggregatesFilter<"ProjectTask"> | string
    title?: StringWithAggregatesFilter<"ProjectTask"> | string
    description?: StringNullableWithAggregatesFilter<"ProjectTask"> | string | null
    status?: EnumTaskStatusWithAggregatesFilter<"ProjectTask"> | $Enums.TaskStatus
    priority?: StringWithAggregatesFilter<"ProjectTask"> | string
    phase?: StringNullableWithAggregatesFilter<"ProjectTask"> | string | null
    assigneeId?: StringNullableWithAggregatesFilter<"ProjectTask"> | string | null
    parentTaskId?: StringNullableWithAggregatesFilter<"ProjectTask"> | string | null
    plannedHours?: FloatNullableWithAggregatesFilter<"ProjectTask"> | number | null
    actualHours?: FloatWithAggregatesFilter<"ProjectTask"> | number
    dueDate?: DateTimeNullableWithAggregatesFilter<"ProjectTask"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ProjectTask"> | Date | string | null
    blockerReason?: StringNullableWithAggregatesFilter<"ProjectTask"> | string | null
    order?: IntWithAggregatesFilter<"ProjectTask"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProjectTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectTask"> | Date | string
  }

  export type ProjectMetricWhereInput = {
    AND?: ProjectMetricWhereInput | ProjectMetricWhereInput[]
    OR?: ProjectMetricWhereInput[]
    NOT?: ProjectMetricWhereInput | ProjectMetricWhereInput[]
    id?: StringFilter<"ProjectMetric"> | string
    projectId?: StringFilter<"ProjectMetric"> | string
    metricName?: StringFilter<"ProjectMetric"> | string
    metricCategory?: StringFilter<"ProjectMetric"> | string
    value?: FloatFilter<"ProjectMetric"> | number
    unit?: StringNullableFilter<"ProjectMetric"> | string | null
    baselineValue?: FloatNullableFilter<"ProjectMetric"> | number | null
    targetValue?: FloatNullableFilter<"ProjectMetric"> | number | null
    recordedAt?: DateTimeFilter<"ProjectMetric"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ProjectMetricOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    metricName?: SortOrder
    metricCategory?: SortOrder
    value?: SortOrder
    unit?: SortOrderInput | SortOrder
    baselineValue?: SortOrderInput | SortOrder
    targetValue?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectMetricWhereInput | ProjectMetricWhereInput[]
    OR?: ProjectMetricWhereInput[]
    NOT?: ProjectMetricWhereInput | ProjectMetricWhereInput[]
    projectId?: StringFilter<"ProjectMetric"> | string
    metricName?: StringFilter<"ProjectMetric"> | string
    metricCategory?: StringFilter<"ProjectMetric"> | string
    value?: FloatFilter<"ProjectMetric"> | number
    unit?: StringNullableFilter<"ProjectMetric"> | string | null
    baselineValue?: FloatNullableFilter<"ProjectMetric"> | number | null
    targetValue?: FloatNullableFilter<"ProjectMetric"> | number | null
    recordedAt?: DateTimeFilter<"ProjectMetric"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type ProjectMetricOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    metricName?: SortOrder
    metricCategory?: SortOrder
    value?: SortOrder
    unit?: SortOrderInput | SortOrder
    baselineValue?: SortOrderInput | SortOrder
    targetValue?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    _count?: ProjectMetricCountOrderByAggregateInput
    _avg?: ProjectMetricAvgOrderByAggregateInput
    _max?: ProjectMetricMaxOrderByAggregateInput
    _min?: ProjectMetricMinOrderByAggregateInput
    _sum?: ProjectMetricSumOrderByAggregateInput
  }

  export type ProjectMetricScalarWhereWithAggregatesInput = {
    AND?: ProjectMetricScalarWhereWithAggregatesInput | ProjectMetricScalarWhereWithAggregatesInput[]
    OR?: ProjectMetricScalarWhereWithAggregatesInput[]
    NOT?: ProjectMetricScalarWhereWithAggregatesInput | ProjectMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectMetric"> | string
    projectId?: StringWithAggregatesFilter<"ProjectMetric"> | string
    metricName?: StringWithAggregatesFilter<"ProjectMetric"> | string
    metricCategory?: StringWithAggregatesFilter<"ProjectMetric"> | string
    value?: FloatWithAggregatesFilter<"ProjectMetric"> | number
    unit?: StringNullableWithAggregatesFilter<"ProjectMetric"> | string | null
    baselineValue?: FloatNullableWithAggregatesFilter<"ProjectMetric"> | number | null
    targetValue?: FloatNullableWithAggregatesFilter<"ProjectMetric"> | number | null
    recordedAt?: DateTimeWithAggregatesFilter<"ProjectMetric"> | Date | string
  }

  export type AISolutionWhereInput = {
    AND?: AISolutionWhereInput | AISolutionWhereInput[]
    OR?: AISolutionWhereInput[]
    NOT?: AISolutionWhereInput | AISolutionWhereInput[]
    id?: StringFilter<"AISolution"> | string
    name?: StringFilter<"AISolution"> | string
    category?: StringFilter<"AISolution"> | string
    description?: StringNullableFilter<"AISolution"> | string | null
    tagline?: StringNullableFilter<"AISolution"> | string | null
    longDescription?: StringNullableFilter<"AISolution"> | string | null
    targetIndustries?: StringNullableListFilter<"AISolution">
    targetFunctions?: StringNullableListFilter<"AISolution">
    technicalRequirements?: StringNullableListFilter<"AISolution">
    integrationPoints?: StringNullableListFilter<"AISolution">
    pricingModels?: StringNullableListFilter<"AISolution">
    typicalTimelineWeeks?: IntNullableFilter<"AISolution"> | number | null
    useCases?: StringNullableListFilter<"AISolution">
    caseStudies?: JsonNullableFilter<"AISolution">
    isActive?: BoolFilter<"AISolution"> | boolean
    displayOrder?: IntFilter<"AISolution"> | number
    createdAt?: DateTimeFilter<"AISolution"> | Date | string
    updatedAt?: DateTimeFilter<"AISolution"> | Date | string
    modules?: AISolutionModuleListRelationFilter
    quotes?: QuoteListRelationFilter
    clientSolutions?: ClientSolutionListRelationFilter
  }

  export type AISolutionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    tagline?: SortOrderInput | SortOrder
    longDescription?: SortOrderInput | SortOrder
    targetIndustries?: SortOrder
    targetFunctions?: SortOrder
    technicalRequirements?: SortOrder
    integrationPoints?: SortOrder
    pricingModels?: SortOrder
    typicalTimelineWeeks?: SortOrderInput | SortOrder
    useCases?: SortOrder
    caseStudies?: SortOrderInput | SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    modules?: AISolutionModuleOrderByRelationAggregateInput
    quotes?: QuoteOrderByRelationAggregateInput
    clientSolutions?: ClientSolutionOrderByRelationAggregateInput
  }

  export type AISolutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AISolutionWhereInput | AISolutionWhereInput[]
    OR?: AISolutionWhereInput[]
    NOT?: AISolutionWhereInput | AISolutionWhereInput[]
    name?: StringFilter<"AISolution"> | string
    category?: StringFilter<"AISolution"> | string
    description?: StringNullableFilter<"AISolution"> | string | null
    tagline?: StringNullableFilter<"AISolution"> | string | null
    longDescription?: StringNullableFilter<"AISolution"> | string | null
    targetIndustries?: StringNullableListFilter<"AISolution">
    targetFunctions?: StringNullableListFilter<"AISolution">
    technicalRequirements?: StringNullableListFilter<"AISolution">
    integrationPoints?: StringNullableListFilter<"AISolution">
    pricingModels?: StringNullableListFilter<"AISolution">
    typicalTimelineWeeks?: IntNullableFilter<"AISolution"> | number | null
    useCases?: StringNullableListFilter<"AISolution">
    caseStudies?: JsonNullableFilter<"AISolution">
    isActive?: BoolFilter<"AISolution"> | boolean
    displayOrder?: IntFilter<"AISolution"> | number
    createdAt?: DateTimeFilter<"AISolution"> | Date | string
    updatedAt?: DateTimeFilter<"AISolution"> | Date | string
    modules?: AISolutionModuleListRelationFilter
    quotes?: QuoteListRelationFilter
    clientSolutions?: ClientSolutionListRelationFilter
  }, "id">

  export type AISolutionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    tagline?: SortOrderInput | SortOrder
    longDescription?: SortOrderInput | SortOrder
    targetIndustries?: SortOrder
    targetFunctions?: SortOrder
    technicalRequirements?: SortOrder
    integrationPoints?: SortOrder
    pricingModels?: SortOrder
    typicalTimelineWeeks?: SortOrderInput | SortOrder
    useCases?: SortOrder
    caseStudies?: SortOrderInput | SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AISolutionCountOrderByAggregateInput
    _avg?: AISolutionAvgOrderByAggregateInput
    _max?: AISolutionMaxOrderByAggregateInput
    _min?: AISolutionMinOrderByAggregateInput
    _sum?: AISolutionSumOrderByAggregateInput
  }

  export type AISolutionScalarWhereWithAggregatesInput = {
    AND?: AISolutionScalarWhereWithAggregatesInput | AISolutionScalarWhereWithAggregatesInput[]
    OR?: AISolutionScalarWhereWithAggregatesInput[]
    NOT?: AISolutionScalarWhereWithAggregatesInput | AISolutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AISolution"> | string
    name?: StringWithAggregatesFilter<"AISolution"> | string
    category?: StringWithAggregatesFilter<"AISolution"> | string
    description?: StringNullableWithAggregatesFilter<"AISolution"> | string | null
    tagline?: StringNullableWithAggregatesFilter<"AISolution"> | string | null
    longDescription?: StringNullableWithAggregatesFilter<"AISolution"> | string | null
    targetIndustries?: StringNullableListFilter<"AISolution">
    targetFunctions?: StringNullableListFilter<"AISolution">
    technicalRequirements?: StringNullableListFilter<"AISolution">
    integrationPoints?: StringNullableListFilter<"AISolution">
    pricingModels?: StringNullableListFilter<"AISolution">
    typicalTimelineWeeks?: IntNullableWithAggregatesFilter<"AISolution"> | number | null
    useCases?: StringNullableListFilter<"AISolution">
    caseStudies?: JsonNullableWithAggregatesFilter<"AISolution">
    isActive?: BoolWithAggregatesFilter<"AISolution"> | boolean
    displayOrder?: IntWithAggregatesFilter<"AISolution"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AISolution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AISolution"> | Date | string
  }

  export type AISolutionModuleWhereInput = {
    AND?: AISolutionModuleWhereInput | AISolutionModuleWhereInput[]
    OR?: AISolutionModuleWhereInput[]
    NOT?: AISolutionModuleWhereInput | AISolutionModuleWhereInput[]
    id?: StringFilter<"AISolutionModule"> | string
    solutionId?: StringFilter<"AISolutionModule"> | string
    name?: StringFilter<"AISolutionModule"> | string
    description?: StringNullableFilter<"AISolutionModule"> | string | null
    basePrice?: FloatFilter<"AISolutionModule"> | number
    isOptional?: BoolFilter<"AISolutionModule"> | boolean
    solution?: XOR<AISolutionRelationFilter, AISolutionWhereInput>
  }

  export type AISolutionModuleOrderByWithRelationInput = {
    id?: SortOrder
    solutionId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    isOptional?: SortOrder
    solution?: AISolutionOrderByWithRelationInput
  }

  export type AISolutionModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AISolutionModuleWhereInput | AISolutionModuleWhereInput[]
    OR?: AISolutionModuleWhereInput[]
    NOT?: AISolutionModuleWhereInput | AISolutionModuleWhereInput[]
    solutionId?: StringFilter<"AISolutionModule"> | string
    name?: StringFilter<"AISolutionModule"> | string
    description?: StringNullableFilter<"AISolutionModule"> | string | null
    basePrice?: FloatFilter<"AISolutionModule"> | number
    isOptional?: BoolFilter<"AISolutionModule"> | boolean
    solution?: XOR<AISolutionRelationFilter, AISolutionWhereInput>
  }, "id">

  export type AISolutionModuleOrderByWithAggregationInput = {
    id?: SortOrder
    solutionId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    isOptional?: SortOrder
    _count?: AISolutionModuleCountOrderByAggregateInput
    _avg?: AISolutionModuleAvgOrderByAggregateInput
    _max?: AISolutionModuleMaxOrderByAggregateInput
    _min?: AISolutionModuleMinOrderByAggregateInput
    _sum?: AISolutionModuleSumOrderByAggregateInput
  }

  export type AISolutionModuleScalarWhereWithAggregatesInput = {
    AND?: AISolutionModuleScalarWhereWithAggregatesInput | AISolutionModuleScalarWhereWithAggregatesInput[]
    OR?: AISolutionModuleScalarWhereWithAggregatesInput[]
    NOT?: AISolutionModuleScalarWhereWithAggregatesInput | AISolutionModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AISolutionModule"> | string
    solutionId?: StringWithAggregatesFilter<"AISolutionModule"> | string
    name?: StringWithAggregatesFilter<"AISolutionModule"> | string
    description?: StringNullableWithAggregatesFilter<"AISolutionModule"> | string | null
    basePrice?: FloatWithAggregatesFilter<"AISolutionModule"> | number
    isOptional?: BoolWithAggregatesFilter<"AISolutionModule"> | boolean
  }

  export type QuoteWhereInput = {
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    id?: StringFilter<"Quote"> | string
    solutionId?: StringFilter<"Quote"> | string
    clientId?: StringNullableFilter<"Quote"> | string | null
    quoteNumber?: StringFilter<"Quote"> | string
    version?: IntFilter<"Quote"> | number
    status?: StringFilter<"Quote"> | string
    scope?: StringNullableFilter<"Quote"> | string | null
    timelineWeeks?: IntNullableFilter<"Quote"> | number | null
    totalPrice?: FloatFilter<"Quote"> | number
    validUntil?: DateTimeNullableFilter<"Quote"> | Date | string | null
    requestedBy?: StringNullableFilter<"Quote"> | string | null
    requestedAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
    solution?: XOR<AISolutionRelationFilter, AISolutionWhereInput>
  }

  export type QuoteOrderByWithRelationInput = {
    id?: SortOrder
    solutionId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    quoteNumber?: SortOrder
    version?: SortOrder
    status?: SortOrder
    scope?: SortOrderInput | SortOrder
    timelineWeeks?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    requestedBy?: SortOrderInput | SortOrder
    requestedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    solution?: AISolutionOrderByWithRelationInput
  }

  export type QuoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    quoteNumber?: string
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    solutionId?: StringFilter<"Quote"> | string
    clientId?: StringNullableFilter<"Quote"> | string | null
    version?: IntFilter<"Quote"> | number
    status?: StringFilter<"Quote"> | string
    scope?: StringNullableFilter<"Quote"> | string | null
    timelineWeeks?: IntNullableFilter<"Quote"> | number | null
    totalPrice?: FloatFilter<"Quote"> | number
    validUntil?: DateTimeNullableFilter<"Quote"> | Date | string | null
    requestedBy?: StringNullableFilter<"Quote"> | string | null
    requestedAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
    solution?: XOR<AISolutionRelationFilter, AISolutionWhereInput>
  }, "id" | "quoteNumber">

  export type QuoteOrderByWithAggregationInput = {
    id?: SortOrder
    solutionId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    quoteNumber?: SortOrder
    version?: SortOrder
    status?: SortOrder
    scope?: SortOrderInput | SortOrder
    timelineWeeks?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    requestedBy?: SortOrderInput | SortOrder
    requestedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuoteCountOrderByAggregateInput
    _avg?: QuoteAvgOrderByAggregateInput
    _max?: QuoteMaxOrderByAggregateInput
    _min?: QuoteMinOrderByAggregateInput
    _sum?: QuoteSumOrderByAggregateInput
  }

  export type QuoteScalarWhereWithAggregatesInput = {
    AND?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    OR?: QuoteScalarWhereWithAggregatesInput[]
    NOT?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quote"> | string
    solutionId?: StringWithAggregatesFilter<"Quote"> | string
    clientId?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    quoteNumber?: StringWithAggregatesFilter<"Quote"> | string
    version?: IntWithAggregatesFilter<"Quote"> | number
    status?: StringWithAggregatesFilter<"Quote"> | string
    scope?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    timelineWeeks?: IntNullableWithAggregatesFilter<"Quote"> | number | null
    totalPrice?: FloatWithAggregatesFilter<"Quote"> | number
    validUntil?: DateTimeNullableWithAggregatesFilter<"Quote"> | Date | string | null
    requestedBy?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    requestedAt?: DateTimeNullableWithAggregatesFilter<"Quote"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    ownerId?: StringFilter<"Activity"> | string
    leadId?: StringNullableFilter<"Activity"> | string | null
    opportunityId?: StringNullableFilter<"Activity"> | string | null
    contactId?: StringNullableFilter<"Activity"> | string | null
    type?: StringFilter<"Activity"> | string
    subject?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    scheduledAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    durationMinutes?: IntNullableFilter<"Activity"> | number | null
    outcome?: StringNullableFilter<"Activity"> | string | null
    sentiment?: StringNullableFilter<"Activity"> | string | null
    keyTopics?: StringNullableListFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    owner?: XOR<UserRelationFilter, UserWhereInput>
    lead?: XOR<LeadNullableRelationFilter, LeadWhereInput> | null
    opportunity?: XOR<OpportunityNullableRelationFilter, OpportunityWhereInput> | null
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    leadId?: SortOrderInput | SortOrder
    opportunityId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    type?: SortOrder
    subject?: SortOrder
    description?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    keyTopics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
    opportunity?: OpportunityOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    ownerId?: StringFilter<"Activity"> | string
    leadId?: StringNullableFilter<"Activity"> | string | null
    opportunityId?: StringNullableFilter<"Activity"> | string | null
    contactId?: StringNullableFilter<"Activity"> | string | null
    type?: StringFilter<"Activity"> | string
    subject?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    scheduledAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    durationMinutes?: IntNullableFilter<"Activity"> | number | null
    outcome?: StringNullableFilter<"Activity"> | string | null
    sentiment?: StringNullableFilter<"Activity"> | string | null
    keyTopics?: StringNullableListFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    owner?: XOR<UserRelationFilter, UserWhereInput>
    lead?: XOR<LeadNullableRelationFilter, LeadWhereInput> | null
    opportunity?: XOR<OpportunityNullableRelationFilter, OpportunityWhereInput> | null
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    leadId?: SortOrderInput | SortOrder
    opportunityId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    type?: SortOrder
    subject?: SortOrder
    description?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    keyTopics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _avg?: ActivityAvgOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
    _sum?: ActivitySumOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    ownerId?: StringWithAggregatesFilter<"Activity"> | string
    leadId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    opportunityId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    contactId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    type?: StringWithAggregatesFilter<"Activity"> | string
    subject?: StringWithAggregatesFilter<"Activity"> | string
    description?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"Activity"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Activity"> | Date | string | null
    durationMinutes?: IntNullableWithAggregatesFilter<"Activity"> | number | null
    outcome?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    sentiment?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    keyTopics?: StringNullableListFilter<"Activity">
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    id?: StringFilter<"Feedback"> | string
    clientId?: StringFilter<"Feedback"> | string
    projectId?: StringNullableFilter<"Feedback"> | string | null
    milestoneId?: StringNullableFilter<"Feedback"> | string | null
    type?: StringFilter<"Feedback"> | string
    rating?: IntFilter<"Feedback"> | number
    comments?: StringNullableFilter<"Feedback"> | string | null
    deliveredOnTime?: BoolNullableFilter<"Feedback"> | boolean | null
    metExpectations?: BoolNullableFilter<"Feedback"> | boolean | null
    wouldRecommend?: BoolNullableFilter<"Feedback"> | boolean | null
    responderName?: StringNullableFilter<"Feedback"> | string | null
    responderEmail?: StringNullableFilter<"Feedback"> | string | null
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    milestoneId?: SortOrderInput | SortOrder
    type?: SortOrder
    rating?: SortOrder
    comments?: SortOrderInput | SortOrder
    deliveredOnTime?: SortOrderInput | SortOrder
    metExpectations?: SortOrderInput | SortOrder
    wouldRecommend?: SortOrderInput | SortOrder
    responderName?: SortOrderInput | SortOrder
    responderEmail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type FeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    clientId?: StringFilter<"Feedback"> | string
    projectId?: StringNullableFilter<"Feedback"> | string | null
    milestoneId?: StringNullableFilter<"Feedback"> | string | null
    type?: StringFilter<"Feedback"> | string
    rating?: IntFilter<"Feedback"> | number
    comments?: StringNullableFilter<"Feedback"> | string | null
    deliveredOnTime?: BoolNullableFilter<"Feedback"> | boolean | null
    metExpectations?: BoolNullableFilter<"Feedback"> | boolean | null
    wouldRecommend?: BoolNullableFilter<"Feedback"> | boolean | null
    responderName?: StringNullableFilter<"Feedback"> | string | null
    responderEmail?: StringNullableFilter<"Feedback"> | string | null
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
  }, "id">

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    milestoneId?: SortOrderInput | SortOrder
    type?: SortOrder
    rating?: SortOrder
    comments?: SortOrderInput | SortOrder
    deliveredOnTime?: SortOrderInput | SortOrder
    metExpectations?: SortOrderInput | SortOrder
    wouldRecommend?: SortOrderInput | SortOrder
    responderName?: SortOrderInput | SortOrder
    responderEmail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _avg?: FeedbackAvgOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
    _sum?: FeedbackSumOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Feedback"> | string
    clientId?: StringWithAggregatesFilter<"Feedback"> | string
    projectId?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    milestoneId?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    type?: StringWithAggregatesFilter<"Feedback"> | string
    rating?: IntWithAggregatesFilter<"Feedback"> | number
    comments?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    deliveredOnTime?: BoolNullableWithAggregatesFilter<"Feedback"> | boolean | null
    metExpectations?: BoolNullableWithAggregatesFilter<"Feedback"> | boolean | null
    wouldRecommend?: BoolNullableWithAggregatesFilter<"Feedback"> | boolean | null
    responderName?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    responderEmail?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: StringFilter<"Ticket"> | string
    clientId?: StringFilter<"Ticket"> | string
    assigneeId?: StringNullableFilter<"Ticket"> | string | null
    ticketNumber?: StringFilter<"Ticket"> | string
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    type?: EnumTicketTypeFilter<"Ticket"> | $Enums.TicketType
    severity?: EnumTicketSeverityFilter<"Ticket"> | $Enums.TicketSeverity
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    resolution?: StringNullableFilter<"Ticket"> | string | null
    rootCause?: StringNullableFilter<"Ticket"> | string | null
    slaResponseDue?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    slaResolutionDue?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    respondedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    assignee?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    comments?: TicketCommentListRelationFilter
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    assigneeId?: SortOrderInput | SortOrder
    ticketNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    resolution?: SortOrderInput | SortOrder
    rootCause?: SortOrderInput | SortOrder
    slaResponseDue?: SortOrderInput | SortOrder
    slaResolutionDue?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    assignee?: UserOrderByWithRelationInput
    comments?: TicketCommentOrderByRelationAggregateInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ticketNumber?: string
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    clientId?: StringFilter<"Ticket"> | string
    assigneeId?: StringNullableFilter<"Ticket"> | string | null
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    type?: EnumTicketTypeFilter<"Ticket"> | $Enums.TicketType
    severity?: EnumTicketSeverityFilter<"Ticket"> | $Enums.TicketSeverity
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    resolution?: StringNullableFilter<"Ticket"> | string | null
    rootCause?: StringNullableFilter<"Ticket"> | string | null
    slaResponseDue?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    slaResolutionDue?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    respondedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    assignee?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    comments?: TicketCommentListRelationFilter
  }, "id" | "ticketNumber">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    assigneeId?: SortOrderInput | SortOrder
    ticketNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    resolution?: SortOrderInput | SortOrder
    rootCause?: SortOrderInput | SortOrder
    slaResponseDue?: SortOrderInput | SortOrder
    slaResolutionDue?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TicketCountOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ticket"> | string
    clientId?: StringWithAggregatesFilter<"Ticket"> | string
    assigneeId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    ticketNumber?: StringWithAggregatesFilter<"Ticket"> | string
    title?: StringWithAggregatesFilter<"Ticket"> | string
    description?: StringWithAggregatesFilter<"Ticket"> | string
    type?: EnumTicketTypeWithAggregatesFilter<"Ticket"> | $Enums.TicketType
    severity?: EnumTicketSeverityWithAggregatesFilter<"Ticket"> | $Enums.TicketSeverity
    status?: EnumTicketStatusWithAggregatesFilter<"Ticket"> | $Enums.TicketStatus
    resolution?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    rootCause?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    slaResponseDue?: DateTimeNullableWithAggregatesFilter<"Ticket"> | Date | string | null
    slaResolutionDue?: DateTimeNullableWithAggregatesFilter<"Ticket"> | Date | string | null
    respondedAt?: DateTimeNullableWithAggregatesFilter<"Ticket"> | Date | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Ticket"> | Date | string | null
    closedAt?: DateTimeNullableWithAggregatesFilter<"Ticket"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
  }

  export type TicketCommentWhereInput = {
    AND?: TicketCommentWhereInput | TicketCommentWhereInput[]
    OR?: TicketCommentWhereInput[]
    NOT?: TicketCommentWhereInput | TicketCommentWhereInput[]
    id?: StringFilter<"TicketComment"> | string
    ticketId?: StringFilter<"TicketComment"> | string
    authorId?: StringFilter<"TicketComment"> | string
    content?: StringFilter<"TicketComment"> | string
    isInternal?: BoolFilter<"TicketComment"> | boolean
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
  }

  export type TicketCommentOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    ticket?: TicketOrderByWithRelationInput
  }

  export type TicketCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketCommentWhereInput | TicketCommentWhereInput[]
    OR?: TicketCommentWhereInput[]
    NOT?: TicketCommentWhereInput | TicketCommentWhereInput[]
    ticketId?: StringFilter<"TicketComment"> | string
    authorId?: StringFilter<"TicketComment"> | string
    content?: StringFilter<"TicketComment"> | string
    isInternal?: BoolFilter<"TicketComment"> | boolean
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
  }, "id">

  export type TicketCommentOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    _count?: TicketCommentCountOrderByAggregateInput
    _max?: TicketCommentMaxOrderByAggregateInput
    _min?: TicketCommentMinOrderByAggregateInput
  }

  export type TicketCommentScalarWhereWithAggregatesInput = {
    AND?: TicketCommentScalarWhereWithAggregatesInput | TicketCommentScalarWhereWithAggregatesInput[]
    OR?: TicketCommentScalarWhereWithAggregatesInput[]
    NOT?: TicketCommentScalarWhereWithAggregatesInput | TicketCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketComment"> | string
    ticketId?: StringWithAggregatesFilter<"TicketComment"> | string
    authorId?: StringWithAggregatesFilter<"TicketComment"> | string
    content?: StringWithAggregatesFilter<"TicketComment"> | string
    isInternal?: BoolWithAggregatesFilter<"TicketComment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TicketComment"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    entityType?: StringFilter<"Comment"> | string
    entityId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    authorId?: StringFilter<"Comment"> | string
    entityType?: StringFilter<"Comment"> | string
    entityId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    authorId?: StringWithAggregatesFilter<"Comment"> | string
    entityType?: StringWithAggregatesFilter<"Comment"> | string
    entityId?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    changes?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutUsersInput
    managedBy?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagedByInput
    leads?: LeadCreateNestedManyWithoutOwnerInput
    opportunities?: OpportunityCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskCreateNestedManyWithoutAssigneeInput
    projectMilestones?: ProjectMilestoneCreateNestedManyWithoutOwnerInput
    tickets?: TicketCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    managerId?: string | null
    subordinates?: UserUncheckedCreateNestedManyWithoutManagedByInput
    leads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskUncheckedCreateNestedManyWithoutAssigneeInput
    projectMilestones?: ProjectMilestoneUncheckedCreateNestedManyWithoutOwnerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutUsersNestedInput
    managedBy?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagedByNestedInput
    leads?: LeadUpdateManyWithoutOwnerNestedInput
    opportunities?: OpportunityUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUpdateManyWithoutAssigneeNestedInput
    projectMilestones?: ProjectMilestoneUpdateManyWithoutOwnerNestedInput
    tickets?: TicketUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    subordinates?: UserUncheckedUpdateManyWithoutManagedByNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    projectMilestones?: ProjectMilestoneUncheckedUpdateManyWithoutOwnerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    managerId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientCreateInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutClientInput
    leads?: LeadCreateNestedManyWithoutClientInput
    opportunities?: OpportunityCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    tickets?: TicketCreateNestedManyWithoutClientInput
    feedback?: FeedbackCreateNestedManyWithoutClientInput
    aiSolutions?: ClientSolutionCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    tickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutClientInput
    aiSolutions?: ClientSolutionUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutClientNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    opportunities?: OpportunityUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    tickets?: TicketUpdateManyWithoutClientNestedInput
    feedback?: FeedbackUpdateManyWithoutClientNestedInput
    aiSolutions?: ClientSolutionUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutClientNestedInput
    aiSolutions?: ClientSolutionUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSolutionCreateInput = {
    id?: string
    deployedAt?: Date | string | null
    status?: string
    client: ClientCreateNestedOneWithoutAiSolutionsInput
    solution: AISolutionCreateNestedOneWithoutClientSolutionsInput
  }

  export type ClientSolutionUncheckedCreateInput = {
    id?: string
    clientId: string
    solutionId: string
    deployedAt?: Date | string | null
    status?: string
  }

  export type ClientSolutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    client?: ClientUpdateOneRequiredWithoutAiSolutionsNestedInput
    solution?: AISolutionUpdateOneRequiredWithoutClientSolutionsNestedInput
  }

  export type ClientSolutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    solutionId?: StringFieldUpdateOperationsInput | string
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ClientSolutionCreateManyInput = {
    id?: string
    clientId: string
    solutionId: string
    deployedAt?: Date | string | null
    status?: string
  }

  export type ClientSolutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ClientSolutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    solutionId?: StringFieldUpdateOperationsInput | string
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ContactCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    jobTitle?: string | null
    isDecisionMaker?: boolean
    isInfluencer?: boolean
    isTechnicalLead?: boolean
    isEndUser?: boolean
    isBudgetHolder?: boolean
    influenceLevel?: number
    relationshipScore?: number
    lastInteraction?: Date | string | null
    preferredChannel?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutContactsInput
    activities?: ActivityCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    clientId: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    jobTitle?: string | null
    isDecisionMaker?: boolean
    isInfluencer?: boolean
    isTechnicalLead?: boolean
    isEndUser?: boolean
    isBudgetHolder?: boolean
    influenceLevel?: number
    relationshipScore?: number
    lastInteraction?: Date | string | null
    preferredChannel?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    isInfluencer?: BoolFieldUpdateOperationsInput | boolean
    isTechnicalLead?: BoolFieldUpdateOperationsInput | boolean
    isEndUser?: BoolFieldUpdateOperationsInput | boolean
    isBudgetHolder?: BoolFieldUpdateOperationsInput | boolean
    influenceLevel?: IntFieldUpdateOperationsInput | number
    relationshipScore?: IntFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredChannel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutContactsNestedInput
    activities?: ActivityUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    isInfluencer?: BoolFieldUpdateOperationsInput | boolean
    isTechnicalLead?: BoolFieldUpdateOperationsInput | boolean
    isEndUser?: BoolFieldUpdateOperationsInput | boolean
    isBudgetHolder?: BoolFieldUpdateOperationsInput | boolean
    influenceLevel?: IntFieldUpdateOperationsInput | number
    relationshipScore?: IntFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredChannel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    clientId: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    jobTitle?: string | null
    isDecisionMaker?: boolean
    isInfluencer?: boolean
    isTechnicalLead?: boolean
    isEndUser?: boolean
    isBudgetHolder?: boolean
    influenceLevel?: number
    relationshipScore?: number
    lastInteraction?: Date | string | null
    preferredChannel?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    isInfluencer?: BoolFieldUpdateOperationsInput | boolean
    isTechnicalLead?: BoolFieldUpdateOperationsInput | boolean
    isEndUser?: BoolFieldUpdateOperationsInput | boolean
    isBudgetHolder?: BoolFieldUpdateOperationsInput | boolean
    influenceLevel?: IntFieldUpdateOperationsInput | number
    relationshipScore?: IntFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredChannel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    isInfluencer?: BoolFieldUpdateOperationsInput | boolean
    isTechnicalLead?: BoolFieldUpdateOperationsInput | boolean
    isEndUser?: BoolFieldUpdateOperationsInput | boolean
    isBudgetHolder?: BoolFieldUpdateOperationsInput | boolean
    influenceLevel?: IntFieldUpdateOperationsInput | number
    relationshipScore?: IntFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredChannel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateInput = {
    id?: string
    source: string
    sourceDetails?: string | null
    status?: $Enums.LeadStatus
    companyName: string
    contactName: string
    contactEmail: string
    contactPhone?: string | null
    industry?: string | null
    companySize?: string | null
    leadScore?: number
    scoreTier?: string
    scoreReason?: string | null
    budgetRange?: string | null
    timeline?: string | null
    needDescription?: string | null
    convertedAt?: Date | string | null
    lostAt?: Date | string | null
    lossReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutLeadsInput
    owner: UserCreateNestedOneWithoutLeadsInput
    activities?: ActivityCreateNestedManyWithoutLeadInput
    opportunities?: OpportunityCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    clientId?: string | null
    ownerId: string
    source: string
    sourceDetails?: string | null
    status?: $Enums.LeadStatus
    companyName: string
    contactName: string
    contactEmail: string
    contactPhone?: string | null
    industry?: string | null
    companySize?: string | null
    leadScore?: number
    scoreTier?: string
    scoreReason?: string | null
    budgetRange?: string | null
    timeline?: string | null
    needDescription?: string | null
    convertedAt?: Date | string | null
    lostAt?: Date | string | null
    lossReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutLeadInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceDetails?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    leadScore?: IntFieldUpdateOperationsInput | number
    scoreTier?: StringFieldUpdateOperationsInput | string
    scoreReason?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    needDescription?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutLeadsNestedInput
    owner?: UserUpdateOneRequiredWithoutLeadsNestedInput
    activities?: ActivityUpdateManyWithoutLeadNestedInput
    opportunities?: OpportunityUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceDetails?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    leadScore?: IntFieldUpdateOperationsInput | number
    scoreTier?: StringFieldUpdateOperationsInput | string
    scoreReason?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    needDescription?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutLeadNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateManyInput = {
    id?: string
    clientId?: string | null
    ownerId: string
    source: string
    sourceDetails?: string | null
    status?: $Enums.LeadStatus
    companyName: string
    contactName: string
    contactEmail: string
    contactPhone?: string | null
    industry?: string | null
    companySize?: string | null
    leadScore?: number
    scoreTier?: string
    scoreReason?: string | null
    budgetRange?: string | null
    timeline?: string | null
    needDescription?: string | null
    convertedAt?: Date | string | null
    lostAt?: Date | string | null
    lossReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceDetails?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    leadScore?: IntFieldUpdateOperationsInput | number
    scoreTier?: StringFieldUpdateOperationsInput | string
    scoreReason?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    needDescription?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceDetails?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    leadScore?: IntFieldUpdateOperationsInput | number
    scoreTier?: StringFieldUpdateOperationsInput | string
    scoreReason?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    needDescription?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityCreateInput = {
    id?: string
    name: string
    stage?: $Enums.OpportunityStage
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    estimatedValue?: number
    weightedValue?: number
    nextStep?: string | null
    nextStepDate?: Date | string | null
    lostReason?: string | null
    wonReason?: string | null
    solutionType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lead?: LeadCreateNestedOneWithoutOpportunitiesInput
    client?: ClientCreateNestedOneWithoutOpportunitiesInput
    owner: UserCreateNestedOneWithoutOpportunitiesInput
    activities?: ActivityCreateNestedManyWithoutOpportunityInput
    proposals?: ProposalCreateNestedManyWithoutOpportunityInput
    project?: ProjectCreateNestedOneWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateInput = {
    id?: string
    leadId?: string | null
    clientId?: string | null
    ownerId: string
    name: string
    stage?: $Enums.OpportunityStage
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    estimatedValue?: number
    weightedValue?: number
    nextStep?: string | null
    nextStepDate?: Date | string | null
    lostReason?: string | null
    wonReason?: string | null
    solutionType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutOpportunityInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutOpportunityInput
    project?: ProjectUncheckedCreateNestedOneWithoutOpportunityInput
  }

  export type OpportunityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneWithoutOpportunitiesNestedInput
    client?: ClientUpdateOneWithoutOpportunitiesNestedInput
    owner?: UserUpdateOneRequiredWithoutOpportunitiesNestedInput
    activities?: ActivityUpdateManyWithoutOpportunityNestedInput
    proposals?: ProposalUpdateManyWithoutOpportunityNestedInput
    project?: ProjectUpdateOneWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutOpportunityNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutOpportunityNestedInput
    project?: ProjectUncheckedUpdateOneWithoutOpportunityNestedInput
  }

  export type OpportunityCreateManyInput = {
    id?: string
    leadId?: string | null
    clientId?: string | null
    ownerId: string
    name: string
    stage?: $Enums.OpportunityStage
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    estimatedValue?: number
    weightedValue?: number
    nextStep?: string | null
    nextStepDate?: Date | string | null
    lostReason?: string | null
    wonReason?: string | null
    solutionType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalCreateInput = {
    id?: string
    version?: number
    title: string
    content?: NullableJsonNullValueInput | InputJsonValue
    solutionDescription?: string | null
    implementationPlan?: string | null
    timelineWeeks?: number | null
    basePrice?: number
    discount?: number
    finalPrice?: number
    terms?: string | null
    status?: string
    approvalStatus?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    signedAt?: Date | string | null
    documentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunity: OpportunityCreateNestedOneWithoutProposalsInput
  }

  export type ProposalUncheckedCreateInput = {
    id?: string
    opportunityId: string
    version?: number
    title: string
    content?: NullableJsonNullValueInput | InputJsonValue
    solutionDescription?: string | null
    implementationPlan?: string | null
    timelineWeeks?: number | null
    basePrice?: number
    discount?: number
    finalPrice?: number
    terms?: string | null
    status?: string
    approvalStatus?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    signedAt?: Date | string | null
    documentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    implementationPlan?: NullableStringFieldUpdateOperationsInput | string | null
    timelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunity?: OpportunityUpdateOneRequiredWithoutProposalsNestedInput
  }

  export type ProposalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    implementationPlan?: NullableStringFieldUpdateOperationsInput | string | null
    timelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalCreateManyInput = {
    id?: string
    opportunityId: string
    version?: number
    title: string
    content?: NullableJsonNullValueInput | InputJsonValue
    solutionDescription?: string | null
    implementationPlan?: string | null
    timelineWeeks?: number | null
    basePrice?: number
    discount?: number
    finalPrice?: number
    terms?: string | null
    status?: string
    approvalStatus?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    signedAt?: Date | string | null
    documentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    implementationPlan?: NullableStringFieldUpdateOperationsInput | string | null
    timelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    implementationPlan?: NullableStringFieldUpdateOperationsInput | string | null
    timelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    budget?: number
    actualCost?: number
    projectManagerId?: string | null
    solutionType?: string | null
    healthStatus?: string
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunity?: OpportunityCreateNestedOneWithoutProjectInput
    client: ClientCreateNestedOneWithoutProjectsInput
    milestones?: ProjectMilestoneCreateNestedManyWithoutProjectInput
    tasks?: ProjectTaskCreateNestedManyWithoutProjectInput
    metrics?: ProjectMetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    opportunityId?: string | null
    clientId: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    budget?: number
    actualCost?: number
    projectManagerId?: string | null
    solutionType?: string | null
    healthStatus?: string
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: ProjectMilestoneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: ProjectTaskUncheckedCreateNestedManyWithoutProjectInput
    metrics?: ProjectMetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualCost?: FloatFieldUpdateOperationsInput | number
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    healthStatus?: StringFieldUpdateOperationsInput | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunity?: OpportunityUpdateOneWithoutProjectNestedInput
    client?: ClientUpdateOneRequiredWithoutProjectsNestedInput
    milestones?: ProjectMilestoneUpdateManyWithoutProjectNestedInput
    tasks?: ProjectTaskUpdateManyWithoutProjectNestedInput
    metrics?: ProjectMetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualCost?: FloatFieldUpdateOperationsInput | number
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    healthStatus?: StringFieldUpdateOperationsInput | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: ProjectMilestoneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: ProjectTaskUncheckedUpdateManyWithoutProjectNestedInput
    metrics?: ProjectMetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    opportunityId?: string | null
    clientId: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    budget?: number
    actualCost?: number
    projectManagerId?: string | null
    solutionType?: string | null
    healthStatus?: string
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualCost?: FloatFieldUpdateOperationsInput | number
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    healthStatus?: StringFieldUpdateOperationsInput | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualCost?: FloatFieldUpdateOperationsInput | number
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    healthStatus?: StringFieldUpdateOperationsInput | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMilestoneCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.MilestoneStatus
    phase?: string | null
    order: number
    plannedStartDate?: Date | string | null
    plannedEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    completionCriteria?: string | null
    dependsOnId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMilestonesInput
    owner?: UserCreateNestedOneWithoutProjectMilestonesInput
  }

  export type ProjectMilestoneUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    status?: $Enums.MilestoneStatus
    phase?: string | null
    order: number
    plannedStartDate?: Date | string | null
    plannedEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    completionCriteria?: string | null
    ownerId?: string | null
    dependsOnId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMilestoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMilestonesNestedInput
    owner?: UserUpdateOneWithoutProjectMilestonesNestedInput
  }

  export type ProjectMilestoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMilestoneCreateManyInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    status?: $Enums.MilestoneStatus
    phase?: string | null
    order: number
    plannedStartDate?: Date | string | null
    plannedEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    completionCriteria?: string | null
    ownerId?: string | null
    dependsOnId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMilestoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMilestoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: string
    phase?: string | null
    parentTaskId?: string | null
    plannedHours?: number | null
    actualHours?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    blockerReason?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    assignee?: UserCreateNestedOneWithoutProjectTasksInput
  }

  export type ProjectTaskUncheckedCreateInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: string
    phase?: string | null
    assigneeId?: string | null
    parentTaskId?: string | null
    plannedHours?: number | null
    actualHours?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    blockerReason?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: StringFieldUpdateOperationsInput | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: FloatFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    assignee?: UserUpdateOneWithoutProjectTasksNestedInput
  }

  export type ProjectTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: StringFieldUpdateOperationsInput | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: FloatFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTaskCreateManyInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: string
    phase?: string | null
    assigneeId?: string | null
    parentTaskId?: string | null
    plannedHours?: number | null
    actualHours?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    blockerReason?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: StringFieldUpdateOperationsInput | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: FloatFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: StringFieldUpdateOperationsInput | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: FloatFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMetricCreateInput = {
    id?: string
    metricName: string
    metricCategory: string
    value: number
    unit?: string | null
    baselineValue?: number | null
    targetValue?: number | null
    recordedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMetricsInput
  }

  export type ProjectMetricUncheckedCreateInput = {
    id?: string
    projectId: string
    metricName: string
    metricCategory: string
    value: number
    unit?: string | null
    baselineValue?: number | null
    targetValue?: number | null
    recordedAt?: Date | string
  }

  export type ProjectMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricCategory?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type ProjectMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricCategory?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMetricCreateManyInput = {
    id?: string
    projectId: string
    metricName: string
    metricCategory: string
    value: number
    unit?: string | null
    baselineValue?: number | null
    targetValue?: number | null
    recordedAt?: Date | string
  }

  export type ProjectMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricCategory?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricCategory?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AISolutionCreateInput = {
    id?: string
    name: string
    category: string
    description?: string | null
    tagline?: string | null
    longDescription?: string | null
    targetIndustries?: AISolutionCreatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionCreatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionCreatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionCreateintegrationPointsInput | string[]
    pricingModels?: AISolutionCreatepricingModelsInput | string[]
    typicalTimelineWeeks?: number | null
    useCases?: AISolutionCreateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: AISolutionModuleCreateNestedManyWithoutSolutionInput
    quotes?: QuoteCreateNestedManyWithoutSolutionInput
    clientSolutions?: ClientSolutionCreateNestedManyWithoutSolutionInput
  }

  export type AISolutionUncheckedCreateInput = {
    id?: string
    name: string
    category: string
    description?: string | null
    tagline?: string | null
    longDescription?: string | null
    targetIndustries?: AISolutionCreatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionCreatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionCreatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionCreateintegrationPointsInput | string[]
    pricingModels?: AISolutionCreatepricingModelsInput | string[]
    typicalTimelineWeeks?: number | null
    useCases?: AISolutionCreateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: AISolutionModuleUncheckedCreateNestedManyWithoutSolutionInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutSolutionInput
    clientSolutions?: ClientSolutionUncheckedCreateNestedManyWithoutSolutionInput
  }

  export type AISolutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    targetIndustries?: AISolutionUpdatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionUpdatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionUpdatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionUpdateintegrationPointsInput | string[]
    pricingModels?: AISolutionUpdatepricingModelsInput | string[]
    typicalTimelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    useCases?: AISolutionUpdateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: AISolutionModuleUpdateManyWithoutSolutionNestedInput
    quotes?: QuoteUpdateManyWithoutSolutionNestedInput
    clientSolutions?: ClientSolutionUpdateManyWithoutSolutionNestedInput
  }

  export type AISolutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    targetIndustries?: AISolutionUpdatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionUpdatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionUpdatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionUpdateintegrationPointsInput | string[]
    pricingModels?: AISolutionUpdatepricingModelsInput | string[]
    typicalTimelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    useCases?: AISolutionUpdateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: AISolutionModuleUncheckedUpdateManyWithoutSolutionNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutSolutionNestedInput
    clientSolutions?: ClientSolutionUncheckedUpdateManyWithoutSolutionNestedInput
  }

  export type AISolutionCreateManyInput = {
    id?: string
    name: string
    category: string
    description?: string | null
    tagline?: string | null
    longDescription?: string | null
    targetIndustries?: AISolutionCreatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionCreatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionCreatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionCreateintegrationPointsInput | string[]
    pricingModels?: AISolutionCreatepricingModelsInput | string[]
    typicalTimelineWeeks?: number | null
    useCases?: AISolutionCreateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AISolutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    targetIndustries?: AISolutionUpdatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionUpdatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionUpdatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionUpdateintegrationPointsInput | string[]
    pricingModels?: AISolutionUpdatepricingModelsInput | string[]
    typicalTimelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    useCases?: AISolutionUpdateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AISolutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    targetIndustries?: AISolutionUpdatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionUpdatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionUpdatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionUpdateintegrationPointsInput | string[]
    pricingModels?: AISolutionUpdatepricingModelsInput | string[]
    typicalTimelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    useCases?: AISolutionUpdateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AISolutionModuleCreateInput = {
    id?: string
    name: string
    description?: string | null
    basePrice?: number
    isOptional?: boolean
    solution: AISolutionCreateNestedOneWithoutModulesInput
  }

  export type AISolutionModuleUncheckedCreateInput = {
    id?: string
    solutionId: string
    name: string
    description?: string | null
    basePrice?: number
    isOptional?: boolean
  }

  export type AISolutionModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    solution?: AISolutionUpdateOneRequiredWithoutModulesNestedInput
  }

  export type AISolutionModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    solutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isOptional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AISolutionModuleCreateManyInput = {
    id?: string
    solutionId: string
    name: string
    description?: string | null
    basePrice?: number
    isOptional?: boolean
  }

  export type AISolutionModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isOptional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AISolutionModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    solutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isOptional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuoteCreateInput = {
    id?: string
    clientId?: string | null
    quoteNumber: string
    version?: number
    status?: string
    scope?: string | null
    timelineWeeks?: number | null
    totalPrice?: number
    validUntil?: Date | string | null
    requestedBy?: string | null
    requestedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    solution: AISolutionCreateNestedOneWithoutQuotesInput
  }

  export type QuoteUncheckedCreateInput = {
    id?: string
    solutionId: string
    clientId?: string | null
    quoteNumber: string
    version?: number
    status?: string
    scope?: string | null
    timelineWeeks?: number | null
    totalPrice?: number
    validUntil?: Date | string | null
    requestedBy?: string | null
    requestedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    timelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solution?: AISolutionUpdateOneRequiredWithoutQuotesNestedInput
  }

  export type QuoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    solutionId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    timelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteCreateManyInput = {
    id?: string
    solutionId: string
    clientId?: string | null
    quoteNumber: string
    version?: number
    status?: string
    scope?: string | null
    timelineWeeks?: number | null
    totalPrice?: number
    validUntil?: Date | string | null
    requestedBy?: string | null
    requestedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    timelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    solutionId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    timelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    id?: string
    type: string
    subject: string
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    durationMinutes?: number | null
    outcome?: string | null
    sentiment?: string | null
    keyTopics?: ActivityCreatekeyTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutActivitiesInput
    lead?: LeadCreateNestedOneWithoutActivitiesInput
    opportunity?: OpportunityCreateNestedOneWithoutActivitiesInput
    contact?: ContactCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    ownerId: string
    leadId?: string | null
    opportunityId?: string | null
    contactId?: string | null
    type: string
    subject: string
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    durationMinutes?: number | null
    outcome?: string | null
    sentiment?: string | null
    keyTopics?: ActivityCreatekeyTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    keyTopics?: ActivityUpdatekeyTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    lead?: LeadUpdateOneWithoutActivitiesNestedInput
    opportunity?: OpportunityUpdateOneWithoutActivitiesNestedInput
    contact?: ContactUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    keyTopics?: ActivityUpdatekeyTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyInput = {
    id?: string
    ownerId: string
    leadId?: string | null
    opportunityId?: string | null
    contactId?: string | null
    type: string
    subject: string
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    durationMinutes?: number | null
    outcome?: string | null
    sentiment?: string | null
    keyTopics?: ActivityCreatekeyTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    keyTopics?: ActivityUpdatekeyTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    keyTopics?: ActivityUpdatekeyTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateInput = {
    id?: string
    projectId?: string | null
    milestoneId?: string | null
    type: string
    rating: number
    comments?: string | null
    deliveredOnTime?: boolean | null
    metExpectations?: boolean | null
    wouldRecommend?: boolean | null
    responderName?: string | null
    responderEmail?: string | null
    createdAt?: Date | string
    client: ClientCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateInput = {
    id?: string
    clientId: string
    projectId?: string | null
    milestoneId?: string | null
    type: string
    rating: number
    comments?: string | null
    deliveredOnTime?: boolean | null
    metExpectations?: boolean | null
    wouldRecommend?: boolean | null
    responderName?: string | null
    responderEmail?: string | null
    createdAt?: Date | string
  }

  export type FeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    milestoneId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metExpectations?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responderName?: NullableStringFieldUpdateOperationsInput | string | null
    responderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    milestoneId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metExpectations?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responderName?: NullableStringFieldUpdateOperationsInput | string | null
    responderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateManyInput = {
    id?: string
    clientId: string
    projectId?: string | null
    milestoneId?: string | null
    type: string
    rating: number
    comments?: string | null
    deliveredOnTime?: boolean | null
    metExpectations?: boolean | null
    wouldRecommend?: boolean | null
    responderName?: string | null
    responderEmail?: string | null
    createdAt?: Date | string
  }

  export type FeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    milestoneId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metExpectations?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responderName?: NullableStringFieldUpdateOperationsInput | string | null
    responderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    milestoneId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metExpectations?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responderName?: NullableStringFieldUpdateOperationsInput | string | null
    responderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    type?: $Enums.TicketType
    severity?: $Enums.TicketSeverity
    status?: $Enums.TicketStatus
    resolution?: string | null
    rootCause?: string | null
    slaResponseDue?: Date | string | null
    slaResolutionDue?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutTicketsInput
    assignee?: UserCreateNestedOneWithoutTicketsInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateInput = {
    id?: string
    clientId: string
    assigneeId?: string | null
    ticketNumber: string
    title: string
    description: string
    type?: $Enums.TicketType
    severity?: $Enums.TicketSeverity
    status?: $Enums.TicketStatus
    resolution?: string | null
    rootCause?: string | null
    slaResponseDue?: Date | string | null
    slaResolutionDue?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    severity?: EnumTicketSeverityFieldUpdateOperationsInput | $Enums.TicketSeverity
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolutionDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutTicketsNestedInput
    assignee?: UserUpdateOneWithoutTicketsNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    severity?: EnumTicketSeverityFieldUpdateOperationsInput | $Enums.TicketSeverity
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolutionDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketCreateManyInput = {
    id?: string
    clientId: string
    assigneeId?: string | null
    ticketNumber: string
    title: string
    description: string
    type?: $Enums.TicketType
    severity?: $Enums.TicketSeverity
    status?: $Enums.TicketStatus
    resolution?: string | null
    rootCause?: string | null
    slaResponseDue?: Date | string | null
    slaResolutionDue?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    severity?: EnumTicketSeverityFieldUpdateOperationsInput | $Enums.TicketSeverity
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolutionDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    severity?: EnumTicketSeverityFieldUpdateOperationsInput | $Enums.TicketSeverity
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolutionDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentCreateInput = {
    id?: string
    authorId: string
    content: string
    isInternal?: boolean
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutCommentsInput
  }

  export type TicketCommentUncheckedCreateInput = {
    id?: string
    ticketId: string
    authorId: string
    content: string
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type TicketCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentCreateManyInput = {
    id?: string
    ticketId: string
    authorId: string
    content: string
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type TicketCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    entityType: string
    entityId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    authorId: string
    entityType: string
    entityId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: string
    authorId: string
    entityType: string
    entityId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ClientNullableRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type LeadListRelationFilter = {
    every?: LeadWhereInput
    some?: LeadWhereInput
    none?: LeadWhereInput
  }

  export type OpportunityListRelationFilter = {
    every?: OpportunityWhereInput
    some?: OpportunityWhereInput
    none?: OpportunityWhereInput
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type ProjectTaskListRelationFilter = {
    every?: ProjectTaskWhereInput
    some?: ProjectTaskWhereInput
    none?: ProjectTaskWhereInput
  }

  export type ProjectMilestoneListRelationFilter = {
    every?: ProjectMilestoneWhereInput
    some?: ProjectMilestoneWhereInput
    none?: ProjectMilestoneWhereInput
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpportunityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectMilestoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    managerId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    managerId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    managerId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumClientLifecycleStageFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientLifecycleStage | EnumClientLifecycleStageFieldRefInput<$PrismaModel>
    in?: $Enums.ClientLifecycleStage[] | ListEnumClientLifecycleStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientLifecycleStage[] | ListEnumClientLifecycleStageFieldRefInput<$PrismaModel>
    not?: NestedEnumClientLifecycleStageFilter<$PrismaModel> | $Enums.ClientLifecycleStage
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type FeedbackListRelationFilter = {
    every?: FeedbackWhereInput
    some?: FeedbackWhereInput
    none?: FeedbackWhereInput
  }

  export type ClientSolutionListRelationFilter = {
    every?: ClientSolutionWhereInput
    some?: ClientSolutionWhereInput
    none?: ClientSolutionWhereInput
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientSolutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    industry?: SortOrder
    industryCode?: SortOrder
    size?: SortOrder
    revenueBand?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    aiMaturityLevel?: SortOrder
    aiReadinessScore?: SortOrder
    technologyStack?: SortOrder
    lifecycleStage?: SortOrder
    healthScore?: SortOrder
    npsScore?: SortOrder
    accountExecutiveId?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    autoRenewal?: SortOrder
    renewalNoticeDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    aiReadinessScore?: SortOrder
    healthScore?: SortOrder
    npsScore?: SortOrder
    renewalNoticeDays?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    industry?: SortOrder
    industryCode?: SortOrder
    size?: SortOrder
    revenueBand?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    aiMaturityLevel?: SortOrder
    aiReadinessScore?: SortOrder
    lifecycleStage?: SortOrder
    healthScore?: SortOrder
    npsScore?: SortOrder
    accountExecutiveId?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    autoRenewal?: SortOrder
    renewalNoticeDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    industry?: SortOrder
    industryCode?: SortOrder
    size?: SortOrder
    revenueBand?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    aiMaturityLevel?: SortOrder
    aiReadinessScore?: SortOrder
    lifecycleStage?: SortOrder
    healthScore?: SortOrder
    npsScore?: SortOrder
    accountExecutiveId?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    autoRenewal?: SortOrder
    renewalNoticeDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    aiReadinessScore?: SortOrder
    healthScore?: SortOrder
    npsScore?: SortOrder
    renewalNoticeDays?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumClientLifecycleStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientLifecycleStage | EnumClientLifecycleStageFieldRefInput<$PrismaModel>
    in?: $Enums.ClientLifecycleStage[] | ListEnumClientLifecycleStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientLifecycleStage[] | ListEnumClientLifecycleStageFieldRefInput<$PrismaModel>
    not?: NestedEnumClientLifecycleStageWithAggregatesFilter<$PrismaModel> | $Enums.ClientLifecycleStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientLifecycleStageFilter<$PrismaModel>
    _max?: NestedEnumClientLifecycleStageFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ClientRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type AISolutionRelationFilter = {
    is?: AISolutionWhereInput
    isNot?: AISolutionWhereInput
  }

  export type ClientSolutionClientIdSolutionIdCompoundUniqueInput = {
    clientId: string
    solutionId: string
  }

  export type ClientSolutionCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    solutionId?: SortOrder
    deployedAt?: SortOrder
    status?: SortOrder
  }

  export type ClientSolutionMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    solutionId?: SortOrder
    deployedAt?: SortOrder
    status?: SortOrder
  }

  export type ClientSolutionMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    solutionId?: SortOrder
    deployedAt?: SortOrder
    status?: SortOrder
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    jobTitle?: SortOrder
    isDecisionMaker?: SortOrder
    isInfluencer?: SortOrder
    isTechnicalLead?: SortOrder
    isEndUser?: SortOrder
    isBudgetHolder?: SortOrder
    influenceLevel?: SortOrder
    relationshipScore?: SortOrder
    lastInteraction?: SortOrder
    preferredChannel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactAvgOrderByAggregateInput = {
    influenceLevel?: SortOrder
    relationshipScore?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    jobTitle?: SortOrder
    isDecisionMaker?: SortOrder
    isInfluencer?: SortOrder
    isTechnicalLead?: SortOrder
    isEndUser?: SortOrder
    isBudgetHolder?: SortOrder
    influenceLevel?: SortOrder
    relationshipScore?: SortOrder
    lastInteraction?: SortOrder
    preferredChannel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    jobTitle?: SortOrder
    isDecisionMaker?: SortOrder
    isInfluencer?: SortOrder
    isTechnicalLead?: SortOrder
    isEndUser?: SortOrder
    isBudgetHolder?: SortOrder
    influenceLevel?: SortOrder
    relationshipScore?: SortOrder
    lastInteraction?: SortOrder
    preferredChannel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactSumOrderByAggregateInput = {
    influenceLevel?: SortOrder
    relationshipScore?: SortOrder
  }

  export type EnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    ownerId?: SortOrder
    source?: SortOrder
    sourceDetails?: SortOrder
    status?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    industry?: SortOrder
    companySize?: SortOrder
    leadScore?: SortOrder
    scoreTier?: SortOrder
    scoreReason?: SortOrder
    budgetRange?: SortOrder
    timeline?: SortOrder
    needDescription?: SortOrder
    convertedAt?: SortOrder
    lostAt?: SortOrder
    lossReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadAvgOrderByAggregateInput = {
    leadScore?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    ownerId?: SortOrder
    source?: SortOrder
    sourceDetails?: SortOrder
    status?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    industry?: SortOrder
    companySize?: SortOrder
    leadScore?: SortOrder
    scoreTier?: SortOrder
    scoreReason?: SortOrder
    budgetRange?: SortOrder
    timeline?: SortOrder
    needDescription?: SortOrder
    convertedAt?: SortOrder
    lostAt?: SortOrder
    lossReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    ownerId?: SortOrder
    source?: SortOrder
    sourceDetails?: SortOrder
    status?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    industry?: SortOrder
    companySize?: SortOrder
    leadScore?: SortOrder
    scoreTier?: SortOrder
    scoreReason?: SortOrder
    budgetRange?: SortOrder
    timeline?: SortOrder
    needDescription?: SortOrder
    convertedAt?: SortOrder
    lostAt?: SortOrder
    lossReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadSumOrderByAggregateInput = {
    leadScore?: SortOrder
  }

  export type EnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type EnumOpportunityStageFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityStage | EnumOpportunityStageFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityStage[] | ListEnumOpportunityStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityStage[] | ListEnumOpportunityStageFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityStageFilter<$PrismaModel> | $Enums.OpportunityStage
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type LeadNullableRelationFilter = {
    is?: LeadWhereInput | null
    isNot?: LeadWhereInput | null
  }

  export type ProposalListRelationFilter = {
    every?: ProposalWhereInput
    some?: ProposalWhereInput
    none?: ProposalWhereInput
  }

  export type ProjectNullableRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type ProposalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpportunityCountOrderByAggregateInput = {
    id?: SortOrder
    leadId?: SortOrder
    clientId?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    stage?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    actualCloseDate?: SortOrder
    estimatedValue?: SortOrder
    weightedValue?: SortOrder
    nextStep?: SortOrder
    nextStepDate?: SortOrder
    lostReason?: SortOrder
    wonReason?: SortOrder
    solutionType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpportunityAvgOrderByAggregateInput = {
    probability?: SortOrder
    estimatedValue?: SortOrder
    weightedValue?: SortOrder
  }

  export type OpportunityMaxOrderByAggregateInput = {
    id?: SortOrder
    leadId?: SortOrder
    clientId?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    stage?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    actualCloseDate?: SortOrder
    estimatedValue?: SortOrder
    weightedValue?: SortOrder
    nextStep?: SortOrder
    nextStepDate?: SortOrder
    lostReason?: SortOrder
    wonReason?: SortOrder
    solutionType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpportunityMinOrderByAggregateInput = {
    id?: SortOrder
    leadId?: SortOrder
    clientId?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    stage?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    actualCloseDate?: SortOrder
    estimatedValue?: SortOrder
    weightedValue?: SortOrder
    nextStep?: SortOrder
    nextStepDate?: SortOrder
    lostReason?: SortOrder
    wonReason?: SortOrder
    solutionType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpportunitySumOrderByAggregateInput = {
    probability?: SortOrder
    estimatedValue?: SortOrder
    weightedValue?: SortOrder
  }

  export type EnumOpportunityStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityStage | EnumOpportunityStageFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityStage[] | ListEnumOpportunityStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityStage[] | ListEnumOpportunityStageFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityStageWithAggregatesFilter<$PrismaModel> | $Enums.OpportunityStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOpportunityStageFilter<$PrismaModel>
    _max?: NestedEnumOpportunityStageFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type OpportunityRelationFilter = {
    is?: OpportunityWhereInput
    isNot?: OpportunityWhereInput
  }

  export type ProposalCountOrderByAggregateInput = {
    id?: SortOrder
    opportunityId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    content?: SortOrder
    solutionDescription?: SortOrder
    implementationPlan?: SortOrder
    timelineWeeks?: SortOrder
    basePrice?: SortOrder
    discount?: SortOrder
    finalPrice?: SortOrder
    terms?: SortOrder
    status?: SortOrder
    approvalStatus?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    signedAt?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalAvgOrderByAggregateInput = {
    version?: SortOrder
    timelineWeeks?: SortOrder
    basePrice?: SortOrder
    discount?: SortOrder
    finalPrice?: SortOrder
  }

  export type ProposalMaxOrderByAggregateInput = {
    id?: SortOrder
    opportunityId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    solutionDescription?: SortOrder
    implementationPlan?: SortOrder
    timelineWeeks?: SortOrder
    basePrice?: SortOrder
    discount?: SortOrder
    finalPrice?: SortOrder
    terms?: SortOrder
    status?: SortOrder
    approvalStatus?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    signedAt?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalMinOrderByAggregateInput = {
    id?: SortOrder
    opportunityId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    solutionDescription?: SortOrder
    implementationPlan?: SortOrder
    timelineWeeks?: SortOrder
    basePrice?: SortOrder
    discount?: SortOrder
    finalPrice?: SortOrder
    terms?: SortOrder
    status?: SortOrder
    approvalStatus?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    signedAt?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalSumOrderByAggregateInput = {
    version?: SortOrder
    timelineWeeks?: SortOrder
    basePrice?: SortOrder
    discount?: SortOrder
    finalPrice?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type OpportunityNullableRelationFilter = {
    is?: OpportunityWhereInput | null
    isNot?: OpportunityWhereInput | null
  }

  export type ProjectMetricListRelationFilter = {
    every?: ProjectMetricWhereInput
    some?: ProjectMetricWhereInput
    none?: ProjectMetricWhereInput
  }

  export type ProjectMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    opportunityId?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    actualEndDate?: SortOrder
    budget?: SortOrder
    actualCost?: SortOrder
    projectManagerId?: SortOrder
    solutionType?: SortOrder
    healthStatus?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    budget?: SortOrder
    actualCost?: SortOrder
    completionPercentage?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    opportunityId?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    actualEndDate?: SortOrder
    budget?: SortOrder
    actualCost?: SortOrder
    projectManagerId?: SortOrder
    solutionType?: SortOrder
    healthStatus?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    opportunityId?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    actualEndDate?: SortOrder
    budget?: SortOrder
    actualCost?: SortOrder
    projectManagerId?: SortOrder
    solutionType?: SortOrder
    healthStatus?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    budget?: SortOrder
    actualCost?: SortOrder
    completionPercentage?: SortOrder
  }

  export type EnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type EnumMilestoneStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MilestoneStatus | EnumMilestoneStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMilestoneStatusFilter<$PrismaModel> | $Enums.MilestoneStatus
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectMilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    phase?: SortOrder
    order?: SortOrder
    plannedStartDate?: SortOrder
    plannedEndDate?: SortOrder
    actualStartDate?: SortOrder
    actualEndDate?: SortOrder
    completionCriteria?: SortOrder
    ownerId?: SortOrder
    dependsOnId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMilestoneAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ProjectMilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    phase?: SortOrder
    order?: SortOrder
    plannedStartDate?: SortOrder
    plannedEndDate?: SortOrder
    actualStartDate?: SortOrder
    actualEndDate?: SortOrder
    completionCriteria?: SortOrder
    ownerId?: SortOrder
    dependsOnId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    phase?: SortOrder
    order?: SortOrder
    plannedStartDate?: SortOrder
    plannedEndDate?: SortOrder
    actualStartDate?: SortOrder
    actualEndDate?: SortOrder
    completionCriteria?: SortOrder
    ownerId?: SortOrder
    dependsOnId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMilestoneSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumMilestoneStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MilestoneStatus | EnumMilestoneStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMilestoneStatusWithAggregatesFilter<$PrismaModel> | $Enums.MilestoneStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMilestoneStatusFilter<$PrismaModel>
    _max?: NestedEnumMilestoneStatusFilter<$PrismaModel>
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ProjectTaskCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    phase?: SortOrder
    assigneeId?: SortOrder
    parentTaskId?: SortOrder
    plannedHours?: SortOrder
    actualHours?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    blockerReason?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectTaskAvgOrderByAggregateInput = {
    plannedHours?: SortOrder
    actualHours?: SortOrder
    order?: SortOrder
  }

  export type ProjectTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    phase?: SortOrder
    assigneeId?: SortOrder
    parentTaskId?: SortOrder
    plannedHours?: SortOrder
    actualHours?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    blockerReason?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectTaskMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    phase?: SortOrder
    assigneeId?: SortOrder
    parentTaskId?: SortOrder
    plannedHours?: SortOrder
    actualHours?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    blockerReason?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectTaskSumOrderByAggregateInput = {
    plannedHours?: SortOrder
    actualHours?: SortOrder
    order?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ProjectMetricCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    metricName?: SortOrder
    metricCategory?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    baselineValue?: SortOrder
    targetValue?: SortOrder
    recordedAt?: SortOrder
  }

  export type ProjectMetricAvgOrderByAggregateInput = {
    value?: SortOrder
    baselineValue?: SortOrder
    targetValue?: SortOrder
  }

  export type ProjectMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    metricName?: SortOrder
    metricCategory?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    baselineValue?: SortOrder
    targetValue?: SortOrder
    recordedAt?: SortOrder
  }

  export type ProjectMetricMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    metricName?: SortOrder
    metricCategory?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    baselineValue?: SortOrder
    targetValue?: SortOrder
    recordedAt?: SortOrder
  }

  export type ProjectMetricSumOrderByAggregateInput = {
    value?: SortOrder
    baselineValue?: SortOrder
    targetValue?: SortOrder
  }

  export type AISolutionModuleListRelationFilter = {
    every?: AISolutionModuleWhereInput
    some?: AISolutionModuleWhereInput
    none?: AISolutionModuleWhereInput
  }

  export type QuoteListRelationFilter = {
    every?: QuoteWhereInput
    some?: QuoteWhereInput
    none?: QuoteWhereInput
  }

  export type AISolutionModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AISolutionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    tagline?: SortOrder
    longDescription?: SortOrder
    targetIndustries?: SortOrder
    targetFunctions?: SortOrder
    technicalRequirements?: SortOrder
    integrationPoints?: SortOrder
    pricingModels?: SortOrder
    typicalTimelineWeeks?: SortOrder
    useCases?: SortOrder
    caseStudies?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AISolutionAvgOrderByAggregateInput = {
    typicalTimelineWeeks?: SortOrder
    displayOrder?: SortOrder
  }

  export type AISolutionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    tagline?: SortOrder
    longDescription?: SortOrder
    typicalTimelineWeeks?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AISolutionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    tagline?: SortOrder
    longDescription?: SortOrder
    typicalTimelineWeeks?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AISolutionSumOrderByAggregateInput = {
    typicalTimelineWeeks?: SortOrder
    displayOrder?: SortOrder
  }

  export type AISolutionModuleCountOrderByAggregateInput = {
    id?: SortOrder
    solutionId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    isOptional?: SortOrder
  }

  export type AISolutionModuleAvgOrderByAggregateInput = {
    basePrice?: SortOrder
  }

  export type AISolutionModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    solutionId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    isOptional?: SortOrder
  }

  export type AISolutionModuleMinOrderByAggregateInput = {
    id?: SortOrder
    solutionId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    isOptional?: SortOrder
  }

  export type AISolutionModuleSumOrderByAggregateInput = {
    basePrice?: SortOrder
  }

  export type QuoteCountOrderByAggregateInput = {
    id?: SortOrder
    solutionId?: SortOrder
    clientId?: SortOrder
    quoteNumber?: SortOrder
    version?: SortOrder
    status?: SortOrder
    scope?: SortOrder
    timelineWeeks?: SortOrder
    totalPrice?: SortOrder
    validUntil?: SortOrder
    requestedBy?: SortOrder
    requestedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteAvgOrderByAggregateInput = {
    version?: SortOrder
    timelineWeeks?: SortOrder
    totalPrice?: SortOrder
  }

  export type QuoteMaxOrderByAggregateInput = {
    id?: SortOrder
    solutionId?: SortOrder
    clientId?: SortOrder
    quoteNumber?: SortOrder
    version?: SortOrder
    status?: SortOrder
    scope?: SortOrder
    timelineWeeks?: SortOrder
    totalPrice?: SortOrder
    validUntil?: SortOrder
    requestedBy?: SortOrder
    requestedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteMinOrderByAggregateInput = {
    id?: SortOrder
    solutionId?: SortOrder
    clientId?: SortOrder
    quoteNumber?: SortOrder
    version?: SortOrder
    status?: SortOrder
    scope?: SortOrder
    timelineWeeks?: SortOrder
    totalPrice?: SortOrder
    validUntil?: SortOrder
    requestedBy?: SortOrder
    requestedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteSumOrderByAggregateInput = {
    version?: SortOrder
    timelineWeeks?: SortOrder
    totalPrice?: SortOrder
  }

  export type ContactNullableRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    leadId?: SortOrder
    opportunityId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    durationMinutes?: SortOrder
    outcome?: SortOrder
    sentiment?: SortOrder
    keyTopics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityAvgOrderByAggregateInput = {
    durationMinutes?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    leadId?: SortOrder
    opportunityId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    durationMinutes?: SortOrder
    outcome?: SortOrder
    sentiment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    leadId?: SortOrder
    opportunityId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    durationMinutes?: SortOrder
    outcome?: SortOrder
    sentiment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivitySumOrderByAggregateInput = {
    durationMinutes?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    milestoneId?: SortOrder
    type?: SortOrder
    rating?: SortOrder
    comments?: SortOrder
    deliveredOnTime?: SortOrder
    metExpectations?: SortOrder
    wouldRecommend?: SortOrder
    responderName?: SortOrder
    responderEmail?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    milestoneId?: SortOrder
    type?: SortOrder
    rating?: SortOrder
    comments?: SortOrder
    deliveredOnTime?: SortOrder
    metExpectations?: SortOrder
    wouldRecommend?: SortOrder
    responderName?: SortOrder
    responderEmail?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    milestoneId?: SortOrder
    type?: SortOrder
    rating?: SortOrder
    comments?: SortOrder
    deliveredOnTime?: SortOrder
    metExpectations?: SortOrder
    wouldRecommend?: SortOrder
    responderName?: SortOrder
    responderEmail?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumTicketTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketTypeFilter<$PrismaModel> | $Enums.TicketType
  }

  export type EnumTicketSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketSeverity | EnumTicketSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketSeverity[] | ListEnumTicketSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketSeverity[] | ListEnumTicketSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketSeverityFilter<$PrismaModel> | $Enums.TicketSeverity
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type TicketCommentListRelationFilter = {
    every?: TicketCommentWhereInput
    some?: TicketCommentWhereInput
    none?: TicketCommentWhereInput
  }

  export type TicketCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    assigneeId?: SortOrder
    ticketNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    resolution?: SortOrder
    rootCause?: SortOrder
    slaResponseDue?: SortOrder
    slaResolutionDue?: SortOrder
    respondedAt?: SortOrder
    resolvedAt?: SortOrder
    closedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    assigneeId?: SortOrder
    ticketNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    resolution?: SortOrder
    rootCause?: SortOrder
    slaResponseDue?: SortOrder
    slaResolutionDue?: SortOrder
    respondedAt?: SortOrder
    resolvedAt?: SortOrder
    closedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    assigneeId?: SortOrder
    ticketNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    resolution?: SortOrder
    rootCause?: SortOrder
    slaResponseDue?: SortOrder
    slaResolutionDue?: SortOrder
    respondedAt?: SortOrder
    resolvedAt?: SortOrder
    closedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTicketTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketTypeWithAggregatesFilter<$PrismaModel> | $Enums.TicketType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketTypeFilter<$PrismaModel>
    _max?: NestedEnumTicketTypeFilter<$PrismaModel>
  }

  export type EnumTicketSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketSeverity | EnumTicketSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketSeverity[] | ListEnumTicketSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketSeverity[] | ListEnumTicketSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketSeverityWithAggregatesFilter<$PrismaModel> | $Enums.TicketSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketSeverityFilter<$PrismaModel>
    _max?: NestedEnumTicketSeverityFilter<$PrismaModel>
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type TicketRelationFilter = {
    is?: TicketWhereInput
    isNot?: TicketWhereInput
  }

  export type TicketCommentCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketCommentMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientCreateNestedOneWithoutUsersInput = {
    create?: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUsersInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSubordinatesInput = {
    create?: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubordinatesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutManagedByInput = {
    create?: XOR<UserCreateWithoutManagedByInput, UserUncheckedCreateWithoutManagedByInput> | UserCreateWithoutManagedByInput[] | UserUncheckedCreateWithoutManagedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagedByInput | UserCreateOrConnectWithoutManagedByInput[]
    createMany?: UserCreateManyManagedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutOwnerInput = {
    create?: XOR<LeadCreateWithoutOwnerInput, LeadUncheckedCreateWithoutOwnerInput> | LeadCreateWithoutOwnerInput[] | LeadUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOwnerInput | LeadCreateOrConnectWithoutOwnerInput[]
    createMany?: LeadCreateManyOwnerInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type OpportunityCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OpportunityCreateWithoutOwnerInput, OpportunityUncheckedCreateWithoutOwnerInput> | OpportunityCreateWithoutOwnerInput[] | OpportunityUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutOwnerInput | OpportunityCreateOrConnectWithoutOwnerInput[]
    createMany?: OpportunityCreateManyOwnerInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ActivityCreateWithoutOwnerInput, ActivityUncheckedCreateWithoutOwnerInput> | ActivityCreateWithoutOwnerInput[] | ActivityUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOwnerInput | ActivityCreateOrConnectWithoutOwnerInput[]
    createMany?: ActivityCreateManyOwnerInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ProjectTaskCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<ProjectTaskCreateWithoutAssigneeInput, ProjectTaskUncheckedCreateWithoutAssigneeInput> | ProjectTaskCreateWithoutAssigneeInput[] | ProjectTaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: ProjectTaskCreateOrConnectWithoutAssigneeInput | ProjectTaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: ProjectTaskCreateManyAssigneeInputEnvelope
    connect?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
  }

  export type ProjectMilestoneCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ProjectMilestoneCreateWithoutOwnerInput, ProjectMilestoneUncheckedCreateWithoutOwnerInput> | ProjectMilestoneCreateWithoutOwnerInput[] | ProjectMilestoneUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectMilestoneCreateOrConnectWithoutOwnerInput | ProjectMilestoneCreateOrConnectWithoutOwnerInput[]
    createMany?: ProjectMilestoneCreateManyOwnerInputEnvelope
    connect?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<TicketCreateWithoutAssigneeInput, TicketUncheckedCreateWithoutAssigneeInput> | TicketCreateWithoutAssigneeInput[] | TicketUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssigneeInput | TicketCreateOrConnectWithoutAssigneeInput[]
    createMany?: TicketCreateManyAssigneeInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutManagedByInput = {
    create?: XOR<UserCreateWithoutManagedByInput, UserUncheckedCreateWithoutManagedByInput> | UserCreateWithoutManagedByInput[] | UserUncheckedCreateWithoutManagedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagedByInput | UserCreateOrConnectWithoutManagedByInput[]
    createMany?: UserCreateManyManagedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<LeadCreateWithoutOwnerInput, LeadUncheckedCreateWithoutOwnerInput> | LeadCreateWithoutOwnerInput[] | LeadUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOwnerInput | LeadCreateOrConnectWithoutOwnerInput[]
    createMany?: LeadCreateManyOwnerInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type OpportunityUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OpportunityCreateWithoutOwnerInput, OpportunityUncheckedCreateWithoutOwnerInput> | OpportunityCreateWithoutOwnerInput[] | OpportunityUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutOwnerInput | OpportunityCreateOrConnectWithoutOwnerInput[]
    createMany?: OpportunityCreateManyOwnerInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ActivityCreateWithoutOwnerInput, ActivityUncheckedCreateWithoutOwnerInput> | ActivityCreateWithoutOwnerInput[] | ActivityUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOwnerInput | ActivityCreateOrConnectWithoutOwnerInput[]
    createMany?: ActivityCreateManyOwnerInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ProjectTaskUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<ProjectTaskCreateWithoutAssigneeInput, ProjectTaskUncheckedCreateWithoutAssigneeInput> | ProjectTaskCreateWithoutAssigneeInput[] | ProjectTaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: ProjectTaskCreateOrConnectWithoutAssigneeInput | ProjectTaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: ProjectTaskCreateManyAssigneeInputEnvelope
    connect?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
  }

  export type ProjectMilestoneUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ProjectMilestoneCreateWithoutOwnerInput, ProjectMilestoneUncheckedCreateWithoutOwnerInput> | ProjectMilestoneCreateWithoutOwnerInput[] | ProjectMilestoneUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectMilestoneCreateOrConnectWithoutOwnerInput | ProjectMilestoneCreateOrConnectWithoutOwnerInput[]
    createMany?: ProjectMilestoneCreateManyOwnerInputEnvelope
    connect?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<TicketCreateWithoutAssigneeInput, TicketUncheckedCreateWithoutAssigneeInput> | TicketCreateWithoutAssigneeInput[] | TicketUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssigneeInput | TicketCreateOrConnectWithoutAssigneeInput[]
    createMany?: TicketCreateManyAssigneeInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ClientUpdateOneWithoutUsersNestedInput = {
    create?: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUsersInput
    upsert?: ClientUpsertWithoutUsersInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUsersInput, ClientUpdateWithoutUsersInput>, ClientUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneWithoutSubordinatesNestedInput = {
    create?: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubordinatesInput
    upsert?: UserUpsertWithoutSubordinatesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubordinatesInput, UserUpdateWithoutSubordinatesInput>, UserUncheckedUpdateWithoutSubordinatesInput>
  }

  export type UserUpdateManyWithoutManagedByNestedInput = {
    create?: XOR<UserCreateWithoutManagedByInput, UserUncheckedCreateWithoutManagedByInput> | UserCreateWithoutManagedByInput[] | UserUncheckedCreateWithoutManagedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagedByInput | UserCreateOrConnectWithoutManagedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutManagedByInput | UserUpsertWithWhereUniqueWithoutManagedByInput[]
    createMany?: UserCreateManyManagedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutManagedByInput | UserUpdateWithWhereUniqueWithoutManagedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutManagedByInput | UserUpdateManyWithWhereWithoutManagedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<LeadCreateWithoutOwnerInput, LeadUncheckedCreateWithoutOwnerInput> | LeadCreateWithoutOwnerInput[] | LeadUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOwnerInput | LeadCreateOrConnectWithoutOwnerInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutOwnerInput | LeadUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: LeadCreateManyOwnerInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutOwnerInput | LeadUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutOwnerInput | LeadUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type OpportunityUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OpportunityCreateWithoutOwnerInput, OpportunityUncheckedCreateWithoutOwnerInput> | OpportunityCreateWithoutOwnerInput[] | OpportunityUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutOwnerInput | OpportunityCreateOrConnectWithoutOwnerInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutOwnerInput | OpportunityUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OpportunityCreateManyOwnerInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutOwnerInput | OpportunityUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutOwnerInput | OpportunityUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ActivityCreateWithoutOwnerInput, ActivityUncheckedCreateWithoutOwnerInput> | ActivityCreateWithoutOwnerInput[] | ActivityUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOwnerInput | ActivityCreateOrConnectWithoutOwnerInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutOwnerInput | ActivityUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ActivityCreateManyOwnerInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutOwnerInput | ActivityUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutOwnerInput | ActivityUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ProjectTaskUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<ProjectTaskCreateWithoutAssigneeInput, ProjectTaskUncheckedCreateWithoutAssigneeInput> | ProjectTaskCreateWithoutAssigneeInput[] | ProjectTaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: ProjectTaskCreateOrConnectWithoutAssigneeInput | ProjectTaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: ProjectTaskUpsertWithWhereUniqueWithoutAssigneeInput | ProjectTaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: ProjectTaskCreateManyAssigneeInputEnvelope
    set?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
    disconnect?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
    delete?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
    connect?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
    update?: ProjectTaskUpdateWithWhereUniqueWithoutAssigneeInput | ProjectTaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: ProjectTaskUpdateManyWithWhereWithoutAssigneeInput | ProjectTaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: ProjectTaskScalarWhereInput | ProjectTaskScalarWhereInput[]
  }

  export type ProjectMilestoneUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ProjectMilestoneCreateWithoutOwnerInput, ProjectMilestoneUncheckedCreateWithoutOwnerInput> | ProjectMilestoneCreateWithoutOwnerInput[] | ProjectMilestoneUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectMilestoneCreateOrConnectWithoutOwnerInput | ProjectMilestoneCreateOrConnectWithoutOwnerInput[]
    upsert?: ProjectMilestoneUpsertWithWhereUniqueWithoutOwnerInput | ProjectMilestoneUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ProjectMilestoneCreateManyOwnerInputEnvelope
    set?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
    disconnect?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
    delete?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
    connect?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
    update?: ProjectMilestoneUpdateWithWhereUniqueWithoutOwnerInput | ProjectMilestoneUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ProjectMilestoneUpdateManyWithWhereWithoutOwnerInput | ProjectMilestoneUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ProjectMilestoneScalarWhereInput | ProjectMilestoneScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<TicketCreateWithoutAssigneeInput, TicketUncheckedCreateWithoutAssigneeInput> | TicketCreateWithoutAssigneeInput[] | TicketUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssigneeInput | TicketCreateOrConnectWithoutAssigneeInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAssigneeInput | TicketUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: TicketCreateManyAssigneeInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAssigneeInput | TicketUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAssigneeInput | TicketUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUncheckedUpdateManyWithoutManagedByNestedInput = {
    create?: XOR<UserCreateWithoutManagedByInput, UserUncheckedCreateWithoutManagedByInput> | UserCreateWithoutManagedByInput[] | UserUncheckedCreateWithoutManagedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagedByInput | UserCreateOrConnectWithoutManagedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutManagedByInput | UserUpsertWithWhereUniqueWithoutManagedByInput[]
    createMany?: UserCreateManyManagedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutManagedByInput | UserUpdateWithWhereUniqueWithoutManagedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutManagedByInput | UserUpdateManyWithWhereWithoutManagedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<LeadCreateWithoutOwnerInput, LeadUncheckedCreateWithoutOwnerInput> | LeadCreateWithoutOwnerInput[] | LeadUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOwnerInput | LeadCreateOrConnectWithoutOwnerInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutOwnerInput | LeadUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: LeadCreateManyOwnerInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutOwnerInput | LeadUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutOwnerInput | LeadUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type OpportunityUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OpportunityCreateWithoutOwnerInput, OpportunityUncheckedCreateWithoutOwnerInput> | OpportunityCreateWithoutOwnerInput[] | OpportunityUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutOwnerInput | OpportunityCreateOrConnectWithoutOwnerInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutOwnerInput | OpportunityUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OpportunityCreateManyOwnerInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutOwnerInput | OpportunityUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutOwnerInput | OpportunityUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ActivityCreateWithoutOwnerInput, ActivityUncheckedCreateWithoutOwnerInput> | ActivityCreateWithoutOwnerInput[] | ActivityUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOwnerInput | ActivityCreateOrConnectWithoutOwnerInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutOwnerInput | ActivityUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ActivityCreateManyOwnerInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutOwnerInput | ActivityUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutOwnerInput | ActivityUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ProjectTaskUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<ProjectTaskCreateWithoutAssigneeInput, ProjectTaskUncheckedCreateWithoutAssigneeInput> | ProjectTaskCreateWithoutAssigneeInput[] | ProjectTaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: ProjectTaskCreateOrConnectWithoutAssigneeInput | ProjectTaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: ProjectTaskUpsertWithWhereUniqueWithoutAssigneeInput | ProjectTaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: ProjectTaskCreateManyAssigneeInputEnvelope
    set?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
    disconnect?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
    delete?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
    connect?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
    update?: ProjectTaskUpdateWithWhereUniqueWithoutAssigneeInput | ProjectTaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: ProjectTaskUpdateManyWithWhereWithoutAssigneeInput | ProjectTaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: ProjectTaskScalarWhereInput | ProjectTaskScalarWhereInput[]
  }

  export type ProjectMilestoneUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ProjectMilestoneCreateWithoutOwnerInput, ProjectMilestoneUncheckedCreateWithoutOwnerInput> | ProjectMilestoneCreateWithoutOwnerInput[] | ProjectMilestoneUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectMilestoneCreateOrConnectWithoutOwnerInput | ProjectMilestoneCreateOrConnectWithoutOwnerInput[]
    upsert?: ProjectMilestoneUpsertWithWhereUniqueWithoutOwnerInput | ProjectMilestoneUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ProjectMilestoneCreateManyOwnerInputEnvelope
    set?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
    disconnect?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
    delete?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
    connect?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
    update?: ProjectMilestoneUpdateWithWhereUniqueWithoutOwnerInput | ProjectMilestoneUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ProjectMilestoneUpdateManyWithWhereWithoutOwnerInput | ProjectMilestoneUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ProjectMilestoneScalarWhereInput | ProjectMilestoneScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<TicketCreateWithoutAssigneeInput, TicketUncheckedCreateWithoutAssigneeInput> | TicketCreateWithoutAssigneeInput[] | TicketUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssigneeInput | TicketCreateOrConnectWithoutAssigneeInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAssigneeInput | TicketUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: TicketCreateManyAssigneeInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAssigneeInput | TicketUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAssigneeInput | TicketUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ClientCreatetechnologyStackInput = {
    set: string[]
  }

  export type ContactCreateNestedManyWithoutClientInput = {
    create?: XOR<ContactCreateWithoutClientInput, ContactUncheckedCreateWithoutClientInput> | ContactCreateWithoutClientInput[] | ContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutClientInput | ContactCreateOrConnectWithoutClientInput[]
    createMany?: ContactCreateManyClientInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutClientInput = {
    create?: XOR<LeadCreateWithoutClientInput, LeadUncheckedCreateWithoutClientInput> | LeadCreateWithoutClientInput[] | LeadUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutClientInput | LeadCreateOrConnectWithoutClientInput[]
    createMany?: LeadCreateManyClientInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type OpportunityCreateNestedManyWithoutClientInput = {
    create?: XOR<OpportunityCreateWithoutClientInput, OpportunityUncheckedCreateWithoutClientInput> | OpportunityCreateWithoutClientInput[] | OpportunityUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutClientInput | OpportunityCreateOrConnectWithoutClientInput[]
    createMany?: OpportunityCreateManyClientInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutClientInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutClientInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutClientInput = {
    create?: XOR<FeedbackCreateWithoutClientInput, FeedbackUncheckedCreateWithoutClientInput> | FeedbackCreateWithoutClientInput[] | FeedbackUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutClientInput | FeedbackCreateOrConnectWithoutClientInput[]
    createMany?: FeedbackCreateManyClientInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type ClientSolutionCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientSolutionCreateWithoutClientInput, ClientSolutionUncheckedCreateWithoutClientInput> | ClientSolutionCreateWithoutClientInput[] | ClientSolutionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientSolutionCreateOrConnectWithoutClientInput | ClientSolutionCreateOrConnectWithoutClientInput[]
    createMany?: ClientSolutionCreateManyClientInputEnvelope
    connect?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ContactCreateWithoutClientInput, ContactUncheckedCreateWithoutClientInput> | ContactCreateWithoutClientInput[] | ContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutClientInput | ContactCreateOrConnectWithoutClientInput[]
    createMany?: ContactCreateManyClientInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<LeadCreateWithoutClientInput, LeadUncheckedCreateWithoutClientInput> | LeadCreateWithoutClientInput[] | LeadUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutClientInput | LeadCreateOrConnectWithoutClientInput[]
    createMany?: LeadCreateManyClientInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type OpportunityUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<OpportunityCreateWithoutClientInput, OpportunityUncheckedCreateWithoutClientInput> | OpportunityCreateWithoutClientInput[] | OpportunityUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutClientInput | OpportunityCreateOrConnectWithoutClientInput[]
    createMany?: OpportunityCreateManyClientInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<FeedbackCreateWithoutClientInput, FeedbackUncheckedCreateWithoutClientInput> | FeedbackCreateWithoutClientInput[] | FeedbackUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutClientInput | FeedbackCreateOrConnectWithoutClientInput[]
    createMany?: FeedbackCreateManyClientInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type ClientSolutionUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientSolutionCreateWithoutClientInput, ClientSolutionUncheckedCreateWithoutClientInput> | ClientSolutionCreateWithoutClientInput[] | ClientSolutionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientSolutionCreateOrConnectWithoutClientInput | ClientSolutionCreateOrConnectWithoutClientInput[]
    createMany?: ClientSolutionCreateManyClientInputEnvelope
    connect?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClientUpdatetechnologyStackInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumClientLifecycleStageFieldUpdateOperationsInput = {
    set?: $Enums.ClientLifecycleStage
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ContactUpdateManyWithoutClientNestedInput = {
    create?: XOR<ContactCreateWithoutClientInput, ContactUncheckedCreateWithoutClientInput> | ContactCreateWithoutClientInput[] | ContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutClientInput | ContactCreateOrConnectWithoutClientInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutClientInput | ContactUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ContactCreateManyClientInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutClientInput | ContactUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutClientInput | ContactUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutClientNestedInput = {
    create?: XOR<LeadCreateWithoutClientInput, LeadUncheckedCreateWithoutClientInput> | LeadCreateWithoutClientInput[] | LeadUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutClientInput | LeadCreateOrConnectWithoutClientInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutClientInput | LeadUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: LeadCreateManyClientInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutClientInput | LeadUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutClientInput | LeadUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type OpportunityUpdateManyWithoutClientNestedInput = {
    create?: XOR<OpportunityCreateWithoutClientInput, OpportunityUncheckedCreateWithoutClientInput> | OpportunityCreateWithoutClientInput[] | OpportunityUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutClientInput | OpportunityCreateOrConnectWithoutClientInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutClientInput | OpportunityUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OpportunityCreateManyClientInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutClientInput | OpportunityUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutClientInput | OpportunityUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutClientInput | ProjectUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutClientInput | ProjectUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutClientInput | ProjectUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutClientNestedInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutClientInput | TicketUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutClientInput | TicketUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutClientInput | TicketUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutClientNestedInput = {
    create?: XOR<FeedbackCreateWithoutClientInput, FeedbackUncheckedCreateWithoutClientInput> | FeedbackCreateWithoutClientInput[] | FeedbackUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutClientInput | FeedbackCreateOrConnectWithoutClientInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutClientInput | FeedbackUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: FeedbackCreateManyClientInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutClientInput | FeedbackUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutClientInput | FeedbackUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type ClientSolutionUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientSolutionCreateWithoutClientInput, ClientSolutionUncheckedCreateWithoutClientInput> | ClientSolutionCreateWithoutClientInput[] | ClientSolutionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientSolutionCreateOrConnectWithoutClientInput | ClientSolutionCreateOrConnectWithoutClientInput[]
    upsert?: ClientSolutionUpsertWithWhereUniqueWithoutClientInput | ClientSolutionUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientSolutionCreateManyClientInputEnvelope
    set?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
    disconnect?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
    delete?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
    connect?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
    update?: ClientSolutionUpdateWithWhereUniqueWithoutClientInput | ClientSolutionUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientSolutionUpdateManyWithWhereWithoutClientInput | ClientSolutionUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientSolutionScalarWhereInput | ClientSolutionScalarWhereInput[]
  }

  export type UserUpdateManyWithoutClientNestedInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutClientInput | UserUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutClientInput | UserUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: UserUpdateManyWithWhereWithoutClientInput | UserUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ContactCreateWithoutClientInput, ContactUncheckedCreateWithoutClientInput> | ContactCreateWithoutClientInput[] | ContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutClientInput | ContactCreateOrConnectWithoutClientInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutClientInput | ContactUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ContactCreateManyClientInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutClientInput | ContactUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutClientInput | ContactUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<LeadCreateWithoutClientInput, LeadUncheckedCreateWithoutClientInput> | LeadCreateWithoutClientInput[] | LeadUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutClientInput | LeadCreateOrConnectWithoutClientInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutClientInput | LeadUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: LeadCreateManyClientInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutClientInput | LeadUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutClientInput | LeadUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type OpportunityUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<OpportunityCreateWithoutClientInput, OpportunityUncheckedCreateWithoutClientInput> | OpportunityCreateWithoutClientInput[] | OpportunityUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutClientInput | OpportunityCreateOrConnectWithoutClientInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutClientInput | OpportunityUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OpportunityCreateManyClientInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutClientInput | OpportunityUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutClientInput | OpportunityUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutClientInput | ProjectUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutClientInput | ProjectUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutClientInput | ProjectUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutClientInput | TicketUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutClientInput | TicketUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutClientInput | TicketUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<FeedbackCreateWithoutClientInput, FeedbackUncheckedCreateWithoutClientInput> | FeedbackCreateWithoutClientInput[] | FeedbackUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutClientInput | FeedbackCreateOrConnectWithoutClientInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutClientInput | FeedbackUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: FeedbackCreateManyClientInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutClientInput | FeedbackUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutClientInput | FeedbackUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type ClientSolutionUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientSolutionCreateWithoutClientInput, ClientSolutionUncheckedCreateWithoutClientInput> | ClientSolutionCreateWithoutClientInput[] | ClientSolutionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientSolutionCreateOrConnectWithoutClientInput | ClientSolutionCreateOrConnectWithoutClientInput[]
    upsert?: ClientSolutionUpsertWithWhereUniqueWithoutClientInput | ClientSolutionUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientSolutionCreateManyClientInputEnvelope
    set?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
    disconnect?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
    delete?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
    connect?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
    update?: ClientSolutionUpdateWithWhereUniqueWithoutClientInput | ClientSolutionUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientSolutionUpdateManyWithWhereWithoutClientInput | ClientSolutionUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientSolutionScalarWhereInput | ClientSolutionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutClientInput | UserUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutClientInput | UserUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: UserUpdateManyWithWhereWithoutClientInput | UserUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutAiSolutionsInput = {
    create?: XOR<ClientCreateWithoutAiSolutionsInput, ClientUncheckedCreateWithoutAiSolutionsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAiSolutionsInput
    connect?: ClientWhereUniqueInput
  }

  export type AISolutionCreateNestedOneWithoutClientSolutionsInput = {
    create?: XOR<AISolutionCreateWithoutClientSolutionsInput, AISolutionUncheckedCreateWithoutClientSolutionsInput>
    connectOrCreate?: AISolutionCreateOrConnectWithoutClientSolutionsInput
    connect?: AISolutionWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutAiSolutionsNestedInput = {
    create?: XOR<ClientCreateWithoutAiSolutionsInput, ClientUncheckedCreateWithoutAiSolutionsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAiSolutionsInput
    upsert?: ClientUpsertWithoutAiSolutionsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutAiSolutionsInput, ClientUpdateWithoutAiSolutionsInput>, ClientUncheckedUpdateWithoutAiSolutionsInput>
  }

  export type AISolutionUpdateOneRequiredWithoutClientSolutionsNestedInput = {
    create?: XOR<AISolutionCreateWithoutClientSolutionsInput, AISolutionUncheckedCreateWithoutClientSolutionsInput>
    connectOrCreate?: AISolutionCreateOrConnectWithoutClientSolutionsInput
    upsert?: AISolutionUpsertWithoutClientSolutionsInput
    connect?: AISolutionWhereUniqueInput
    update?: XOR<XOR<AISolutionUpdateToOneWithWhereWithoutClientSolutionsInput, AISolutionUpdateWithoutClientSolutionsInput>, AISolutionUncheckedUpdateWithoutClientSolutionsInput>
  }

  export type ClientCreateNestedOneWithoutContactsInput = {
    create?: XOR<ClientCreateWithoutContactsInput, ClientUncheckedCreateWithoutContactsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutContactsInput
    connect?: ClientWhereUniqueInput
  }

  export type ActivityCreateNestedManyWithoutContactInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ClientUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<ClientCreateWithoutContactsInput, ClientUncheckedCreateWithoutContactsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutContactsInput
    upsert?: ClientUpsertWithoutContactsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutContactsInput, ClientUpdateWithoutContactsInput>, ClientUncheckedUpdateWithoutContactsInput>
  }

  export type ActivityUpdateManyWithoutContactNestedInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutContactInput | ActivityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutContactInput | ActivityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutContactInput | ActivityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutContactInput | ActivityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutContactInput | ActivityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutContactInput | ActivityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutLeadsInput = {
    create?: XOR<ClientCreateWithoutLeadsInput, ClientUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutLeadsInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLeadsInput = {
    create?: XOR<UserCreateWithoutLeadsInput, UserUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeadsInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityCreateNestedManyWithoutLeadInput = {
    create?: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput> | ActivityCreateWithoutLeadInput[] | ActivityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutLeadInput | ActivityCreateOrConnectWithoutLeadInput[]
    createMany?: ActivityCreateManyLeadInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type OpportunityCreateNestedManyWithoutLeadInput = {
    create?: XOR<OpportunityCreateWithoutLeadInput, OpportunityUncheckedCreateWithoutLeadInput> | OpportunityCreateWithoutLeadInput[] | OpportunityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutLeadInput | OpportunityCreateOrConnectWithoutLeadInput[]
    createMany?: OpportunityCreateManyLeadInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput> | ActivityCreateWithoutLeadInput[] | ActivityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutLeadInput | ActivityCreateOrConnectWithoutLeadInput[]
    createMany?: ActivityCreateManyLeadInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type OpportunityUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<OpportunityCreateWithoutLeadInput, OpportunityUncheckedCreateWithoutLeadInput> | OpportunityCreateWithoutLeadInput[] | OpportunityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutLeadInput | OpportunityCreateOrConnectWithoutLeadInput[]
    createMany?: OpportunityCreateManyLeadInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type EnumLeadStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeadStatus
  }

  export type ClientUpdateOneWithoutLeadsNestedInput = {
    create?: XOR<ClientCreateWithoutLeadsInput, ClientUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutLeadsInput
    upsert?: ClientUpsertWithoutLeadsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutLeadsInput, ClientUpdateWithoutLeadsInput>, ClientUncheckedUpdateWithoutLeadsInput>
  }

  export type UserUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<UserCreateWithoutLeadsInput, UserUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeadsInput
    upsert?: UserUpsertWithoutLeadsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeadsInput, UserUpdateWithoutLeadsInput>, UserUncheckedUpdateWithoutLeadsInput>
  }

  export type ActivityUpdateManyWithoutLeadNestedInput = {
    create?: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput> | ActivityCreateWithoutLeadInput[] | ActivityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutLeadInput | ActivityCreateOrConnectWithoutLeadInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutLeadInput | ActivityUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: ActivityCreateManyLeadInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutLeadInput | ActivityUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutLeadInput | ActivityUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type OpportunityUpdateManyWithoutLeadNestedInput = {
    create?: XOR<OpportunityCreateWithoutLeadInput, OpportunityUncheckedCreateWithoutLeadInput> | OpportunityCreateWithoutLeadInput[] | OpportunityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutLeadInput | OpportunityCreateOrConnectWithoutLeadInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutLeadInput | OpportunityUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: OpportunityCreateManyLeadInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutLeadInput | OpportunityUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutLeadInput | OpportunityUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput> | ActivityCreateWithoutLeadInput[] | ActivityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutLeadInput | ActivityCreateOrConnectWithoutLeadInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutLeadInput | ActivityUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: ActivityCreateManyLeadInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutLeadInput | ActivityUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutLeadInput | ActivityUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type OpportunityUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<OpportunityCreateWithoutLeadInput, OpportunityUncheckedCreateWithoutLeadInput> | OpportunityCreateWithoutLeadInput[] | OpportunityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutLeadInput | OpportunityCreateOrConnectWithoutLeadInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutLeadInput | OpportunityUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: OpportunityCreateManyLeadInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutLeadInput | OpportunityUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutLeadInput | OpportunityUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type LeadCreateNestedOneWithoutOpportunitiesInput = {
    create?: XOR<LeadCreateWithoutOpportunitiesInput, LeadUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: LeadCreateOrConnectWithoutOpportunitiesInput
    connect?: LeadWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutOpportunitiesInput = {
    create?: XOR<ClientCreateWithoutOpportunitiesInput, ClientUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutOpportunitiesInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOpportunitiesInput = {
    create?: XOR<UserCreateWithoutOpportunitiesInput, UserUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOpportunitiesInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<ActivityCreateWithoutOpportunityInput, ActivityUncheckedCreateWithoutOpportunityInput> | ActivityCreateWithoutOpportunityInput[] | ActivityUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOpportunityInput | ActivityCreateOrConnectWithoutOpportunityInput[]
    createMany?: ActivityCreateManyOpportunityInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ProposalCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<ProposalCreateWithoutOpportunityInput, ProposalUncheckedCreateWithoutOpportunityInput> | ProposalCreateWithoutOpportunityInput[] | ProposalUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutOpportunityInput | ProposalCreateOrConnectWithoutOpportunityInput[]
    createMany?: ProposalCreateManyOpportunityInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type ProjectCreateNestedOneWithoutOpportunityInput = {
    create?: XOR<ProjectCreateWithoutOpportunityInput, ProjectUncheckedCreateWithoutOpportunityInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutOpportunityInput
    connect?: ProjectWhereUniqueInput
  }

  export type ActivityUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<ActivityCreateWithoutOpportunityInput, ActivityUncheckedCreateWithoutOpportunityInput> | ActivityCreateWithoutOpportunityInput[] | ActivityUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOpportunityInput | ActivityCreateOrConnectWithoutOpportunityInput[]
    createMany?: ActivityCreateManyOpportunityInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ProposalUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<ProposalCreateWithoutOpportunityInput, ProposalUncheckedCreateWithoutOpportunityInput> | ProposalCreateWithoutOpportunityInput[] | ProposalUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutOpportunityInput | ProposalCreateOrConnectWithoutOpportunityInput[]
    createMany?: ProposalCreateManyOpportunityInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedOneWithoutOpportunityInput = {
    create?: XOR<ProjectCreateWithoutOpportunityInput, ProjectUncheckedCreateWithoutOpportunityInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutOpportunityInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumOpportunityStageFieldUpdateOperationsInput = {
    set?: $Enums.OpportunityStage
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LeadUpdateOneWithoutOpportunitiesNestedInput = {
    create?: XOR<LeadCreateWithoutOpportunitiesInput, LeadUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: LeadCreateOrConnectWithoutOpportunitiesInput
    upsert?: LeadUpsertWithoutOpportunitiesInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutOpportunitiesInput, LeadUpdateWithoutOpportunitiesInput>, LeadUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type ClientUpdateOneWithoutOpportunitiesNestedInput = {
    create?: XOR<ClientCreateWithoutOpportunitiesInput, ClientUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutOpportunitiesInput
    upsert?: ClientUpsertWithoutOpportunitiesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutOpportunitiesInput, ClientUpdateWithoutOpportunitiesInput>, ClientUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type UserUpdateOneRequiredWithoutOpportunitiesNestedInput = {
    create?: XOR<UserCreateWithoutOpportunitiesInput, UserUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOpportunitiesInput
    upsert?: UserUpsertWithoutOpportunitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOpportunitiesInput, UserUpdateWithoutOpportunitiesInput>, UserUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type ActivityUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<ActivityCreateWithoutOpportunityInput, ActivityUncheckedCreateWithoutOpportunityInput> | ActivityCreateWithoutOpportunityInput[] | ActivityUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOpportunityInput | ActivityCreateOrConnectWithoutOpportunityInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutOpportunityInput | ActivityUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: ActivityCreateManyOpportunityInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutOpportunityInput | ActivityUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutOpportunityInput | ActivityUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ProposalUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<ProposalCreateWithoutOpportunityInput, ProposalUncheckedCreateWithoutOpportunityInput> | ProposalCreateWithoutOpportunityInput[] | ProposalUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutOpportunityInput | ProposalCreateOrConnectWithoutOpportunityInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutOpportunityInput | ProposalUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: ProposalCreateManyOpportunityInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutOpportunityInput | ProposalUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutOpportunityInput | ProposalUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type ProjectUpdateOneWithoutOpportunityNestedInput = {
    create?: XOR<ProjectCreateWithoutOpportunityInput, ProjectUncheckedCreateWithoutOpportunityInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutOpportunityInput
    upsert?: ProjectUpsertWithoutOpportunityInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutOpportunityInput, ProjectUpdateWithoutOpportunityInput>, ProjectUncheckedUpdateWithoutOpportunityInput>
  }

  export type ActivityUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<ActivityCreateWithoutOpportunityInput, ActivityUncheckedCreateWithoutOpportunityInput> | ActivityCreateWithoutOpportunityInput[] | ActivityUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOpportunityInput | ActivityCreateOrConnectWithoutOpportunityInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutOpportunityInput | ActivityUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: ActivityCreateManyOpportunityInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutOpportunityInput | ActivityUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutOpportunityInput | ActivityUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ProposalUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<ProposalCreateWithoutOpportunityInput, ProposalUncheckedCreateWithoutOpportunityInput> | ProposalCreateWithoutOpportunityInput[] | ProposalUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutOpportunityInput | ProposalCreateOrConnectWithoutOpportunityInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutOpportunityInput | ProposalUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: ProposalCreateManyOpportunityInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutOpportunityInput | ProposalUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutOpportunityInput | ProposalUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateOneWithoutOpportunityNestedInput = {
    create?: XOR<ProjectCreateWithoutOpportunityInput, ProjectUncheckedCreateWithoutOpportunityInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutOpportunityInput
    upsert?: ProjectUpsertWithoutOpportunityInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutOpportunityInput, ProjectUpdateWithoutOpportunityInput>, ProjectUncheckedUpdateWithoutOpportunityInput>
  }

  export type OpportunityCreateNestedOneWithoutProposalsInput = {
    create?: XOR<OpportunityCreateWithoutProposalsInput, OpportunityUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutProposalsInput
    connect?: OpportunityWhereUniqueInput
  }

  export type OpportunityUpdateOneRequiredWithoutProposalsNestedInput = {
    create?: XOR<OpportunityCreateWithoutProposalsInput, OpportunityUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutProposalsInput
    upsert?: OpportunityUpsertWithoutProposalsInput
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutProposalsInput, OpportunityUpdateWithoutProposalsInput>, OpportunityUncheckedUpdateWithoutProposalsInput>
  }

  export type OpportunityCreateNestedOneWithoutProjectInput = {
    create?: XOR<OpportunityCreateWithoutProjectInput, OpportunityUncheckedCreateWithoutProjectInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutProjectInput
    connect?: OpportunityWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutProjectsInput = {
    create?: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProjectsInput
    connect?: ClientWhereUniqueInput
  }

  export type ProjectMilestoneCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMilestoneCreateWithoutProjectInput, ProjectMilestoneUncheckedCreateWithoutProjectInput> | ProjectMilestoneCreateWithoutProjectInput[] | ProjectMilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMilestoneCreateOrConnectWithoutProjectInput | ProjectMilestoneCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMilestoneCreateManyProjectInputEnvelope
    connect?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
  }

  export type ProjectTaskCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectTaskCreateWithoutProjectInput, ProjectTaskUncheckedCreateWithoutProjectInput> | ProjectTaskCreateWithoutProjectInput[] | ProjectTaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTaskCreateOrConnectWithoutProjectInput | ProjectTaskCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectTaskCreateManyProjectInputEnvelope
    connect?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
  }

  export type ProjectMetricCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMetricCreateWithoutProjectInput, ProjectMetricUncheckedCreateWithoutProjectInput> | ProjectMetricCreateWithoutProjectInput[] | ProjectMetricUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMetricCreateOrConnectWithoutProjectInput | ProjectMetricCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMetricCreateManyProjectInputEnvelope
    connect?: ProjectMetricWhereUniqueInput | ProjectMetricWhereUniqueInput[]
  }

  export type ProjectMilestoneUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMilestoneCreateWithoutProjectInput, ProjectMilestoneUncheckedCreateWithoutProjectInput> | ProjectMilestoneCreateWithoutProjectInput[] | ProjectMilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMilestoneCreateOrConnectWithoutProjectInput | ProjectMilestoneCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMilestoneCreateManyProjectInputEnvelope
    connect?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
  }

  export type ProjectTaskUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectTaskCreateWithoutProjectInput, ProjectTaskUncheckedCreateWithoutProjectInput> | ProjectTaskCreateWithoutProjectInput[] | ProjectTaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTaskCreateOrConnectWithoutProjectInput | ProjectTaskCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectTaskCreateManyProjectInputEnvelope
    connect?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
  }

  export type ProjectMetricUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMetricCreateWithoutProjectInput, ProjectMetricUncheckedCreateWithoutProjectInput> | ProjectMetricCreateWithoutProjectInput[] | ProjectMetricUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMetricCreateOrConnectWithoutProjectInput | ProjectMetricCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMetricCreateManyProjectInputEnvelope
    connect?: ProjectMetricWhereUniqueInput | ProjectMetricWhereUniqueInput[]
  }

  export type EnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus
  }

  export type OpportunityUpdateOneWithoutProjectNestedInput = {
    create?: XOR<OpportunityCreateWithoutProjectInput, OpportunityUncheckedCreateWithoutProjectInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutProjectInput
    upsert?: OpportunityUpsertWithoutProjectInput
    disconnect?: OpportunityWhereInput | boolean
    delete?: OpportunityWhereInput | boolean
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutProjectInput, OpportunityUpdateWithoutProjectInput>, OpportunityUncheckedUpdateWithoutProjectInput>
  }

  export type ClientUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProjectsInput
    upsert?: ClientUpsertWithoutProjectsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutProjectsInput, ClientUpdateWithoutProjectsInput>, ClientUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectMilestoneUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMilestoneCreateWithoutProjectInput, ProjectMilestoneUncheckedCreateWithoutProjectInput> | ProjectMilestoneCreateWithoutProjectInput[] | ProjectMilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMilestoneCreateOrConnectWithoutProjectInput | ProjectMilestoneCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMilestoneUpsertWithWhereUniqueWithoutProjectInput | ProjectMilestoneUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMilestoneCreateManyProjectInputEnvelope
    set?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
    disconnect?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
    delete?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
    connect?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
    update?: ProjectMilestoneUpdateWithWhereUniqueWithoutProjectInput | ProjectMilestoneUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMilestoneUpdateManyWithWhereWithoutProjectInput | ProjectMilestoneUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMilestoneScalarWhereInput | ProjectMilestoneScalarWhereInput[]
  }

  export type ProjectTaskUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectTaskCreateWithoutProjectInput, ProjectTaskUncheckedCreateWithoutProjectInput> | ProjectTaskCreateWithoutProjectInput[] | ProjectTaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTaskCreateOrConnectWithoutProjectInput | ProjectTaskCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectTaskUpsertWithWhereUniqueWithoutProjectInput | ProjectTaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectTaskCreateManyProjectInputEnvelope
    set?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
    disconnect?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
    delete?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
    connect?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
    update?: ProjectTaskUpdateWithWhereUniqueWithoutProjectInput | ProjectTaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectTaskUpdateManyWithWhereWithoutProjectInput | ProjectTaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectTaskScalarWhereInput | ProjectTaskScalarWhereInput[]
  }

  export type ProjectMetricUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMetricCreateWithoutProjectInput, ProjectMetricUncheckedCreateWithoutProjectInput> | ProjectMetricCreateWithoutProjectInput[] | ProjectMetricUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMetricCreateOrConnectWithoutProjectInput | ProjectMetricCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMetricUpsertWithWhereUniqueWithoutProjectInput | ProjectMetricUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMetricCreateManyProjectInputEnvelope
    set?: ProjectMetricWhereUniqueInput | ProjectMetricWhereUniqueInput[]
    disconnect?: ProjectMetricWhereUniqueInput | ProjectMetricWhereUniqueInput[]
    delete?: ProjectMetricWhereUniqueInput | ProjectMetricWhereUniqueInput[]
    connect?: ProjectMetricWhereUniqueInput | ProjectMetricWhereUniqueInput[]
    update?: ProjectMetricUpdateWithWhereUniqueWithoutProjectInput | ProjectMetricUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMetricUpdateManyWithWhereWithoutProjectInput | ProjectMetricUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMetricScalarWhereInput | ProjectMetricScalarWhereInput[]
  }

  export type ProjectMilestoneUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMilestoneCreateWithoutProjectInput, ProjectMilestoneUncheckedCreateWithoutProjectInput> | ProjectMilestoneCreateWithoutProjectInput[] | ProjectMilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMilestoneCreateOrConnectWithoutProjectInput | ProjectMilestoneCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMilestoneUpsertWithWhereUniqueWithoutProjectInput | ProjectMilestoneUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMilestoneCreateManyProjectInputEnvelope
    set?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
    disconnect?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
    delete?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
    connect?: ProjectMilestoneWhereUniqueInput | ProjectMilestoneWhereUniqueInput[]
    update?: ProjectMilestoneUpdateWithWhereUniqueWithoutProjectInput | ProjectMilestoneUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMilestoneUpdateManyWithWhereWithoutProjectInput | ProjectMilestoneUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMilestoneScalarWhereInput | ProjectMilestoneScalarWhereInput[]
  }

  export type ProjectTaskUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectTaskCreateWithoutProjectInput, ProjectTaskUncheckedCreateWithoutProjectInput> | ProjectTaskCreateWithoutProjectInput[] | ProjectTaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTaskCreateOrConnectWithoutProjectInput | ProjectTaskCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectTaskUpsertWithWhereUniqueWithoutProjectInput | ProjectTaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectTaskCreateManyProjectInputEnvelope
    set?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
    disconnect?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
    delete?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
    connect?: ProjectTaskWhereUniqueInput | ProjectTaskWhereUniqueInput[]
    update?: ProjectTaskUpdateWithWhereUniqueWithoutProjectInput | ProjectTaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectTaskUpdateManyWithWhereWithoutProjectInput | ProjectTaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectTaskScalarWhereInput | ProjectTaskScalarWhereInput[]
  }

  export type ProjectMetricUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMetricCreateWithoutProjectInput, ProjectMetricUncheckedCreateWithoutProjectInput> | ProjectMetricCreateWithoutProjectInput[] | ProjectMetricUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMetricCreateOrConnectWithoutProjectInput | ProjectMetricCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMetricUpsertWithWhereUniqueWithoutProjectInput | ProjectMetricUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMetricCreateManyProjectInputEnvelope
    set?: ProjectMetricWhereUniqueInput | ProjectMetricWhereUniqueInput[]
    disconnect?: ProjectMetricWhereUniqueInput | ProjectMetricWhereUniqueInput[]
    delete?: ProjectMetricWhereUniqueInput | ProjectMetricWhereUniqueInput[]
    connect?: ProjectMetricWhereUniqueInput | ProjectMetricWhereUniqueInput[]
    update?: ProjectMetricUpdateWithWhereUniqueWithoutProjectInput | ProjectMetricUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMetricUpdateManyWithWhereWithoutProjectInput | ProjectMetricUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMetricScalarWhereInput | ProjectMetricScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutMilestonesInput = {
    create?: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMilestonesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectMilestonesInput = {
    create?: XOR<UserCreateWithoutProjectMilestonesInput, UserUncheckedCreateWithoutProjectMilestonesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMilestonesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMilestoneStatusFieldUpdateOperationsInput = {
    set?: $Enums.MilestoneStatus
  }

  export type ProjectUpdateOneRequiredWithoutMilestonesNestedInput = {
    create?: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMilestonesInput
    upsert?: ProjectUpsertWithoutMilestonesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMilestonesInput, ProjectUpdateWithoutMilestonesInput>, ProjectUncheckedUpdateWithoutMilestonesInput>
  }

  export type UserUpdateOneWithoutProjectMilestonesNestedInput = {
    create?: XOR<UserCreateWithoutProjectMilestonesInput, UserUncheckedCreateWithoutProjectMilestonesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMilestonesInput
    upsert?: UserUpsertWithoutProjectMilestonesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectMilestonesInput, UserUpdateWithoutProjectMilestonesInput>, UserUncheckedUpdateWithoutProjectMilestonesInput>
  }

  export type ProjectCreateNestedOneWithoutTasksInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectTasksInput = {
    create?: XOR<UserCreateWithoutProjectTasksInput, UserUncheckedCreateWithoutProjectTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectTasksInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    upsert?: ProjectUpsertWithoutTasksInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTasksInput, ProjectUpdateWithoutTasksInput>, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateOneWithoutProjectTasksNestedInput = {
    create?: XOR<UserCreateWithoutProjectTasksInput, UserUncheckedCreateWithoutProjectTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectTasksInput
    upsert?: UserUpsertWithoutProjectTasksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectTasksInput, UserUpdateWithoutProjectTasksInput>, UserUncheckedUpdateWithoutProjectTasksInput>
  }

  export type ProjectCreateNestedOneWithoutMetricsInput = {
    create?: XOR<ProjectCreateWithoutMetricsInput, ProjectUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMetricsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<ProjectCreateWithoutMetricsInput, ProjectUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMetricsInput
    upsert?: ProjectUpsertWithoutMetricsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMetricsInput, ProjectUpdateWithoutMetricsInput>, ProjectUncheckedUpdateWithoutMetricsInput>
  }

  export type AISolutionCreatetargetIndustriesInput = {
    set: string[]
  }

  export type AISolutionCreatetargetFunctionsInput = {
    set: string[]
  }

  export type AISolutionCreatetechnicalRequirementsInput = {
    set: string[]
  }

  export type AISolutionCreateintegrationPointsInput = {
    set: string[]
  }

  export type AISolutionCreatepricingModelsInput = {
    set: string[]
  }

  export type AISolutionCreateuseCasesInput = {
    set: string[]
  }

  export type AISolutionModuleCreateNestedManyWithoutSolutionInput = {
    create?: XOR<AISolutionModuleCreateWithoutSolutionInput, AISolutionModuleUncheckedCreateWithoutSolutionInput> | AISolutionModuleCreateWithoutSolutionInput[] | AISolutionModuleUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: AISolutionModuleCreateOrConnectWithoutSolutionInput | AISolutionModuleCreateOrConnectWithoutSolutionInput[]
    createMany?: AISolutionModuleCreateManySolutionInputEnvelope
    connect?: AISolutionModuleWhereUniqueInput | AISolutionModuleWhereUniqueInput[]
  }

  export type QuoteCreateNestedManyWithoutSolutionInput = {
    create?: XOR<QuoteCreateWithoutSolutionInput, QuoteUncheckedCreateWithoutSolutionInput> | QuoteCreateWithoutSolutionInput[] | QuoteUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutSolutionInput | QuoteCreateOrConnectWithoutSolutionInput[]
    createMany?: QuoteCreateManySolutionInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type ClientSolutionCreateNestedManyWithoutSolutionInput = {
    create?: XOR<ClientSolutionCreateWithoutSolutionInput, ClientSolutionUncheckedCreateWithoutSolutionInput> | ClientSolutionCreateWithoutSolutionInput[] | ClientSolutionUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: ClientSolutionCreateOrConnectWithoutSolutionInput | ClientSolutionCreateOrConnectWithoutSolutionInput[]
    createMany?: ClientSolutionCreateManySolutionInputEnvelope
    connect?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
  }

  export type AISolutionModuleUncheckedCreateNestedManyWithoutSolutionInput = {
    create?: XOR<AISolutionModuleCreateWithoutSolutionInput, AISolutionModuleUncheckedCreateWithoutSolutionInput> | AISolutionModuleCreateWithoutSolutionInput[] | AISolutionModuleUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: AISolutionModuleCreateOrConnectWithoutSolutionInput | AISolutionModuleCreateOrConnectWithoutSolutionInput[]
    createMany?: AISolutionModuleCreateManySolutionInputEnvelope
    connect?: AISolutionModuleWhereUniqueInput | AISolutionModuleWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutSolutionInput = {
    create?: XOR<QuoteCreateWithoutSolutionInput, QuoteUncheckedCreateWithoutSolutionInput> | QuoteCreateWithoutSolutionInput[] | QuoteUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutSolutionInput | QuoteCreateOrConnectWithoutSolutionInput[]
    createMany?: QuoteCreateManySolutionInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type ClientSolutionUncheckedCreateNestedManyWithoutSolutionInput = {
    create?: XOR<ClientSolutionCreateWithoutSolutionInput, ClientSolutionUncheckedCreateWithoutSolutionInput> | ClientSolutionCreateWithoutSolutionInput[] | ClientSolutionUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: ClientSolutionCreateOrConnectWithoutSolutionInput | ClientSolutionCreateOrConnectWithoutSolutionInput[]
    createMany?: ClientSolutionCreateManySolutionInputEnvelope
    connect?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
  }

  export type AISolutionUpdatetargetIndustriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AISolutionUpdatetargetFunctionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AISolutionUpdatetechnicalRequirementsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AISolutionUpdateintegrationPointsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AISolutionUpdatepricingModelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AISolutionUpdateuseCasesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AISolutionModuleUpdateManyWithoutSolutionNestedInput = {
    create?: XOR<AISolutionModuleCreateWithoutSolutionInput, AISolutionModuleUncheckedCreateWithoutSolutionInput> | AISolutionModuleCreateWithoutSolutionInput[] | AISolutionModuleUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: AISolutionModuleCreateOrConnectWithoutSolutionInput | AISolutionModuleCreateOrConnectWithoutSolutionInput[]
    upsert?: AISolutionModuleUpsertWithWhereUniqueWithoutSolutionInput | AISolutionModuleUpsertWithWhereUniqueWithoutSolutionInput[]
    createMany?: AISolutionModuleCreateManySolutionInputEnvelope
    set?: AISolutionModuleWhereUniqueInput | AISolutionModuleWhereUniqueInput[]
    disconnect?: AISolutionModuleWhereUniqueInput | AISolutionModuleWhereUniqueInput[]
    delete?: AISolutionModuleWhereUniqueInput | AISolutionModuleWhereUniqueInput[]
    connect?: AISolutionModuleWhereUniqueInput | AISolutionModuleWhereUniqueInput[]
    update?: AISolutionModuleUpdateWithWhereUniqueWithoutSolutionInput | AISolutionModuleUpdateWithWhereUniqueWithoutSolutionInput[]
    updateMany?: AISolutionModuleUpdateManyWithWhereWithoutSolutionInput | AISolutionModuleUpdateManyWithWhereWithoutSolutionInput[]
    deleteMany?: AISolutionModuleScalarWhereInput | AISolutionModuleScalarWhereInput[]
  }

  export type QuoteUpdateManyWithoutSolutionNestedInput = {
    create?: XOR<QuoteCreateWithoutSolutionInput, QuoteUncheckedCreateWithoutSolutionInput> | QuoteCreateWithoutSolutionInput[] | QuoteUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutSolutionInput | QuoteCreateOrConnectWithoutSolutionInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutSolutionInput | QuoteUpsertWithWhereUniqueWithoutSolutionInput[]
    createMany?: QuoteCreateManySolutionInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutSolutionInput | QuoteUpdateWithWhereUniqueWithoutSolutionInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutSolutionInput | QuoteUpdateManyWithWhereWithoutSolutionInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type ClientSolutionUpdateManyWithoutSolutionNestedInput = {
    create?: XOR<ClientSolutionCreateWithoutSolutionInput, ClientSolutionUncheckedCreateWithoutSolutionInput> | ClientSolutionCreateWithoutSolutionInput[] | ClientSolutionUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: ClientSolutionCreateOrConnectWithoutSolutionInput | ClientSolutionCreateOrConnectWithoutSolutionInput[]
    upsert?: ClientSolutionUpsertWithWhereUniqueWithoutSolutionInput | ClientSolutionUpsertWithWhereUniqueWithoutSolutionInput[]
    createMany?: ClientSolutionCreateManySolutionInputEnvelope
    set?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
    disconnect?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
    delete?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
    connect?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
    update?: ClientSolutionUpdateWithWhereUniqueWithoutSolutionInput | ClientSolutionUpdateWithWhereUniqueWithoutSolutionInput[]
    updateMany?: ClientSolutionUpdateManyWithWhereWithoutSolutionInput | ClientSolutionUpdateManyWithWhereWithoutSolutionInput[]
    deleteMany?: ClientSolutionScalarWhereInput | ClientSolutionScalarWhereInput[]
  }

  export type AISolutionModuleUncheckedUpdateManyWithoutSolutionNestedInput = {
    create?: XOR<AISolutionModuleCreateWithoutSolutionInput, AISolutionModuleUncheckedCreateWithoutSolutionInput> | AISolutionModuleCreateWithoutSolutionInput[] | AISolutionModuleUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: AISolutionModuleCreateOrConnectWithoutSolutionInput | AISolutionModuleCreateOrConnectWithoutSolutionInput[]
    upsert?: AISolutionModuleUpsertWithWhereUniqueWithoutSolutionInput | AISolutionModuleUpsertWithWhereUniqueWithoutSolutionInput[]
    createMany?: AISolutionModuleCreateManySolutionInputEnvelope
    set?: AISolutionModuleWhereUniqueInput | AISolutionModuleWhereUniqueInput[]
    disconnect?: AISolutionModuleWhereUniqueInput | AISolutionModuleWhereUniqueInput[]
    delete?: AISolutionModuleWhereUniqueInput | AISolutionModuleWhereUniqueInput[]
    connect?: AISolutionModuleWhereUniqueInput | AISolutionModuleWhereUniqueInput[]
    update?: AISolutionModuleUpdateWithWhereUniqueWithoutSolutionInput | AISolutionModuleUpdateWithWhereUniqueWithoutSolutionInput[]
    updateMany?: AISolutionModuleUpdateManyWithWhereWithoutSolutionInput | AISolutionModuleUpdateManyWithWhereWithoutSolutionInput[]
    deleteMany?: AISolutionModuleScalarWhereInput | AISolutionModuleScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutSolutionNestedInput = {
    create?: XOR<QuoteCreateWithoutSolutionInput, QuoteUncheckedCreateWithoutSolutionInput> | QuoteCreateWithoutSolutionInput[] | QuoteUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutSolutionInput | QuoteCreateOrConnectWithoutSolutionInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutSolutionInput | QuoteUpsertWithWhereUniqueWithoutSolutionInput[]
    createMany?: QuoteCreateManySolutionInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutSolutionInput | QuoteUpdateWithWhereUniqueWithoutSolutionInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutSolutionInput | QuoteUpdateManyWithWhereWithoutSolutionInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type ClientSolutionUncheckedUpdateManyWithoutSolutionNestedInput = {
    create?: XOR<ClientSolutionCreateWithoutSolutionInput, ClientSolutionUncheckedCreateWithoutSolutionInput> | ClientSolutionCreateWithoutSolutionInput[] | ClientSolutionUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: ClientSolutionCreateOrConnectWithoutSolutionInput | ClientSolutionCreateOrConnectWithoutSolutionInput[]
    upsert?: ClientSolutionUpsertWithWhereUniqueWithoutSolutionInput | ClientSolutionUpsertWithWhereUniqueWithoutSolutionInput[]
    createMany?: ClientSolutionCreateManySolutionInputEnvelope
    set?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
    disconnect?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
    delete?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
    connect?: ClientSolutionWhereUniqueInput | ClientSolutionWhereUniqueInput[]
    update?: ClientSolutionUpdateWithWhereUniqueWithoutSolutionInput | ClientSolutionUpdateWithWhereUniqueWithoutSolutionInput[]
    updateMany?: ClientSolutionUpdateManyWithWhereWithoutSolutionInput | ClientSolutionUpdateManyWithWhereWithoutSolutionInput[]
    deleteMany?: ClientSolutionScalarWhereInput | ClientSolutionScalarWhereInput[]
  }

  export type AISolutionCreateNestedOneWithoutModulesInput = {
    create?: XOR<AISolutionCreateWithoutModulesInput, AISolutionUncheckedCreateWithoutModulesInput>
    connectOrCreate?: AISolutionCreateOrConnectWithoutModulesInput
    connect?: AISolutionWhereUniqueInput
  }

  export type AISolutionUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<AISolutionCreateWithoutModulesInput, AISolutionUncheckedCreateWithoutModulesInput>
    connectOrCreate?: AISolutionCreateOrConnectWithoutModulesInput
    upsert?: AISolutionUpsertWithoutModulesInput
    connect?: AISolutionWhereUniqueInput
    update?: XOR<XOR<AISolutionUpdateToOneWithWhereWithoutModulesInput, AISolutionUpdateWithoutModulesInput>, AISolutionUncheckedUpdateWithoutModulesInput>
  }

  export type AISolutionCreateNestedOneWithoutQuotesInput = {
    create?: XOR<AISolutionCreateWithoutQuotesInput, AISolutionUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: AISolutionCreateOrConnectWithoutQuotesInput
    connect?: AISolutionWhereUniqueInput
  }

  export type AISolutionUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<AISolutionCreateWithoutQuotesInput, AISolutionUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: AISolutionCreateOrConnectWithoutQuotesInput
    upsert?: AISolutionUpsertWithoutQuotesInput
    connect?: AISolutionWhereUniqueInput
    update?: XOR<XOR<AISolutionUpdateToOneWithWhereWithoutQuotesInput, AISolutionUpdateWithoutQuotesInput>, AISolutionUncheckedUpdateWithoutQuotesInput>
  }

  export type ActivityCreatekeyTopicsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<LeadCreateWithoutActivitiesInput, LeadUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: LeadCreateOrConnectWithoutActivitiesInput
    connect?: LeadWhereUniqueInput
  }

  export type OpportunityCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<OpportunityCreateWithoutActivitiesInput, OpportunityUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutActivitiesInput
    connect?: OpportunityWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutActivitiesInput
    connect?: ContactWhereUniqueInput
  }

  export type ActivityUpdatekeyTopicsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type LeadUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<LeadCreateWithoutActivitiesInput, LeadUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: LeadCreateOrConnectWithoutActivitiesInput
    upsert?: LeadUpsertWithoutActivitiesInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutActivitiesInput, LeadUpdateWithoutActivitiesInput>, LeadUncheckedUpdateWithoutActivitiesInput>
  }

  export type OpportunityUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<OpportunityCreateWithoutActivitiesInput, OpportunityUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutActivitiesInput
    upsert?: OpportunityUpsertWithoutActivitiesInput
    disconnect?: OpportunityWhereInput | boolean
    delete?: OpportunityWhereInput | boolean
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutActivitiesInput, OpportunityUpdateWithoutActivitiesInput>, OpportunityUncheckedUpdateWithoutActivitiesInput>
  }

  export type ContactUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutActivitiesInput
    upsert?: ContactUpsertWithoutActivitiesInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutActivitiesInput, ContactUpdateWithoutActivitiesInput>, ContactUncheckedUpdateWithoutActivitiesInput>
  }

  export type ClientCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<ClientCreateWithoutFeedbackInput, ClientUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: ClientCreateOrConnectWithoutFeedbackInput
    connect?: ClientWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ClientUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<ClientCreateWithoutFeedbackInput, ClientUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: ClientCreateOrConnectWithoutFeedbackInput
    upsert?: ClientUpsertWithoutFeedbackInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutFeedbackInput, ClientUpdateWithoutFeedbackInput>, ClientUncheckedUpdateWithoutFeedbackInput>
  }

  export type ClientCreateNestedOneWithoutTicketsInput = {
    create?: XOR<ClientCreateWithoutTicketsInput, ClientUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutTicketsInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketsInput = {
    create?: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketCommentCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type TicketCommentUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type EnumTicketTypeFieldUpdateOperationsInput = {
    set?: $Enums.TicketType
  }

  export type EnumTicketSeverityFieldUpdateOperationsInput = {
    set?: $Enums.TicketSeverity
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type ClientUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<ClientCreateWithoutTicketsInput, ClientUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutTicketsInput
    upsert?: ClientUpsertWithoutTicketsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutTicketsInput, ClientUpdateWithoutTicketsInput>, ClientUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsInput
    upsert?: UserUpsertWithoutTicketsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketsInput, UserUpdateWithoutTicketsInput>, UserUncheckedUpdateWithoutTicketsInput>
  }

  export type TicketCommentUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutTicketInput | TicketCommentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutTicketInput | TicketCommentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutTicketInput | TicketCommentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type TicketCommentUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutTicketInput | TicketCommentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutTicketInput | TicketCommentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutTicketInput | TicketCommentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type TicketCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutCommentsInput
    connect?: TicketWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutCommentsInput
    upsert?: TicketUpsertWithoutCommentsInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutCommentsInput, TicketUpdateWithoutCommentsInput>, TicketUncheckedUpdateWithoutCommentsInput>
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumClientLifecycleStageFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientLifecycleStage | EnumClientLifecycleStageFieldRefInput<$PrismaModel>
    in?: $Enums.ClientLifecycleStage[] | ListEnumClientLifecycleStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientLifecycleStage[] | ListEnumClientLifecycleStageFieldRefInput<$PrismaModel>
    not?: NestedEnumClientLifecycleStageFilter<$PrismaModel> | $Enums.ClientLifecycleStage
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumClientLifecycleStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientLifecycleStage | EnumClientLifecycleStageFieldRefInput<$PrismaModel>
    in?: $Enums.ClientLifecycleStage[] | ListEnumClientLifecycleStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientLifecycleStage[] | ListEnumClientLifecycleStageFieldRefInput<$PrismaModel>
    not?: NestedEnumClientLifecycleStageWithAggregatesFilter<$PrismaModel> | $Enums.ClientLifecycleStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientLifecycleStageFilter<$PrismaModel>
    _max?: NestedEnumClientLifecycleStageFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type NestedEnumOpportunityStageFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityStage | EnumOpportunityStageFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityStage[] | ListEnumOpportunityStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityStage[] | ListEnumOpportunityStageFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityStageFilter<$PrismaModel> | $Enums.OpportunityStage
  }

  export type NestedEnumOpportunityStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityStage | EnumOpportunityStageFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityStage[] | ListEnumOpportunityStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityStage[] | ListEnumOpportunityStageFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityStageWithAggregatesFilter<$PrismaModel> | $Enums.OpportunityStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOpportunityStageFilter<$PrismaModel>
    _max?: NestedEnumOpportunityStageFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type NestedEnumMilestoneStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MilestoneStatus | EnumMilestoneStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMilestoneStatusFilter<$PrismaModel> | $Enums.MilestoneStatus
  }

  export type NestedEnumMilestoneStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MilestoneStatus | EnumMilestoneStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMilestoneStatusWithAggregatesFilter<$PrismaModel> | $Enums.MilestoneStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMilestoneStatusFilter<$PrismaModel>
    _max?: NestedEnumMilestoneStatusFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumTicketTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketTypeFilter<$PrismaModel> | $Enums.TicketType
  }

  export type NestedEnumTicketSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketSeverity | EnumTicketSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketSeverity[] | ListEnumTicketSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketSeverity[] | ListEnumTicketSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketSeverityFilter<$PrismaModel> | $Enums.TicketSeverity
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedEnumTicketTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketTypeWithAggregatesFilter<$PrismaModel> | $Enums.TicketType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketTypeFilter<$PrismaModel>
    _max?: NestedEnumTicketTypeFilter<$PrismaModel>
  }

  export type NestedEnumTicketSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketSeverity | EnumTicketSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketSeverity[] | ListEnumTicketSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketSeverity[] | ListEnumTicketSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketSeverityWithAggregatesFilter<$PrismaModel> | $Enums.TicketSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketSeverityFilter<$PrismaModel>
    _max?: NestedEnumTicketSeverityFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type ClientCreateWithoutUsersInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutClientInput
    leads?: LeadCreateNestedManyWithoutClientInput
    opportunities?: OpportunityCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    tickets?: TicketCreateNestedManyWithoutClientInput
    feedback?: FeedbackCreateNestedManyWithoutClientInput
    aiSolutions?: ClientSolutionCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    tickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutClientInput
    aiSolutions?: ClientSolutionUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUsersInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutSubordinatesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutUsersInput
    managedBy?: UserCreateNestedOneWithoutSubordinatesInput
    leads?: LeadCreateNestedManyWithoutOwnerInput
    opportunities?: OpportunityCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskCreateNestedManyWithoutAssigneeInput
    projectMilestones?: ProjectMilestoneCreateNestedManyWithoutOwnerInput
    tickets?: TicketCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutSubordinatesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    managerId?: string | null
    leads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskUncheckedCreateNestedManyWithoutAssigneeInput
    projectMilestones?: ProjectMilestoneUncheckedCreateNestedManyWithoutOwnerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutSubordinatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
  }

  export type UserCreateWithoutManagedByInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutUsersInput
    subordinates?: UserCreateNestedManyWithoutManagedByInput
    leads?: LeadCreateNestedManyWithoutOwnerInput
    opportunities?: OpportunityCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskCreateNestedManyWithoutAssigneeInput
    projectMilestones?: ProjectMilestoneCreateNestedManyWithoutOwnerInput
    tickets?: TicketCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutManagedByInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    subordinates?: UserUncheckedCreateNestedManyWithoutManagedByInput
    leads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskUncheckedCreateNestedManyWithoutAssigneeInput
    projectMilestones?: ProjectMilestoneUncheckedCreateNestedManyWithoutOwnerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutManagedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagedByInput, UserUncheckedCreateWithoutManagedByInput>
  }

  export type UserCreateManyManagedByInputEnvelope = {
    data: UserCreateManyManagedByInput | UserCreateManyManagedByInput[]
    skipDuplicates?: boolean
  }

  export type LeadCreateWithoutOwnerInput = {
    id?: string
    source: string
    sourceDetails?: string | null
    status?: $Enums.LeadStatus
    companyName: string
    contactName: string
    contactEmail: string
    contactPhone?: string | null
    industry?: string | null
    companySize?: string | null
    leadScore?: number
    scoreTier?: string
    scoreReason?: string | null
    budgetRange?: string | null
    timeline?: string | null
    needDescription?: string | null
    convertedAt?: Date | string | null
    lostAt?: Date | string | null
    lossReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutLeadsInput
    activities?: ActivityCreateNestedManyWithoutLeadInput
    opportunities?: OpportunityCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutOwnerInput = {
    id?: string
    clientId?: string | null
    source: string
    sourceDetails?: string | null
    status?: $Enums.LeadStatus
    companyName: string
    contactName: string
    contactEmail: string
    contactPhone?: string | null
    industry?: string | null
    companySize?: string | null
    leadScore?: number
    scoreTier?: string
    scoreReason?: string | null
    budgetRange?: string | null
    timeline?: string | null
    needDescription?: string | null
    convertedAt?: Date | string | null
    lostAt?: Date | string | null
    lossReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutLeadInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutOwnerInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutOwnerInput, LeadUncheckedCreateWithoutOwnerInput>
  }

  export type LeadCreateManyOwnerInputEnvelope = {
    data: LeadCreateManyOwnerInput | LeadCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityCreateWithoutOwnerInput = {
    id?: string
    name: string
    stage?: $Enums.OpportunityStage
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    estimatedValue?: number
    weightedValue?: number
    nextStep?: string | null
    nextStepDate?: Date | string | null
    lostReason?: string | null
    wonReason?: string | null
    solutionType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lead?: LeadCreateNestedOneWithoutOpportunitiesInput
    client?: ClientCreateNestedOneWithoutOpportunitiesInput
    activities?: ActivityCreateNestedManyWithoutOpportunityInput
    proposals?: ProposalCreateNestedManyWithoutOpportunityInput
    project?: ProjectCreateNestedOneWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutOwnerInput = {
    id?: string
    leadId?: string | null
    clientId?: string | null
    name: string
    stage?: $Enums.OpportunityStage
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    estimatedValue?: number
    weightedValue?: number
    nextStep?: string | null
    nextStepDate?: Date | string | null
    lostReason?: string | null
    wonReason?: string | null
    solutionType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutOpportunityInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutOpportunityInput
    project?: ProjectUncheckedCreateNestedOneWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutOwnerInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutOwnerInput, OpportunityUncheckedCreateWithoutOwnerInput>
  }

  export type OpportunityCreateManyOwnerInputEnvelope = {
    data: OpportunityCreateManyOwnerInput | OpportunityCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutOwnerInput = {
    id?: string
    type: string
    subject: string
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    durationMinutes?: number | null
    outcome?: string | null
    sentiment?: string | null
    keyTopics?: ActivityCreatekeyTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lead?: LeadCreateNestedOneWithoutActivitiesInput
    opportunity?: OpportunityCreateNestedOneWithoutActivitiesInput
    contact?: ContactCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutOwnerInput = {
    id?: string
    leadId?: string | null
    opportunityId?: string | null
    contactId?: string | null
    type: string
    subject: string
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    durationMinutes?: number | null
    outcome?: string | null
    sentiment?: string | null
    keyTopics?: ActivityCreatekeyTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutOwnerInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutOwnerInput, ActivityUncheckedCreateWithoutOwnerInput>
  }

  export type ActivityCreateManyOwnerInputEnvelope = {
    data: ActivityCreateManyOwnerInput | ActivityCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectTaskCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: string
    phase?: string | null
    parentTaskId?: string | null
    plannedHours?: number | null
    actualHours?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    blockerReason?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
  }

  export type ProjectTaskUncheckedCreateWithoutAssigneeInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: string
    phase?: string | null
    parentTaskId?: string | null
    plannedHours?: number | null
    actualHours?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    blockerReason?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTaskCreateOrConnectWithoutAssigneeInput = {
    where: ProjectTaskWhereUniqueInput
    create: XOR<ProjectTaskCreateWithoutAssigneeInput, ProjectTaskUncheckedCreateWithoutAssigneeInput>
  }

  export type ProjectTaskCreateManyAssigneeInputEnvelope = {
    data: ProjectTaskCreateManyAssigneeInput | ProjectTaskCreateManyAssigneeInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMilestoneCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.MilestoneStatus
    phase?: string | null
    order: number
    plannedStartDate?: Date | string | null
    plannedEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    completionCriteria?: string | null
    dependsOnId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMilestonesInput
  }

  export type ProjectMilestoneUncheckedCreateWithoutOwnerInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    status?: $Enums.MilestoneStatus
    phase?: string | null
    order: number
    plannedStartDate?: Date | string | null
    plannedEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    completionCriteria?: string | null
    dependsOnId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMilestoneCreateOrConnectWithoutOwnerInput = {
    where: ProjectMilestoneWhereUniqueInput
    create: XOR<ProjectMilestoneCreateWithoutOwnerInput, ProjectMilestoneUncheckedCreateWithoutOwnerInput>
  }

  export type ProjectMilestoneCreateManyOwnerInputEnvelope = {
    data: ProjectMilestoneCreateManyOwnerInput | ProjectMilestoneCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutAssigneeInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    type?: $Enums.TicketType
    severity?: $Enums.TicketSeverity
    status?: $Enums.TicketStatus
    resolution?: string | null
    rootCause?: string | null
    slaResponseDue?: Date | string | null
    slaResolutionDue?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutTicketsInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutAssigneeInput = {
    id?: string
    clientId: string
    ticketNumber: string
    title: string
    description: string
    type?: $Enums.TicketType
    severity?: $Enums.TicketSeverity
    status?: $Enums.TicketStatus
    resolution?: string | null
    rootCause?: string | null
    slaResponseDue?: Date | string | null
    slaResolutionDue?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutAssigneeInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutAssigneeInput, TicketUncheckedCreateWithoutAssigneeInput>
  }

  export type TicketCreateManyAssigneeInputEnvelope = {
    data: TicketCreateManyAssigneeInput | TicketCreateManyAssigneeInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAuthorInput = {
    id?: string
    entityType: string
    entityId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    entityType: string
    entityId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutUsersInput = {
    update: XOR<ClientUpdateWithoutUsersInput, ClientUncheckedUpdateWithoutUsersInput>
    create: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutUsersInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutUsersInput, ClientUncheckedUpdateWithoutUsersInput>
  }

  export type ClientUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutClientNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    opportunities?: OpportunityUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    tickets?: TicketUpdateManyWithoutClientNestedInput
    feedback?: FeedbackUpdateManyWithoutClientNestedInput
    aiSolutions?: ClientSolutionUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutClientNestedInput
    aiSolutions?: ClientSolutionUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutSubordinatesInput = {
    update: XOR<UserUpdateWithoutSubordinatesInput, UserUncheckedUpdateWithoutSubordinatesInput>
    create: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubordinatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubordinatesInput, UserUncheckedUpdateWithoutSubordinatesInput>
  }

  export type UserUpdateWithoutSubordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutUsersNestedInput
    managedBy?: UserUpdateOneWithoutSubordinatesNestedInput
    leads?: LeadUpdateManyWithoutOwnerNestedInput
    opportunities?: OpportunityUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUpdateManyWithoutAssigneeNestedInput
    projectMilestones?: ProjectMilestoneUpdateManyWithoutOwnerNestedInput
    tickets?: TicketUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutSubordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    leads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    projectMilestones?: ProjectMilestoneUncheckedUpdateManyWithoutOwnerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutManagedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutManagedByInput, UserUncheckedUpdateWithoutManagedByInput>
    create: XOR<UserCreateWithoutManagedByInput, UserUncheckedCreateWithoutManagedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutManagedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutManagedByInput, UserUncheckedUpdateWithoutManagedByInput>
  }

  export type UserUpdateManyWithWhereWithoutManagedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutManagedByInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    clientId?: StringNullableFilter<"User"> | string | null
    managerId?: StringNullableFilter<"User"> | string | null
  }

  export type LeadUpsertWithWhereUniqueWithoutOwnerInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutOwnerInput, LeadUncheckedUpdateWithoutOwnerInput>
    create: XOR<LeadCreateWithoutOwnerInput, LeadUncheckedCreateWithoutOwnerInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutOwnerInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutOwnerInput, LeadUncheckedUpdateWithoutOwnerInput>
  }

  export type LeadUpdateManyWithWhereWithoutOwnerInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutOwnerInput>
  }

  export type LeadScalarWhereInput = {
    AND?: LeadScalarWhereInput | LeadScalarWhereInput[]
    OR?: LeadScalarWhereInput[]
    NOT?: LeadScalarWhereInput | LeadScalarWhereInput[]
    id?: StringFilter<"Lead"> | string
    clientId?: StringNullableFilter<"Lead"> | string | null
    ownerId?: StringFilter<"Lead"> | string
    source?: StringFilter<"Lead"> | string
    sourceDetails?: StringNullableFilter<"Lead"> | string | null
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    companyName?: StringFilter<"Lead"> | string
    contactName?: StringFilter<"Lead"> | string
    contactEmail?: StringFilter<"Lead"> | string
    contactPhone?: StringNullableFilter<"Lead"> | string | null
    industry?: StringNullableFilter<"Lead"> | string | null
    companySize?: StringNullableFilter<"Lead"> | string | null
    leadScore?: IntFilter<"Lead"> | number
    scoreTier?: StringFilter<"Lead"> | string
    scoreReason?: StringNullableFilter<"Lead"> | string | null
    budgetRange?: StringNullableFilter<"Lead"> | string | null
    timeline?: StringNullableFilter<"Lead"> | string | null
    needDescription?: StringNullableFilter<"Lead"> | string | null
    convertedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    lostAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    lossReason?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
  }

  export type OpportunityUpsertWithWhereUniqueWithoutOwnerInput = {
    where: OpportunityWhereUniqueInput
    update: XOR<OpportunityUpdateWithoutOwnerInput, OpportunityUncheckedUpdateWithoutOwnerInput>
    create: XOR<OpportunityCreateWithoutOwnerInput, OpportunityUncheckedCreateWithoutOwnerInput>
  }

  export type OpportunityUpdateWithWhereUniqueWithoutOwnerInput = {
    where: OpportunityWhereUniqueInput
    data: XOR<OpportunityUpdateWithoutOwnerInput, OpportunityUncheckedUpdateWithoutOwnerInput>
  }

  export type OpportunityUpdateManyWithWhereWithoutOwnerInput = {
    where: OpportunityScalarWhereInput
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyWithoutOwnerInput>
  }

  export type OpportunityScalarWhereInput = {
    AND?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
    OR?: OpportunityScalarWhereInput[]
    NOT?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
    id?: StringFilter<"Opportunity"> | string
    leadId?: StringNullableFilter<"Opportunity"> | string | null
    clientId?: StringNullableFilter<"Opportunity"> | string | null
    ownerId?: StringFilter<"Opportunity"> | string
    name?: StringFilter<"Opportunity"> | string
    stage?: EnumOpportunityStageFilter<"Opportunity"> | $Enums.OpportunityStage
    probability?: IntFilter<"Opportunity"> | number
    expectedCloseDate?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    actualCloseDate?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    estimatedValue?: FloatFilter<"Opportunity"> | number
    weightedValue?: FloatFilter<"Opportunity"> | number
    nextStep?: StringNullableFilter<"Opportunity"> | string | null
    nextStepDate?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    lostReason?: StringNullableFilter<"Opportunity"> | string | null
    wonReason?: StringNullableFilter<"Opportunity"> | string | null
    solutionType?: StringNullableFilter<"Opportunity"> | string | null
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeFilter<"Opportunity"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutOwnerInput, ActivityUncheckedUpdateWithoutOwnerInput>
    create: XOR<ActivityCreateWithoutOwnerInput, ActivityUncheckedCreateWithoutOwnerInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutOwnerInput, ActivityUncheckedUpdateWithoutOwnerInput>
  }

  export type ActivityUpdateManyWithWhereWithoutOwnerInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    ownerId?: StringFilter<"Activity"> | string
    leadId?: StringNullableFilter<"Activity"> | string | null
    opportunityId?: StringNullableFilter<"Activity"> | string | null
    contactId?: StringNullableFilter<"Activity"> | string | null
    type?: StringFilter<"Activity"> | string
    subject?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    scheduledAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    durationMinutes?: IntNullableFilter<"Activity"> | number | null
    outcome?: StringNullableFilter<"Activity"> | string | null
    sentiment?: StringNullableFilter<"Activity"> | string | null
    keyTopics?: StringNullableListFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
  }

  export type ProjectTaskUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: ProjectTaskWhereUniqueInput
    update: XOR<ProjectTaskUpdateWithoutAssigneeInput, ProjectTaskUncheckedUpdateWithoutAssigneeInput>
    create: XOR<ProjectTaskCreateWithoutAssigneeInput, ProjectTaskUncheckedCreateWithoutAssigneeInput>
  }

  export type ProjectTaskUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: ProjectTaskWhereUniqueInput
    data: XOR<ProjectTaskUpdateWithoutAssigneeInput, ProjectTaskUncheckedUpdateWithoutAssigneeInput>
  }

  export type ProjectTaskUpdateManyWithWhereWithoutAssigneeInput = {
    where: ProjectTaskScalarWhereInput
    data: XOR<ProjectTaskUpdateManyMutationInput, ProjectTaskUncheckedUpdateManyWithoutAssigneeInput>
  }

  export type ProjectTaskScalarWhereInput = {
    AND?: ProjectTaskScalarWhereInput | ProjectTaskScalarWhereInput[]
    OR?: ProjectTaskScalarWhereInput[]
    NOT?: ProjectTaskScalarWhereInput | ProjectTaskScalarWhereInput[]
    id?: StringFilter<"ProjectTask"> | string
    projectId?: StringFilter<"ProjectTask"> | string
    title?: StringFilter<"ProjectTask"> | string
    description?: StringNullableFilter<"ProjectTask"> | string | null
    status?: EnumTaskStatusFilter<"ProjectTask"> | $Enums.TaskStatus
    priority?: StringFilter<"ProjectTask"> | string
    phase?: StringNullableFilter<"ProjectTask"> | string | null
    assigneeId?: StringNullableFilter<"ProjectTask"> | string | null
    parentTaskId?: StringNullableFilter<"ProjectTask"> | string | null
    plannedHours?: FloatNullableFilter<"ProjectTask"> | number | null
    actualHours?: FloatFilter<"ProjectTask"> | number
    dueDate?: DateTimeNullableFilter<"ProjectTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ProjectTask"> | Date | string | null
    blockerReason?: StringNullableFilter<"ProjectTask"> | string | null
    order?: IntFilter<"ProjectTask"> | number
    createdAt?: DateTimeFilter<"ProjectTask"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectTask"> | Date | string
  }

  export type ProjectMilestoneUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ProjectMilestoneWhereUniqueInput
    update: XOR<ProjectMilestoneUpdateWithoutOwnerInput, ProjectMilestoneUncheckedUpdateWithoutOwnerInput>
    create: XOR<ProjectMilestoneCreateWithoutOwnerInput, ProjectMilestoneUncheckedCreateWithoutOwnerInput>
  }

  export type ProjectMilestoneUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ProjectMilestoneWhereUniqueInput
    data: XOR<ProjectMilestoneUpdateWithoutOwnerInput, ProjectMilestoneUncheckedUpdateWithoutOwnerInput>
  }

  export type ProjectMilestoneUpdateManyWithWhereWithoutOwnerInput = {
    where: ProjectMilestoneScalarWhereInput
    data: XOR<ProjectMilestoneUpdateManyMutationInput, ProjectMilestoneUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ProjectMilestoneScalarWhereInput = {
    AND?: ProjectMilestoneScalarWhereInput | ProjectMilestoneScalarWhereInput[]
    OR?: ProjectMilestoneScalarWhereInput[]
    NOT?: ProjectMilestoneScalarWhereInput | ProjectMilestoneScalarWhereInput[]
    id?: StringFilter<"ProjectMilestone"> | string
    projectId?: StringFilter<"ProjectMilestone"> | string
    name?: StringFilter<"ProjectMilestone"> | string
    description?: StringNullableFilter<"ProjectMilestone"> | string | null
    status?: EnumMilestoneStatusFilter<"ProjectMilestone"> | $Enums.MilestoneStatus
    phase?: StringNullableFilter<"ProjectMilestone"> | string | null
    order?: IntFilter<"ProjectMilestone"> | number
    plannedStartDate?: DateTimeNullableFilter<"ProjectMilestone"> | Date | string | null
    plannedEndDate?: DateTimeNullableFilter<"ProjectMilestone"> | Date | string | null
    actualStartDate?: DateTimeNullableFilter<"ProjectMilestone"> | Date | string | null
    actualEndDate?: DateTimeNullableFilter<"ProjectMilestone"> | Date | string | null
    completionCriteria?: StringNullableFilter<"ProjectMilestone"> | string | null
    ownerId?: StringNullableFilter<"ProjectMilestone"> | string | null
    dependsOnId?: StringNullableFilter<"ProjectMilestone"> | string | null
    createdAt?: DateTimeFilter<"ProjectMilestone"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMilestone"> | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutAssigneeInput, TicketUncheckedUpdateWithoutAssigneeInput>
    create: XOR<TicketCreateWithoutAssigneeInput, TicketUncheckedCreateWithoutAssigneeInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutAssigneeInput, TicketUncheckedUpdateWithoutAssigneeInput>
  }

  export type TicketUpdateManyWithWhereWithoutAssigneeInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutAssigneeInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: StringFilter<"Ticket"> | string
    clientId?: StringFilter<"Ticket"> | string
    assigneeId?: StringNullableFilter<"Ticket"> | string | null
    ticketNumber?: StringFilter<"Ticket"> | string
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    type?: EnumTicketTypeFilter<"Ticket"> | $Enums.TicketType
    severity?: EnumTicketSeverityFilter<"Ticket"> | $Enums.TicketSeverity
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    resolution?: StringNullableFilter<"Ticket"> | string | null
    rootCause?: StringNullableFilter<"Ticket"> | string | null
    slaResponseDue?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    slaResolutionDue?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    respondedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    entityType?: StringFilter<"Comment"> | string
    entityId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type ContactCreateWithoutClientInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    jobTitle?: string | null
    isDecisionMaker?: boolean
    isInfluencer?: boolean
    isTechnicalLead?: boolean
    isEndUser?: boolean
    isBudgetHolder?: boolean
    influenceLevel?: number
    relationshipScore?: number
    lastInteraction?: Date | string | null
    preferredChannel?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutClientInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    jobTitle?: string | null
    isDecisionMaker?: boolean
    isInfluencer?: boolean
    isTechnicalLead?: boolean
    isEndUser?: boolean
    isBudgetHolder?: boolean
    influenceLevel?: number
    relationshipScore?: number
    lastInteraction?: Date | string | null
    preferredChannel?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutClientInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutClientInput, ContactUncheckedCreateWithoutClientInput>
  }

  export type ContactCreateManyClientInputEnvelope = {
    data: ContactCreateManyClientInput | ContactCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type LeadCreateWithoutClientInput = {
    id?: string
    source: string
    sourceDetails?: string | null
    status?: $Enums.LeadStatus
    companyName: string
    contactName: string
    contactEmail: string
    contactPhone?: string | null
    industry?: string | null
    companySize?: string | null
    leadScore?: number
    scoreTier?: string
    scoreReason?: string | null
    budgetRange?: string | null
    timeline?: string | null
    needDescription?: string | null
    convertedAt?: Date | string | null
    lostAt?: Date | string | null
    lossReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutLeadsInput
    activities?: ActivityCreateNestedManyWithoutLeadInput
    opportunities?: OpportunityCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutClientInput = {
    id?: string
    ownerId: string
    source: string
    sourceDetails?: string | null
    status?: $Enums.LeadStatus
    companyName: string
    contactName: string
    contactEmail: string
    contactPhone?: string | null
    industry?: string | null
    companySize?: string | null
    leadScore?: number
    scoreTier?: string
    scoreReason?: string | null
    budgetRange?: string | null
    timeline?: string | null
    needDescription?: string | null
    convertedAt?: Date | string | null
    lostAt?: Date | string | null
    lossReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutLeadInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutClientInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutClientInput, LeadUncheckedCreateWithoutClientInput>
  }

  export type LeadCreateManyClientInputEnvelope = {
    data: LeadCreateManyClientInput | LeadCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityCreateWithoutClientInput = {
    id?: string
    name: string
    stage?: $Enums.OpportunityStage
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    estimatedValue?: number
    weightedValue?: number
    nextStep?: string | null
    nextStepDate?: Date | string | null
    lostReason?: string | null
    wonReason?: string | null
    solutionType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lead?: LeadCreateNestedOneWithoutOpportunitiesInput
    owner: UserCreateNestedOneWithoutOpportunitiesInput
    activities?: ActivityCreateNestedManyWithoutOpportunityInput
    proposals?: ProposalCreateNestedManyWithoutOpportunityInput
    project?: ProjectCreateNestedOneWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutClientInput = {
    id?: string
    leadId?: string | null
    ownerId: string
    name: string
    stage?: $Enums.OpportunityStage
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    estimatedValue?: number
    weightedValue?: number
    nextStep?: string | null
    nextStepDate?: Date | string | null
    lostReason?: string | null
    wonReason?: string | null
    solutionType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutOpportunityInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutOpportunityInput
    project?: ProjectUncheckedCreateNestedOneWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutClientInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutClientInput, OpportunityUncheckedCreateWithoutClientInput>
  }

  export type OpportunityCreateManyClientInputEnvelope = {
    data: OpportunityCreateManyClientInput | OpportunityCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutClientInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    budget?: number
    actualCost?: number
    projectManagerId?: string | null
    solutionType?: string | null
    healthStatus?: string
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunity?: OpportunityCreateNestedOneWithoutProjectInput
    milestones?: ProjectMilestoneCreateNestedManyWithoutProjectInput
    tasks?: ProjectTaskCreateNestedManyWithoutProjectInput
    metrics?: ProjectMetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutClientInput = {
    id?: string
    opportunityId?: string | null
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    budget?: number
    actualCost?: number
    projectManagerId?: string | null
    solutionType?: string | null
    healthStatus?: string
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: ProjectMilestoneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: ProjectTaskUncheckedCreateNestedManyWithoutProjectInput
    metrics?: ProjectMetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutClientInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectCreateManyClientInputEnvelope = {
    data: ProjectCreateManyClientInput | ProjectCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutClientInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    type?: $Enums.TicketType
    severity?: $Enums.TicketSeverity
    status?: $Enums.TicketStatus
    resolution?: string | null
    rootCause?: string | null
    slaResponseDue?: Date | string | null
    slaResolutionDue?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignee?: UserCreateNestedOneWithoutTicketsInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutClientInput = {
    id?: string
    assigneeId?: string | null
    ticketNumber: string
    title: string
    description: string
    type?: $Enums.TicketType
    severity?: $Enums.TicketSeverity
    status?: $Enums.TicketStatus
    resolution?: string | null
    rootCause?: string | null
    slaResponseDue?: Date | string | null
    slaResolutionDue?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutClientInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput>
  }

  export type TicketCreateManyClientInputEnvelope = {
    data: TicketCreateManyClientInput | TicketCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutClientInput = {
    id?: string
    projectId?: string | null
    milestoneId?: string | null
    type: string
    rating: number
    comments?: string | null
    deliveredOnTime?: boolean | null
    metExpectations?: boolean | null
    wouldRecommend?: boolean | null
    responderName?: string | null
    responderEmail?: string | null
    createdAt?: Date | string
  }

  export type FeedbackUncheckedCreateWithoutClientInput = {
    id?: string
    projectId?: string | null
    milestoneId?: string | null
    type: string
    rating: number
    comments?: string | null
    deliveredOnTime?: boolean | null
    metExpectations?: boolean | null
    wouldRecommend?: boolean | null
    responderName?: string | null
    responderEmail?: string | null
    createdAt?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutClientInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutClientInput, FeedbackUncheckedCreateWithoutClientInput>
  }

  export type FeedbackCreateManyClientInputEnvelope = {
    data: FeedbackCreateManyClientInput | FeedbackCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientSolutionCreateWithoutClientInput = {
    id?: string
    deployedAt?: Date | string | null
    status?: string
    solution: AISolutionCreateNestedOneWithoutClientSolutionsInput
  }

  export type ClientSolutionUncheckedCreateWithoutClientInput = {
    id?: string
    solutionId: string
    deployedAt?: Date | string | null
    status?: string
  }

  export type ClientSolutionCreateOrConnectWithoutClientInput = {
    where: ClientSolutionWhereUniqueInput
    create: XOR<ClientSolutionCreateWithoutClientInput, ClientSolutionUncheckedCreateWithoutClientInput>
  }

  export type ClientSolutionCreateManyClientInputEnvelope = {
    data: ClientSolutionCreateManyClientInput | ClientSolutionCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutClientInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managedBy?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagedByInput
    leads?: LeadCreateNestedManyWithoutOwnerInput
    opportunities?: OpportunityCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskCreateNestedManyWithoutAssigneeInput
    projectMilestones?: ProjectMilestoneCreateNestedManyWithoutOwnerInput
    tickets?: TicketCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutClientInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    subordinates?: UserUncheckedCreateNestedManyWithoutManagedByInput
    leads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskUncheckedCreateNestedManyWithoutAssigneeInput
    projectMilestones?: ProjectMilestoneUncheckedCreateNestedManyWithoutOwnerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutClientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type UserCreateManyClientInputEnvelope = {
    data: UserCreateManyClientInput | UserCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ContactUpsertWithWhereUniqueWithoutClientInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutClientInput, ContactUncheckedUpdateWithoutClientInput>
    create: XOR<ContactCreateWithoutClientInput, ContactUncheckedCreateWithoutClientInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutClientInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutClientInput, ContactUncheckedUpdateWithoutClientInput>
  }

  export type ContactUpdateManyWithWhereWithoutClientInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutClientInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    clientId?: StringFilter<"Contact"> | string
    firstName?: StringFilter<"Contact"> | string
    lastName?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    phone?: StringNullableFilter<"Contact"> | string | null
    jobTitle?: StringNullableFilter<"Contact"> | string | null
    isDecisionMaker?: BoolFilter<"Contact"> | boolean
    isInfluencer?: BoolFilter<"Contact"> | boolean
    isTechnicalLead?: BoolFilter<"Contact"> | boolean
    isEndUser?: BoolFilter<"Contact"> | boolean
    isBudgetHolder?: BoolFilter<"Contact"> | boolean
    influenceLevel?: IntFilter<"Contact"> | number
    relationshipScore?: IntFilter<"Contact"> | number
    lastInteraction?: DateTimeNullableFilter<"Contact"> | Date | string | null
    preferredChannel?: StringNullableFilter<"Contact"> | string | null
    isActive?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type LeadUpsertWithWhereUniqueWithoutClientInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutClientInput, LeadUncheckedUpdateWithoutClientInput>
    create: XOR<LeadCreateWithoutClientInput, LeadUncheckedCreateWithoutClientInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutClientInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutClientInput, LeadUncheckedUpdateWithoutClientInput>
  }

  export type LeadUpdateManyWithWhereWithoutClientInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutClientInput>
  }

  export type OpportunityUpsertWithWhereUniqueWithoutClientInput = {
    where: OpportunityWhereUniqueInput
    update: XOR<OpportunityUpdateWithoutClientInput, OpportunityUncheckedUpdateWithoutClientInput>
    create: XOR<OpportunityCreateWithoutClientInput, OpportunityUncheckedCreateWithoutClientInput>
  }

  export type OpportunityUpdateWithWhereUniqueWithoutClientInput = {
    where: OpportunityWhereUniqueInput
    data: XOR<OpportunityUpdateWithoutClientInput, OpportunityUncheckedUpdateWithoutClientInput>
  }

  export type OpportunityUpdateManyWithWhereWithoutClientInput = {
    where: OpportunityScalarWhereInput
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyWithoutClientInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
  }

  export type ProjectUpdateManyWithWhereWithoutClientInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutClientInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    opportunityId?: StringNullableFilter<"Project"> | string | null
    clientId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    actualEndDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    budget?: FloatFilter<"Project"> | number
    actualCost?: FloatFilter<"Project"> | number
    projectManagerId?: StringNullableFilter<"Project"> | string | null
    solutionType?: StringNullableFilter<"Project"> | string | null
    healthStatus?: StringFilter<"Project"> | string
    completionPercentage?: IntFilter<"Project"> | number
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutClientInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutClientInput, TicketUncheckedUpdateWithoutClientInput>
    create: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutClientInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutClientInput, TicketUncheckedUpdateWithoutClientInput>
  }

  export type TicketUpdateManyWithWhereWithoutClientInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutClientInput>
  }

  export type FeedbackUpsertWithWhereUniqueWithoutClientInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutClientInput, FeedbackUncheckedUpdateWithoutClientInput>
    create: XOR<FeedbackCreateWithoutClientInput, FeedbackUncheckedCreateWithoutClientInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutClientInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutClientInput, FeedbackUncheckedUpdateWithoutClientInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutClientInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutClientInput>
  }

  export type FeedbackScalarWhereInput = {
    AND?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    OR?: FeedbackScalarWhereInput[]
    NOT?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    id?: StringFilter<"Feedback"> | string
    clientId?: StringFilter<"Feedback"> | string
    projectId?: StringNullableFilter<"Feedback"> | string | null
    milestoneId?: StringNullableFilter<"Feedback"> | string | null
    type?: StringFilter<"Feedback"> | string
    rating?: IntFilter<"Feedback"> | number
    comments?: StringNullableFilter<"Feedback"> | string | null
    deliveredOnTime?: BoolNullableFilter<"Feedback"> | boolean | null
    metExpectations?: BoolNullableFilter<"Feedback"> | boolean | null
    wouldRecommend?: BoolNullableFilter<"Feedback"> | boolean | null
    responderName?: StringNullableFilter<"Feedback"> | string | null
    responderEmail?: StringNullableFilter<"Feedback"> | string | null
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
  }

  export type ClientSolutionUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientSolutionWhereUniqueInput
    update: XOR<ClientSolutionUpdateWithoutClientInput, ClientSolutionUncheckedUpdateWithoutClientInput>
    create: XOR<ClientSolutionCreateWithoutClientInput, ClientSolutionUncheckedCreateWithoutClientInput>
  }

  export type ClientSolutionUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientSolutionWhereUniqueInput
    data: XOR<ClientSolutionUpdateWithoutClientInput, ClientSolutionUncheckedUpdateWithoutClientInput>
  }

  export type ClientSolutionUpdateManyWithWhereWithoutClientInput = {
    where: ClientSolutionScalarWhereInput
    data: XOR<ClientSolutionUpdateManyMutationInput, ClientSolutionUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientSolutionScalarWhereInput = {
    AND?: ClientSolutionScalarWhereInput | ClientSolutionScalarWhereInput[]
    OR?: ClientSolutionScalarWhereInput[]
    NOT?: ClientSolutionScalarWhereInput | ClientSolutionScalarWhereInput[]
    id?: StringFilter<"ClientSolution"> | string
    clientId?: StringFilter<"ClientSolution"> | string
    solutionId?: StringFilter<"ClientSolution"> | string
    deployedAt?: DateTimeNullableFilter<"ClientSolution"> | Date | string | null
    status?: StringFilter<"ClientSolution"> | string
  }

  export type UserUpsertWithWhereUniqueWithoutClientInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type UserUpdateWithWhereUniqueWithoutClientInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
  }

  export type UserUpdateManyWithWhereWithoutClientInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientCreateWithoutAiSolutionsInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutClientInput
    leads?: LeadCreateNestedManyWithoutClientInput
    opportunities?: OpportunityCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    tickets?: TicketCreateNestedManyWithoutClientInput
    feedback?: FeedbackCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutAiSolutionsInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    tickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutAiSolutionsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAiSolutionsInput, ClientUncheckedCreateWithoutAiSolutionsInput>
  }

  export type AISolutionCreateWithoutClientSolutionsInput = {
    id?: string
    name: string
    category: string
    description?: string | null
    tagline?: string | null
    longDescription?: string | null
    targetIndustries?: AISolutionCreatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionCreatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionCreatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionCreateintegrationPointsInput | string[]
    pricingModels?: AISolutionCreatepricingModelsInput | string[]
    typicalTimelineWeeks?: number | null
    useCases?: AISolutionCreateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: AISolutionModuleCreateNestedManyWithoutSolutionInput
    quotes?: QuoteCreateNestedManyWithoutSolutionInput
  }

  export type AISolutionUncheckedCreateWithoutClientSolutionsInput = {
    id?: string
    name: string
    category: string
    description?: string | null
    tagline?: string | null
    longDescription?: string | null
    targetIndustries?: AISolutionCreatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionCreatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionCreatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionCreateintegrationPointsInput | string[]
    pricingModels?: AISolutionCreatepricingModelsInput | string[]
    typicalTimelineWeeks?: number | null
    useCases?: AISolutionCreateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: AISolutionModuleUncheckedCreateNestedManyWithoutSolutionInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutSolutionInput
  }

  export type AISolutionCreateOrConnectWithoutClientSolutionsInput = {
    where: AISolutionWhereUniqueInput
    create: XOR<AISolutionCreateWithoutClientSolutionsInput, AISolutionUncheckedCreateWithoutClientSolutionsInput>
  }

  export type ClientUpsertWithoutAiSolutionsInput = {
    update: XOR<ClientUpdateWithoutAiSolutionsInput, ClientUncheckedUpdateWithoutAiSolutionsInput>
    create: XOR<ClientCreateWithoutAiSolutionsInput, ClientUncheckedCreateWithoutAiSolutionsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutAiSolutionsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutAiSolutionsInput, ClientUncheckedUpdateWithoutAiSolutionsInput>
  }

  export type ClientUpdateWithoutAiSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutClientNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    opportunities?: OpportunityUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    tickets?: TicketUpdateManyWithoutClientNestedInput
    feedback?: FeedbackUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutAiSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
  }

  export type AISolutionUpsertWithoutClientSolutionsInput = {
    update: XOR<AISolutionUpdateWithoutClientSolutionsInput, AISolutionUncheckedUpdateWithoutClientSolutionsInput>
    create: XOR<AISolutionCreateWithoutClientSolutionsInput, AISolutionUncheckedCreateWithoutClientSolutionsInput>
    where?: AISolutionWhereInput
  }

  export type AISolutionUpdateToOneWithWhereWithoutClientSolutionsInput = {
    where?: AISolutionWhereInput
    data: XOR<AISolutionUpdateWithoutClientSolutionsInput, AISolutionUncheckedUpdateWithoutClientSolutionsInput>
  }

  export type AISolutionUpdateWithoutClientSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    targetIndustries?: AISolutionUpdatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionUpdatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionUpdatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionUpdateintegrationPointsInput | string[]
    pricingModels?: AISolutionUpdatepricingModelsInput | string[]
    typicalTimelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    useCases?: AISolutionUpdateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: AISolutionModuleUpdateManyWithoutSolutionNestedInput
    quotes?: QuoteUpdateManyWithoutSolutionNestedInput
  }

  export type AISolutionUncheckedUpdateWithoutClientSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    targetIndustries?: AISolutionUpdatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionUpdatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionUpdatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionUpdateintegrationPointsInput | string[]
    pricingModels?: AISolutionUpdatepricingModelsInput | string[]
    typicalTimelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    useCases?: AISolutionUpdateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: AISolutionModuleUncheckedUpdateManyWithoutSolutionNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutSolutionNestedInput
  }

  export type ClientCreateWithoutContactsInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leads?: LeadCreateNestedManyWithoutClientInput
    opportunities?: OpportunityCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    tickets?: TicketCreateNestedManyWithoutClientInput
    feedback?: FeedbackCreateNestedManyWithoutClientInput
    aiSolutions?: ClientSolutionCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutContactsInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    tickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutClientInput
    aiSolutions?: ClientSolutionUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutContactsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutContactsInput, ClientUncheckedCreateWithoutContactsInput>
  }

  export type ActivityCreateWithoutContactInput = {
    id?: string
    type: string
    subject: string
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    durationMinutes?: number | null
    outcome?: string | null
    sentiment?: string | null
    keyTopics?: ActivityCreatekeyTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutActivitiesInput
    lead?: LeadCreateNestedOneWithoutActivitiesInput
    opportunity?: OpportunityCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutContactInput = {
    id?: string
    ownerId: string
    leadId?: string | null
    opportunityId?: string | null
    type: string
    subject: string
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    durationMinutes?: number | null
    outcome?: string | null
    sentiment?: string | null
    keyTopics?: ActivityCreatekeyTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutContactInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput>
  }

  export type ActivityCreateManyContactInputEnvelope = {
    data: ActivityCreateManyContactInput | ActivityCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutContactsInput = {
    update: XOR<ClientUpdateWithoutContactsInput, ClientUncheckedUpdateWithoutContactsInput>
    create: XOR<ClientCreateWithoutContactsInput, ClientUncheckedCreateWithoutContactsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutContactsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutContactsInput, ClientUncheckedUpdateWithoutContactsInput>
  }

  export type ClientUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: LeadUpdateManyWithoutClientNestedInput
    opportunities?: OpportunityUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    tickets?: TicketUpdateManyWithoutClientNestedInput
    feedback?: FeedbackUpdateManyWithoutClientNestedInput
    aiSolutions?: ClientSolutionUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutClientNestedInput
    aiSolutions?: ClientSolutionUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ActivityUpsertWithWhereUniqueWithoutContactInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutContactInput, ActivityUncheckedUpdateWithoutContactInput>
    create: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutContactInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutContactInput, ActivityUncheckedUpdateWithoutContactInput>
  }

  export type ActivityUpdateManyWithWhereWithoutContactInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutContactInput>
  }

  export type ClientCreateWithoutLeadsInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutClientInput
    opportunities?: OpportunityCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    tickets?: TicketCreateNestedManyWithoutClientInput
    feedback?: FeedbackCreateNestedManyWithoutClientInput
    aiSolutions?: ClientSolutionCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutLeadsInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    tickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutClientInput
    aiSolutions?: ClientSolutionUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutLeadsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutLeadsInput, ClientUncheckedCreateWithoutLeadsInput>
  }

  export type UserCreateWithoutLeadsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutUsersInput
    managedBy?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagedByInput
    opportunities?: OpportunityCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskCreateNestedManyWithoutAssigneeInput
    projectMilestones?: ProjectMilestoneCreateNestedManyWithoutOwnerInput
    tickets?: TicketCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutLeadsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    managerId?: string | null
    subordinates?: UserUncheckedCreateNestedManyWithoutManagedByInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskUncheckedCreateNestedManyWithoutAssigneeInput
    projectMilestones?: ProjectMilestoneUncheckedCreateNestedManyWithoutOwnerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutLeadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeadsInput, UserUncheckedCreateWithoutLeadsInput>
  }

  export type ActivityCreateWithoutLeadInput = {
    id?: string
    type: string
    subject: string
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    durationMinutes?: number | null
    outcome?: string | null
    sentiment?: string | null
    keyTopics?: ActivityCreatekeyTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutActivitiesInput
    opportunity?: OpportunityCreateNestedOneWithoutActivitiesInput
    contact?: ContactCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutLeadInput = {
    id?: string
    ownerId: string
    opportunityId?: string | null
    contactId?: string | null
    type: string
    subject: string
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    durationMinutes?: number | null
    outcome?: string | null
    sentiment?: string | null
    keyTopics?: ActivityCreatekeyTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutLeadInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput>
  }

  export type ActivityCreateManyLeadInputEnvelope = {
    data: ActivityCreateManyLeadInput | ActivityCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityCreateWithoutLeadInput = {
    id?: string
    name: string
    stage?: $Enums.OpportunityStage
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    estimatedValue?: number
    weightedValue?: number
    nextStep?: string | null
    nextStepDate?: Date | string | null
    lostReason?: string | null
    wonReason?: string | null
    solutionType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutOpportunitiesInput
    owner: UserCreateNestedOneWithoutOpportunitiesInput
    activities?: ActivityCreateNestedManyWithoutOpportunityInput
    proposals?: ProposalCreateNestedManyWithoutOpportunityInput
    project?: ProjectCreateNestedOneWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutLeadInput = {
    id?: string
    clientId?: string | null
    ownerId: string
    name: string
    stage?: $Enums.OpportunityStage
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    estimatedValue?: number
    weightedValue?: number
    nextStep?: string | null
    nextStepDate?: Date | string | null
    lostReason?: string | null
    wonReason?: string | null
    solutionType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutOpportunityInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutOpportunityInput
    project?: ProjectUncheckedCreateNestedOneWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutLeadInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutLeadInput, OpportunityUncheckedCreateWithoutLeadInput>
  }

  export type OpportunityCreateManyLeadInputEnvelope = {
    data: OpportunityCreateManyLeadInput | OpportunityCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutLeadsInput = {
    update: XOR<ClientUpdateWithoutLeadsInput, ClientUncheckedUpdateWithoutLeadsInput>
    create: XOR<ClientCreateWithoutLeadsInput, ClientUncheckedCreateWithoutLeadsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutLeadsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutLeadsInput, ClientUncheckedUpdateWithoutLeadsInput>
  }

  export type ClientUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutClientNestedInput
    opportunities?: OpportunityUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    tickets?: TicketUpdateManyWithoutClientNestedInput
    feedback?: FeedbackUpdateManyWithoutClientNestedInput
    aiSolutions?: ClientSolutionUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutClientNestedInput
    aiSolutions?: ClientSolutionUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutLeadsInput = {
    update: XOR<UserUpdateWithoutLeadsInput, UserUncheckedUpdateWithoutLeadsInput>
    create: XOR<UserCreateWithoutLeadsInput, UserUncheckedCreateWithoutLeadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeadsInput, UserUncheckedUpdateWithoutLeadsInput>
  }

  export type UserUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutUsersNestedInput
    managedBy?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagedByNestedInput
    opportunities?: OpportunityUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUpdateManyWithoutAssigneeNestedInput
    projectMilestones?: ProjectMilestoneUpdateManyWithoutOwnerNestedInput
    tickets?: TicketUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    subordinates?: UserUncheckedUpdateManyWithoutManagedByNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    projectMilestones?: ProjectMilestoneUncheckedUpdateManyWithoutOwnerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ActivityUpsertWithWhereUniqueWithoutLeadInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutLeadInput, ActivityUncheckedUpdateWithoutLeadInput>
    create: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutLeadInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutLeadInput, ActivityUncheckedUpdateWithoutLeadInput>
  }

  export type ActivityUpdateManyWithWhereWithoutLeadInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutLeadInput>
  }

  export type OpportunityUpsertWithWhereUniqueWithoutLeadInput = {
    where: OpportunityWhereUniqueInput
    update: XOR<OpportunityUpdateWithoutLeadInput, OpportunityUncheckedUpdateWithoutLeadInput>
    create: XOR<OpportunityCreateWithoutLeadInput, OpportunityUncheckedCreateWithoutLeadInput>
  }

  export type OpportunityUpdateWithWhereUniqueWithoutLeadInput = {
    where: OpportunityWhereUniqueInput
    data: XOR<OpportunityUpdateWithoutLeadInput, OpportunityUncheckedUpdateWithoutLeadInput>
  }

  export type OpportunityUpdateManyWithWhereWithoutLeadInput = {
    where: OpportunityScalarWhereInput
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyWithoutLeadInput>
  }

  export type LeadCreateWithoutOpportunitiesInput = {
    id?: string
    source: string
    sourceDetails?: string | null
    status?: $Enums.LeadStatus
    companyName: string
    contactName: string
    contactEmail: string
    contactPhone?: string | null
    industry?: string | null
    companySize?: string | null
    leadScore?: number
    scoreTier?: string
    scoreReason?: string | null
    budgetRange?: string | null
    timeline?: string | null
    needDescription?: string | null
    convertedAt?: Date | string | null
    lostAt?: Date | string | null
    lossReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutLeadsInput
    owner: UserCreateNestedOneWithoutLeadsInput
    activities?: ActivityCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutOpportunitiesInput = {
    id?: string
    clientId?: string | null
    ownerId: string
    source: string
    sourceDetails?: string | null
    status?: $Enums.LeadStatus
    companyName: string
    contactName: string
    contactEmail: string
    contactPhone?: string | null
    industry?: string | null
    companySize?: string | null
    leadScore?: number
    scoreTier?: string
    scoreReason?: string | null
    budgetRange?: string | null
    timeline?: string | null
    needDescription?: string | null
    convertedAt?: Date | string | null
    lostAt?: Date | string | null
    lossReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutOpportunitiesInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutOpportunitiesInput, LeadUncheckedCreateWithoutOpportunitiesInput>
  }

  export type ClientCreateWithoutOpportunitiesInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutClientInput
    leads?: LeadCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    tickets?: TicketCreateNestedManyWithoutClientInput
    feedback?: FeedbackCreateNestedManyWithoutClientInput
    aiSolutions?: ClientSolutionCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutOpportunitiesInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    tickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutClientInput
    aiSolutions?: ClientSolutionUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutOpportunitiesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutOpportunitiesInput, ClientUncheckedCreateWithoutOpportunitiesInput>
  }

  export type UserCreateWithoutOpportunitiesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutUsersInput
    managedBy?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagedByInput
    leads?: LeadCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskCreateNestedManyWithoutAssigneeInput
    projectMilestones?: ProjectMilestoneCreateNestedManyWithoutOwnerInput
    tickets?: TicketCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutOpportunitiesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    managerId?: string | null
    subordinates?: UserUncheckedCreateNestedManyWithoutManagedByInput
    leads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskUncheckedCreateNestedManyWithoutAssigneeInput
    projectMilestones?: ProjectMilestoneUncheckedCreateNestedManyWithoutOwnerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutOpportunitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOpportunitiesInput, UserUncheckedCreateWithoutOpportunitiesInput>
  }

  export type ActivityCreateWithoutOpportunityInput = {
    id?: string
    type: string
    subject: string
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    durationMinutes?: number | null
    outcome?: string | null
    sentiment?: string | null
    keyTopics?: ActivityCreatekeyTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutActivitiesInput
    lead?: LeadCreateNestedOneWithoutActivitiesInput
    contact?: ContactCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutOpportunityInput = {
    id?: string
    ownerId: string
    leadId?: string | null
    contactId?: string | null
    type: string
    subject: string
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    durationMinutes?: number | null
    outcome?: string | null
    sentiment?: string | null
    keyTopics?: ActivityCreatekeyTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutOpportunityInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutOpportunityInput, ActivityUncheckedCreateWithoutOpportunityInput>
  }

  export type ActivityCreateManyOpportunityInputEnvelope = {
    data: ActivityCreateManyOpportunityInput | ActivityCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type ProposalCreateWithoutOpportunityInput = {
    id?: string
    version?: number
    title: string
    content?: NullableJsonNullValueInput | InputJsonValue
    solutionDescription?: string | null
    implementationPlan?: string | null
    timelineWeeks?: number | null
    basePrice?: number
    discount?: number
    finalPrice?: number
    terms?: string | null
    status?: string
    approvalStatus?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    signedAt?: Date | string | null
    documentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalUncheckedCreateWithoutOpportunityInput = {
    id?: string
    version?: number
    title: string
    content?: NullableJsonNullValueInput | InputJsonValue
    solutionDescription?: string | null
    implementationPlan?: string | null
    timelineWeeks?: number | null
    basePrice?: number
    discount?: number
    finalPrice?: number
    terms?: string | null
    status?: string
    approvalStatus?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    signedAt?: Date | string | null
    documentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalCreateOrConnectWithoutOpportunityInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutOpportunityInput, ProposalUncheckedCreateWithoutOpportunityInput>
  }

  export type ProposalCreateManyOpportunityInputEnvelope = {
    data: ProposalCreateManyOpportunityInput | ProposalCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutOpportunityInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    budget?: number
    actualCost?: number
    projectManagerId?: string | null
    solutionType?: string | null
    healthStatus?: string
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutProjectsInput
    milestones?: ProjectMilestoneCreateNestedManyWithoutProjectInput
    tasks?: ProjectTaskCreateNestedManyWithoutProjectInput
    metrics?: ProjectMetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutOpportunityInput = {
    id?: string
    clientId: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    budget?: number
    actualCost?: number
    projectManagerId?: string | null
    solutionType?: string | null
    healthStatus?: string
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: ProjectMilestoneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: ProjectTaskUncheckedCreateNestedManyWithoutProjectInput
    metrics?: ProjectMetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutOpportunityInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutOpportunityInput, ProjectUncheckedCreateWithoutOpportunityInput>
  }

  export type LeadUpsertWithoutOpportunitiesInput = {
    update: XOR<LeadUpdateWithoutOpportunitiesInput, LeadUncheckedUpdateWithoutOpportunitiesInput>
    create: XOR<LeadCreateWithoutOpportunitiesInput, LeadUncheckedCreateWithoutOpportunitiesInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutOpportunitiesInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutOpportunitiesInput, LeadUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type LeadUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceDetails?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    leadScore?: IntFieldUpdateOperationsInput | number
    scoreTier?: StringFieldUpdateOperationsInput | string
    scoreReason?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    needDescription?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutLeadsNestedInput
    owner?: UserUpdateOneRequiredWithoutLeadsNestedInput
    activities?: ActivityUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceDetails?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    leadScore?: IntFieldUpdateOperationsInput | number
    scoreTier?: StringFieldUpdateOperationsInput | string
    scoreReason?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    needDescription?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type ClientUpsertWithoutOpportunitiesInput = {
    update: XOR<ClientUpdateWithoutOpportunitiesInput, ClientUncheckedUpdateWithoutOpportunitiesInput>
    create: XOR<ClientCreateWithoutOpportunitiesInput, ClientUncheckedCreateWithoutOpportunitiesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutOpportunitiesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutOpportunitiesInput, ClientUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type ClientUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutClientNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    tickets?: TicketUpdateManyWithoutClientNestedInput
    feedback?: FeedbackUpdateManyWithoutClientNestedInput
    aiSolutions?: ClientSolutionUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutClientNestedInput
    aiSolutions?: ClientSolutionUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutOpportunitiesInput = {
    update: XOR<UserUpdateWithoutOpportunitiesInput, UserUncheckedUpdateWithoutOpportunitiesInput>
    create: XOR<UserCreateWithoutOpportunitiesInput, UserUncheckedCreateWithoutOpportunitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOpportunitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOpportunitiesInput, UserUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type UserUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutUsersNestedInput
    managedBy?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagedByNestedInput
    leads?: LeadUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUpdateManyWithoutAssigneeNestedInput
    projectMilestones?: ProjectMilestoneUpdateManyWithoutOwnerNestedInput
    tickets?: TicketUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    subordinates?: UserUncheckedUpdateManyWithoutManagedByNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    projectMilestones?: ProjectMilestoneUncheckedUpdateManyWithoutOwnerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ActivityUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutOpportunityInput, ActivityUncheckedUpdateWithoutOpportunityInput>
    create: XOR<ActivityCreateWithoutOpportunityInput, ActivityUncheckedCreateWithoutOpportunityInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutOpportunityInput, ActivityUncheckedUpdateWithoutOpportunityInput>
  }

  export type ActivityUpdateManyWithWhereWithoutOpportunityInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type ProposalUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: ProposalWhereUniqueInput
    update: XOR<ProposalUpdateWithoutOpportunityInput, ProposalUncheckedUpdateWithoutOpportunityInput>
    create: XOR<ProposalCreateWithoutOpportunityInput, ProposalUncheckedCreateWithoutOpportunityInput>
  }

  export type ProposalUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: ProposalWhereUniqueInput
    data: XOR<ProposalUpdateWithoutOpportunityInput, ProposalUncheckedUpdateWithoutOpportunityInput>
  }

  export type ProposalUpdateManyWithWhereWithoutOpportunityInput = {
    where: ProposalScalarWhereInput
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type ProposalScalarWhereInput = {
    AND?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
    OR?: ProposalScalarWhereInput[]
    NOT?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
    id?: StringFilter<"Proposal"> | string
    opportunityId?: StringFilter<"Proposal"> | string
    version?: IntFilter<"Proposal"> | number
    title?: StringFilter<"Proposal"> | string
    content?: JsonNullableFilter<"Proposal">
    solutionDescription?: StringNullableFilter<"Proposal"> | string | null
    implementationPlan?: StringNullableFilter<"Proposal"> | string | null
    timelineWeeks?: IntNullableFilter<"Proposal"> | number | null
    basePrice?: FloatFilter<"Proposal"> | number
    discount?: FloatFilter<"Proposal"> | number
    finalPrice?: FloatFilter<"Proposal"> | number
    terms?: StringNullableFilter<"Proposal"> | string | null
    status?: StringFilter<"Proposal"> | string
    approvalStatus?: StringFilter<"Proposal"> | string
    approvedBy?: StringNullableFilter<"Proposal"> | string | null
    approvedAt?: DateTimeNullableFilter<"Proposal"> | Date | string | null
    signedAt?: DateTimeNullableFilter<"Proposal"> | Date | string | null
    documentUrl?: StringNullableFilter<"Proposal"> | string | null
    createdAt?: DateTimeFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeFilter<"Proposal"> | Date | string
  }

  export type ProjectUpsertWithoutOpportunityInput = {
    update: XOR<ProjectUpdateWithoutOpportunityInput, ProjectUncheckedUpdateWithoutOpportunityInput>
    create: XOR<ProjectCreateWithoutOpportunityInput, ProjectUncheckedCreateWithoutOpportunityInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutOpportunityInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutOpportunityInput, ProjectUncheckedUpdateWithoutOpportunityInput>
  }

  export type ProjectUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualCost?: FloatFieldUpdateOperationsInput | number
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    healthStatus?: StringFieldUpdateOperationsInput | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutProjectsNestedInput
    milestones?: ProjectMilestoneUpdateManyWithoutProjectNestedInput
    tasks?: ProjectTaskUpdateManyWithoutProjectNestedInput
    metrics?: ProjectMetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualCost?: FloatFieldUpdateOperationsInput | number
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    healthStatus?: StringFieldUpdateOperationsInput | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: ProjectMilestoneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: ProjectTaskUncheckedUpdateManyWithoutProjectNestedInput
    metrics?: ProjectMetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type OpportunityCreateWithoutProposalsInput = {
    id?: string
    name: string
    stage?: $Enums.OpportunityStage
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    estimatedValue?: number
    weightedValue?: number
    nextStep?: string | null
    nextStepDate?: Date | string | null
    lostReason?: string | null
    wonReason?: string | null
    solutionType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lead?: LeadCreateNestedOneWithoutOpportunitiesInput
    client?: ClientCreateNestedOneWithoutOpportunitiesInput
    owner: UserCreateNestedOneWithoutOpportunitiesInput
    activities?: ActivityCreateNestedManyWithoutOpportunityInput
    project?: ProjectCreateNestedOneWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutProposalsInput = {
    id?: string
    leadId?: string | null
    clientId?: string | null
    ownerId: string
    name: string
    stage?: $Enums.OpportunityStage
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    estimatedValue?: number
    weightedValue?: number
    nextStep?: string | null
    nextStepDate?: Date | string | null
    lostReason?: string | null
    wonReason?: string | null
    solutionType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutOpportunityInput
    project?: ProjectUncheckedCreateNestedOneWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutProposalsInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutProposalsInput, OpportunityUncheckedCreateWithoutProposalsInput>
  }

  export type OpportunityUpsertWithoutProposalsInput = {
    update: XOR<OpportunityUpdateWithoutProposalsInput, OpportunityUncheckedUpdateWithoutProposalsInput>
    create: XOR<OpportunityCreateWithoutProposalsInput, OpportunityUncheckedCreateWithoutProposalsInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutProposalsInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutProposalsInput, OpportunityUncheckedUpdateWithoutProposalsInput>
  }

  export type OpportunityUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneWithoutOpportunitiesNestedInput
    client?: ClientUpdateOneWithoutOpportunitiesNestedInput
    owner?: UserUpdateOneRequiredWithoutOpportunitiesNestedInput
    activities?: ActivityUpdateManyWithoutOpportunityNestedInput
    project?: ProjectUpdateOneWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutOpportunityNestedInput
    project?: ProjectUncheckedUpdateOneWithoutOpportunityNestedInput
  }

  export type OpportunityCreateWithoutProjectInput = {
    id?: string
    name: string
    stage?: $Enums.OpportunityStage
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    estimatedValue?: number
    weightedValue?: number
    nextStep?: string | null
    nextStepDate?: Date | string | null
    lostReason?: string | null
    wonReason?: string | null
    solutionType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lead?: LeadCreateNestedOneWithoutOpportunitiesInput
    client?: ClientCreateNestedOneWithoutOpportunitiesInput
    owner: UserCreateNestedOneWithoutOpportunitiesInput
    activities?: ActivityCreateNestedManyWithoutOpportunityInput
    proposals?: ProposalCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutProjectInput = {
    id?: string
    leadId?: string | null
    clientId?: string | null
    ownerId: string
    name: string
    stage?: $Enums.OpportunityStage
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    estimatedValue?: number
    weightedValue?: number
    nextStep?: string | null
    nextStepDate?: Date | string | null
    lostReason?: string | null
    wonReason?: string | null
    solutionType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutOpportunityInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutProjectInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutProjectInput, OpportunityUncheckedCreateWithoutProjectInput>
  }

  export type ClientCreateWithoutProjectsInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutClientInput
    leads?: LeadCreateNestedManyWithoutClientInput
    opportunities?: OpportunityCreateNestedManyWithoutClientInput
    tickets?: TicketCreateNestedManyWithoutClientInput
    feedback?: FeedbackCreateNestedManyWithoutClientInput
    aiSolutions?: ClientSolutionCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutClientInput
    tickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutClientInput
    aiSolutions?: ClientSolutionUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutProjectsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectMilestoneCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.MilestoneStatus
    phase?: string | null
    order: number
    plannedStartDate?: Date | string | null
    plannedEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    completionCriteria?: string | null
    dependsOnId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutProjectMilestonesInput
  }

  export type ProjectMilestoneUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.MilestoneStatus
    phase?: string | null
    order: number
    plannedStartDate?: Date | string | null
    plannedEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    completionCriteria?: string | null
    ownerId?: string | null
    dependsOnId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMilestoneCreateOrConnectWithoutProjectInput = {
    where: ProjectMilestoneWhereUniqueInput
    create: XOR<ProjectMilestoneCreateWithoutProjectInput, ProjectMilestoneUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMilestoneCreateManyProjectInputEnvelope = {
    data: ProjectMilestoneCreateManyProjectInput | ProjectMilestoneCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectTaskCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: string
    phase?: string | null
    parentTaskId?: string | null
    plannedHours?: number | null
    actualHours?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    blockerReason?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignee?: UserCreateNestedOneWithoutProjectTasksInput
  }

  export type ProjectTaskUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: string
    phase?: string | null
    assigneeId?: string | null
    parentTaskId?: string | null
    plannedHours?: number | null
    actualHours?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    blockerReason?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTaskCreateOrConnectWithoutProjectInput = {
    where: ProjectTaskWhereUniqueInput
    create: XOR<ProjectTaskCreateWithoutProjectInput, ProjectTaskUncheckedCreateWithoutProjectInput>
  }

  export type ProjectTaskCreateManyProjectInputEnvelope = {
    data: ProjectTaskCreateManyProjectInput | ProjectTaskCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMetricCreateWithoutProjectInput = {
    id?: string
    metricName: string
    metricCategory: string
    value: number
    unit?: string | null
    baselineValue?: number | null
    targetValue?: number | null
    recordedAt?: Date | string
  }

  export type ProjectMetricUncheckedCreateWithoutProjectInput = {
    id?: string
    metricName: string
    metricCategory: string
    value: number
    unit?: string | null
    baselineValue?: number | null
    targetValue?: number | null
    recordedAt?: Date | string
  }

  export type ProjectMetricCreateOrConnectWithoutProjectInput = {
    where: ProjectMetricWhereUniqueInput
    create: XOR<ProjectMetricCreateWithoutProjectInput, ProjectMetricUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMetricCreateManyProjectInputEnvelope = {
    data: ProjectMetricCreateManyProjectInput | ProjectMetricCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityUpsertWithoutProjectInput = {
    update: XOR<OpportunityUpdateWithoutProjectInput, OpportunityUncheckedUpdateWithoutProjectInput>
    create: XOR<OpportunityCreateWithoutProjectInput, OpportunityUncheckedCreateWithoutProjectInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutProjectInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutProjectInput, OpportunityUncheckedUpdateWithoutProjectInput>
  }

  export type OpportunityUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneWithoutOpportunitiesNestedInput
    client?: ClientUpdateOneWithoutOpportunitiesNestedInput
    owner?: UserUpdateOneRequiredWithoutOpportunitiesNestedInput
    activities?: ActivityUpdateManyWithoutOpportunityNestedInput
    proposals?: ProposalUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutOpportunityNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type ClientUpsertWithoutProjectsInput = {
    update: XOR<ClientUpdateWithoutProjectsInput, ClientUncheckedUpdateWithoutProjectsInput>
    create: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutProjectsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutProjectsInput, ClientUncheckedUpdateWithoutProjectsInput>
  }

  export type ClientUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutClientNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    opportunities?: OpportunityUpdateManyWithoutClientNestedInput
    tickets?: TicketUpdateManyWithoutClientNestedInput
    feedback?: FeedbackUpdateManyWithoutClientNestedInput
    aiSolutions?: ClientSolutionUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutClientNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutClientNestedInput
    aiSolutions?: ClientSolutionUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ProjectMilestoneUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectMilestoneWhereUniqueInput
    update: XOR<ProjectMilestoneUpdateWithoutProjectInput, ProjectMilestoneUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectMilestoneCreateWithoutProjectInput, ProjectMilestoneUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMilestoneUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectMilestoneWhereUniqueInput
    data: XOR<ProjectMilestoneUpdateWithoutProjectInput, ProjectMilestoneUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMilestoneUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectMilestoneScalarWhereInput
    data: XOR<ProjectMilestoneUpdateManyMutationInput, ProjectMilestoneUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectTaskUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectTaskWhereUniqueInput
    update: XOR<ProjectTaskUpdateWithoutProjectInput, ProjectTaskUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectTaskCreateWithoutProjectInput, ProjectTaskUncheckedCreateWithoutProjectInput>
  }

  export type ProjectTaskUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectTaskWhereUniqueInput
    data: XOR<ProjectTaskUpdateWithoutProjectInput, ProjectTaskUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectTaskUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectTaskScalarWhereInput
    data: XOR<ProjectTaskUpdateManyMutationInput, ProjectTaskUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectMetricUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectMetricWhereUniqueInput
    update: XOR<ProjectMetricUpdateWithoutProjectInput, ProjectMetricUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectMetricCreateWithoutProjectInput, ProjectMetricUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMetricUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectMetricWhereUniqueInput
    data: XOR<ProjectMetricUpdateWithoutProjectInput, ProjectMetricUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMetricUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectMetricScalarWhereInput
    data: XOR<ProjectMetricUpdateManyMutationInput, ProjectMetricUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectMetricScalarWhereInput = {
    AND?: ProjectMetricScalarWhereInput | ProjectMetricScalarWhereInput[]
    OR?: ProjectMetricScalarWhereInput[]
    NOT?: ProjectMetricScalarWhereInput | ProjectMetricScalarWhereInput[]
    id?: StringFilter<"ProjectMetric"> | string
    projectId?: StringFilter<"ProjectMetric"> | string
    metricName?: StringFilter<"ProjectMetric"> | string
    metricCategory?: StringFilter<"ProjectMetric"> | string
    value?: FloatFilter<"ProjectMetric"> | number
    unit?: StringNullableFilter<"ProjectMetric"> | string | null
    baselineValue?: FloatNullableFilter<"ProjectMetric"> | number | null
    targetValue?: FloatNullableFilter<"ProjectMetric"> | number | null
    recordedAt?: DateTimeFilter<"ProjectMetric"> | Date | string
  }

  export type ProjectCreateWithoutMilestonesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    budget?: number
    actualCost?: number
    projectManagerId?: string | null
    solutionType?: string | null
    healthStatus?: string
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunity?: OpportunityCreateNestedOneWithoutProjectInput
    client: ClientCreateNestedOneWithoutProjectsInput
    tasks?: ProjectTaskCreateNestedManyWithoutProjectInput
    metrics?: ProjectMetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMilestonesInput = {
    id?: string
    opportunityId?: string | null
    clientId: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    budget?: number
    actualCost?: number
    projectManagerId?: string | null
    solutionType?: string | null
    healthStatus?: string
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: ProjectTaskUncheckedCreateNestedManyWithoutProjectInput
    metrics?: ProjectMetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMilestonesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
  }

  export type UserCreateWithoutProjectMilestonesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutUsersInput
    managedBy?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagedByInput
    leads?: LeadCreateNestedManyWithoutOwnerInput
    opportunities?: OpportunityCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskCreateNestedManyWithoutAssigneeInput
    tickets?: TicketCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutProjectMilestonesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    managerId?: string | null
    subordinates?: UserUncheckedCreateNestedManyWithoutManagedByInput
    leads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskUncheckedCreateNestedManyWithoutAssigneeInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutProjectMilestonesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectMilestonesInput, UserUncheckedCreateWithoutProjectMilestonesInput>
  }

  export type ProjectUpsertWithoutMilestonesInput = {
    update: XOR<ProjectUpdateWithoutMilestonesInput, ProjectUncheckedUpdateWithoutMilestonesInput>
    create: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMilestonesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMilestonesInput, ProjectUncheckedUpdateWithoutMilestonesInput>
  }

  export type ProjectUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualCost?: FloatFieldUpdateOperationsInput | number
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    healthStatus?: StringFieldUpdateOperationsInput | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunity?: OpportunityUpdateOneWithoutProjectNestedInput
    client?: ClientUpdateOneRequiredWithoutProjectsNestedInput
    tasks?: ProjectTaskUpdateManyWithoutProjectNestedInput
    metrics?: ProjectMetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualCost?: FloatFieldUpdateOperationsInput | number
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    healthStatus?: StringFieldUpdateOperationsInput | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: ProjectTaskUncheckedUpdateManyWithoutProjectNestedInput
    metrics?: ProjectMetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectMilestonesInput = {
    update: XOR<UserUpdateWithoutProjectMilestonesInput, UserUncheckedUpdateWithoutProjectMilestonesInput>
    create: XOR<UserCreateWithoutProjectMilestonesInput, UserUncheckedCreateWithoutProjectMilestonesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectMilestonesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectMilestonesInput, UserUncheckedUpdateWithoutProjectMilestonesInput>
  }

  export type UserUpdateWithoutProjectMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutUsersNestedInput
    managedBy?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagedByNestedInput
    leads?: LeadUpdateManyWithoutOwnerNestedInput
    opportunities?: OpportunityUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUpdateManyWithoutAssigneeNestedInput
    tickets?: TicketUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    subordinates?: UserUncheckedUpdateManyWithoutManagedByNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ProjectCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    budget?: number
    actualCost?: number
    projectManagerId?: string | null
    solutionType?: string | null
    healthStatus?: string
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunity?: OpportunityCreateNestedOneWithoutProjectInput
    client: ClientCreateNestedOneWithoutProjectsInput
    milestones?: ProjectMilestoneCreateNestedManyWithoutProjectInput
    metrics?: ProjectMetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTasksInput = {
    id?: string
    opportunityId?: string | null
    clientId: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    budget?: number
    actualCost?: number
    projectManagerId?: string | null
    solutionType?: string | null
    healthStatus?: string
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: ProjectMilestoneUncheckedCreateNestedManyWithoutProjectInput
    metrics?: ProjectMetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTasksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
  }

  export type UserCreateWithoutProjectTasksInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutUsersInput
    managedBy?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagedByInput
    leads?: LeadCreateNestedManyWithoutOwnerInput
    opportunities?: OpportunityCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutOwnerInput
    projectMilestones?: ProjectMilestoneCreateNestedManyWithoutOwnerInput
    tickets?: TicketCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutProjectTasksInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    managerId?: string | null
    subordinates?: UserUncheckedCreateNestedManyWithoutManagedByInput
    leads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    projectMilestones?: ProjectMilestoneUncheckedCreateNestedManyWithoutOwnerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutProjectTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectTasksInput, UserUncheckedCreateWithoutProjectTasksInput>
  }

  export type ProjectUpsertWithoutTasksInput = {
    update: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTasksInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualCost?: FloatFieldUpdateOperationsInput | number
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    healthStatus?: StringFieldUpdateOperationsInput | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunity?: OpportunityUpdateOneWithoutProjectNestedInput
    client?: ClientUpdateOneRequiredWithoutProjectsNestedInput
    milestones?: ProjectMilestoneUpdateManyWithoutProjectNestedInput
    metrics?: ProjectMetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualCost?: FloatFieldUpdateOperationsInput | number
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    healthStatus?: StringFieldUpdateOperationsInput | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: ProjectMilestoneUncheckedUpdateManyWithoutProjectNestedInput
    metrics?: ProjectMetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectTasksInput = {
    update: XOR<UserUpdateWithoutProjectTasksInput, UserUncheckedUpdateWithoutProjectTasksInput>
    create: XOR<UserCreateWithoutProjectTasksInput, UserUncheckedCreateWithoutProjectTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectTasksInput, UserUncheckedUpdateWithoutProjectTasksInput>
  }

  export type UserUpdateWithoutProjectTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutUsersNestedInput
    managedBy?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagedByNestedInput
    leads?: LeadUpdateManyWithoutOwnerNestedInput
    opportunities?: OpportunityUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutOwnerNestedInput
    projectMilestones?: ProjectMilestoneUpdateManyWithoutOwnerNestedInput
    tickets?: TicketUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    subordinates?: UserUncheckedUpdateManyWithoutManagedByNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    projectMilestones?: ProjectMilestoneUncheckedUpdateManyWithoutOwnerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ProjectCreateWithoutMetricsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    budget?: number
    actualCost?: number
    projectManagerId?: string | null
    solutionType?: string | null
    healthStatus?: string
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunity?: OpportunityCreateNestedOneWithoutProjectInput
    client: ClientCreateNestedOneWithoutProjectsInput
    milestones?: ProjectMilestoneCreateNestedManyWithoutProjectInput
    tasks?: ProjectTaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMetricsInput = {
    id?: string
    opportunityId?: string | null
    clientId: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    budget?: number
    actualCost?: number
    projectManagerId?: string | null
    solutionType?: string | null
    healthStatus?: string
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: ProjectMilestoneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: ProjectTaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMetricsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMetricsInput, ProjectUncheckedCreateWithoutMetricsInput>
  }

  export type ProjectUpsertWithoutMetricsInput = {
    update: XOR<ProjectUpdateWithoutMetricsInput, ProjectUncheckedUpdateWithoutMetricsInput>
    create: XOR<ProjectCreateWithoutMetricsInput, ProjectUncheckedCreateWithoutMetricsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMetricsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMetricsInput, ProjectUncheckedUpdateWithoutMetricsInput>
  }

  export type ProjectUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualCost?: FloatFieldUpdateOperationsInput | number
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    healthStatus?: StringFieldUpdateOperationsInput | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunity?: OpportunityUpdateOneWithoutProjectNestedInput
    client?: ClientUpdateOneRequiredWithoutProjectsNestedInput
    milestones?: ProjectMilestoneUpdateManyWithoutProjectNestedInput
    tasks?: ProjectTaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualCost?: FloatFieldUpdateOperationsInput | number
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    healthStatus?: StringFieldUpdateOperationsInput | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: ProjectMilestoneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: ProjectTaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type AISolutionModuleCreateWithoutSolutionInput = {
    id?: string
    name: string
    description?: string | null
    basePrice?: number
    isOptional?: boolean
  }

  export type AISolutionModuleUncheckedCreateWithoutSolutionInput = {
    id?: string
    name: string
    description?: string | null
    basePrice?: number
    isOptional?: boolean
  }

  export type AISolutionModuleCreateOrConnectWithoutSolutionInput = {
    where: AISolutionModuleWhereUniqueInput
    create: XOR<AISolutionModuleCreateWithoutSolutionInput, AISolutionModuleUncheckedCreateWithoutSolutionInput>
  }

  export type AISolutionModuleCreateManySolutionInputEnvelope = {
    data: AISolutionModuleCreateManySolutionInput | AISolutionModuleCreateManySolutionInput[]
    skipDuplicates?: boolean
  }

  export type QuoteCreateWithoutSolutionInput = {
    id?: string
    clientId?: string | null
    quoteNumber: string
    version?: number
    status?: string
    scope?: string | null
    timelineWeeks?: number | null
    totalPrice?: number
    validUntil?: Date | string | null
    requestedBy?: string | null
    requestedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteUncheckedCreateWithoutSolutionInput = {
    id?: string
    clientId?: string | null
    quoteNumber: string
    version?: number
    status?: string
    scope?: string | null
    timelineWeeks?: number | null
    totalPrice?: number
    validUntil?: Date | string | null
    requestedBy?: string | null
    requestedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteCreateOrConnectWithoutSolutionInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutSolutionInput, QuoteUncheckedCreateWithoutSolutionInput>
  }

  export type QuoteCreateManySolutionInputEnvelope = {
    data: QuoteCreateManySolutionInput | QuoteCreateManySolutionInput[]
    skipDuplicates?: boolean
  }

  export type ClientSolutionCreateWithoutSolutionInput = {
    id?: string
    deployedAt?: Date | string | null
    status?: string
    client: ClientCreateNestedOneWithoutAiSolutionsInput
  }

  export type ClientSolutionUncheckedCreateWithoutSolutionInput = {
    id?: string
    clientId: string
    deployedAt?: Date | string | null
    status?: string
  }

  export type ClientSolutionCreateOrConnectWithoutSolutionInput = {
    where: ClientSolutionWhereUniqueInput
    create: XOR<ClientSolutionCreateWithoutSolutionInput, ClientSolutionUncheckedCreateWithoutSolutionInput>
  }

  export type ClientSolutionCreateManySolutionInputEnvelope = {
    data: ClientSolutionCreateManySolutionInput | ClientSolutionCreateManySolutionInput[]
    skipDuplicates?: boolean
  }

  export type AISolutionModuleUpsertWithWhereUniqueWithoutSolutionInput = {
    where: AISolutionModuleWhereUniqueInput
    update: XOR<AISolutionModuleUpdateWithoutSolutionInput, AISolutionModuleUncheckedUpdateWithoutSolutionInput>
    create: XOR<AISolutionModuleCreateWithoutSolutionInput, AISolutionModuleUncheckedCreateWithoutSolutionInput>
  }

  export type AISolutionModuleUpdateWithWhereUniqueWithoutSolutionInput = {
    where: AISolutionModuleWhereUniqueInput
    data: XOR<AISolutionModuleUpdateWithoutSolutionInput, AISolutionModuleUncheckedUpdateWithoutSolutionInput>
  }

  export type AISolutionModuleUpdateManyWithWhereWithoutSolutionInput = {
    where: AISolutionModuleScalarWhereInput
    data: XOR<AISolutionModuleUpdateManyMutationInput, AISolutionModuleUncheckedUpdateManyWithoutSolutionInput>
  }

  export type AISolutionModuleScalarWhereInput = {
    AND?: AISolutionModuleScalarWhereInput | AISolutionModuleScalarWhereInput[]
    OR?: AISolutionModuleScalarWhereInput[]
    NOT?: AISolutionModuleScalarWhereInput | AISolutionModuleScalarWhereInput[]
    id?: StringFilter<"AISolutionModule"> | string
    solutionId?: StringFilter<"AISolutionModule"> | string
    name?: StringFilter<"AISolutionModule"> | string
    description?: StringNullableFilter<"AISolutionModule"> | string | null
    basePrice?: FloatFilter<"AISolutionModule"> | number
    isOptional?: BoolFilter<"AISolutionModule"> | boolean
  }

  export type QuoteUpsertWithWhereUniqueWithoutSolutionInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutSolutionInput, QuoteUncheckedUpdateWithoutSolutionInput>
    create: XOR<QuoteCreateWithoutSolutionInput, QuoteUncheckedCreateWithoutSolutionInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutSolutionInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutSolutionInput, QuoteUncheckedUpdateWithoutSolutionInput>
  }

  export type QuoteUpdateManyWithWhereWithoutSolutionInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutSolutionInput>
  }

  export type QuoteScalarWhereInput = {
    AND?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
    OR?: QuoteScalarWhereInput[]
    NOT?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
    id?: StringFilter<"Quote"> | string
    solutionId?: StringFilter<"Quote"> | string
    clientId?: StringNullableFilter<"Quote"> | string | null
    quoteNumber?: StringFilter<"Quote"> | string
    version?: IntFilter<"Quote"> | number
    status?: StringFilter<"Quote"> | string
    scope?: StringNullableFilter<"Quote"> | string | null
    timelineWeeks?: IntNullableFilter<"Quote"> | number | null
    totalPrice?: FloatFilter<"Quote"> | number
    validUntil?: DateTimeNullableFilter<"Quote"> | Date | string | null
    requestedBy?: StringNullableFilter<"Quote"> | string | null
    requestedAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
  }

  export type ClientSolutionUpsertWithWhereUniqueWithoutSolutionInput = {
    where: ClientSolutionWhereUniqueInput
    update: XOR<ClientSolutionUpdateWithoutSolutionInput, ClientSolutionUncheckedUpdateWithoutSolutionInput>
    create: XOR<ClientSolutionCreateWithoutSolutionInput, ClientSolutionUncheckedCreateWithoutSolutionInput>
  }

  export type ClientSolutionUpdateWithWhereUniqueWithoutSolutionInput = {
    where: ClientSolutionWhereUniqueInput
    data: XOR<ClientSolutionUpdateWithoutSolutionInput, ClientSolutionUncheckedUpdateWithoutSolutionInput>
  }

  export type ClientSolutionUpdateManyWithWhereWithoutSolutionInput = {
    where: ClientSolutionScalarWhereInput
    data: XOR<ClientSolutionUpdateManyMutationInput, ClientSolutionUncheckedUpdateManyWithoutSolutionInput>
  }

  export type AISolutionCreateWithoutModulesInput = {
    id?: string
    name: string
    category: string
    description?: string | null
    tagline?: string | null
    longDescription?: string | null
    targetIndustries?: AISolutionCreatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionCreatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionCreatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionCreateintegrationPointsInput | string[]
    pricingModels?: AISolutionCreatepricingModelsInput | string[]
    typicalTimelineWeeks?: number | null
    useCases?: AISolutionCreateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: QuoteCreateNestedManyWithoutSolutionInput
    clientSolutions?: ClientSolutionCreateNestedManyWithoutSolutionInput
  }

  export type AISolutionUncheckedCreateWithoutModulesInput = {
    id?: string
    name: string
    category: string
    description?: string | null
    tagline?: string | null
    longDescription?: string | null
    targetIndustries?: AISolutionCreatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionCreatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionCreatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionCreateintegrationPointsInput | string[]
    pricingModels?: AISolutionCreatepricingModelsInput | string[]
    typicalTimelineWeeks?: number | null
    useCases?: AISolutionCreateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: QuoteUncheckedCreateNestedManyWithoutSolutionInput
    clientSolutions?: ClientSolutionUncheckedCreateNestedManyWithoutSolutionInput
  }

  export type AISolutionCreateOrConnectWithoutModulesInput = {
    where: AISolutionWhereUniqueInput
    create: XOR<AISolutionCreateWithoutModulesInput, AISolutionUncheckedCreateWithoutModulesInput>
  }

  export type AISolutionUpsertWithoutModulesInput = {
    update: XOR<AISolutionUpdateWithoutModulesInput, AISolutionUncheckedUpdateWithoutModulesInput>
    create: XOR<AISolutionCreateWithoutModulesInput, AISolutionUncheckedCreateWithoutModulesInput>
    where?: AISolutionWhereInput
  }

  export type AISolutionUpdateToOneWithWhereWithoutModulesInput = {
    where?: AISolutionWhereInput
    data: XOR<AISolutionUpdateWithoutModulesInput, AISolutionUncheckedUpdateWithoutModulesInput>
  }

  export type AISolutionUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    targetIndustries?: AISolutionUpdatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionUpdatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionUpdatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionUpdateintegrationPointsInput | string[]
    pricingModels?: AISolutionUpdatepricingModelsInput | string[]
    typicalTimelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    useCases?: AISolutionUpdateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUpdateManyWithoutSolutionNestedInput
    clientSolutions?: ClientSolutionUpdateManyWithoutSolutionNestedInput
  }

  export type AISolutionUncheckedUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    targetIndustries?: AISolutionUpdatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionUpdatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionUpdatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionUpdateintegrationPointsInput | string[]
    pricingModels?: AISolutionUpdatepricingModelsInput | string[]
    typicalTimelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    useCases?: AISolutionUpdateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUncheckedUpdateManyWithoutSolutionNestedInput
    clientSolutions?: ClientSolutionUncheckedUpdateManyWithoutSolutionNestedInput
  }

  export type AISolutionCreateWithoutQuotesInput = {
    id?: string
    name: string
    category: string
    description?: string | null
    tagline?: string | null
    longDescription?: string | null
    targetIndustries?: AISolutionCreatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionCreatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionCreatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionCreateintegrationPointsInput | string[]
    pricingModels?: AISolutionCreatepricingModelsInput | string[]
    typicalTimelineWeeks?: number | null
    useCases?: AISolutionCreateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: AISolutionModuleCreateNestedManyWithoutSolutionInput
    clientSolutions?: ClientSolutionCreateNestedManyWithoutSolutionInput
  }

  export type AISolutionUncheckedCreateWithoutQuotesInput = {
    id?: string
    name: string
    category: string
    description?: string | null
    tagline?: string | null
    longDescription?: string | null
    targetIndustries?: AISolutionCreatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionCreatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionCreatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionCreateintegrationPointsInput | string[]
    pricingModels?: AISolutionCreatepricingModelsInput | string[]
    typicalTimelineWeeks?: number | null
    useCases?: AISolutionCreateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: AISolutionModuleUncheckedCreateNestedManyWithoutSolutionInput
    clientSolutions?: ClientSolutionUncheckedCreateNestedManyWithoutSolutionInput
  }

  export type AISolutionCreateOrConnectWithoutQuotesInput = {
    where: AISolutionWhereUniqueInput
    create: XOR<AISolutionCreateWithoutQuotesInput, AISolutionUncheckedCreateWithoutQuotesInput>
  }

  export type AISolutionUpsertWithoutQuotesInput = {
    update: XOR<AISolutionUpdateWithoutQuotesInput, AISolutionUncheckedUpdateWithoutQuotesInput>
    create: XOR<AISolutionCreateWithoutQuotesInput, AISolutionUncheckedCreateWithoutQuotesInput>
    where?: AISolutionWhereInput
  }

  export type AISolutionUpdateToOneWithWhereWithoutQuotesInput = {
    where?: AISolutionWhereInput
    data: XOR<AISolutionUpdateWithoutQuotesInput, AISolutionUncheckedUpdateWithoutQuotesInput>
  }

  export type AISolutionUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    targetIndustries?: AISolutionUpdatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionUpdatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionUpdatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionUpdateintegrationPointsInput | string[]
    pricingModels?: AISolutionUpdatepricingModelsInput | string[]
    typicalTimelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    useCases?: AISolutionUpdateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: AISolutionModuleUpdateManyWithoutSolutionNestedInput
    clientSolutions?: ClientSolutionUpdateManyWithoutSolutionNestedInput
  }

  export type AISolutionUncheckedUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    targetIndustries?: AISolutionUpdatetargetIndustriesInput | string[]
    targetFunctions?: AISolutionUpdatetargetFunctionsInput | string[]
    technicalRequirements?: AISolutionUpdatetechnicalRequirementsInput | string[]
    integrationPoints?: AISolutionUpdateintegrationPointsInput | string[]
    pricingModels?: AISolutionUpdatepricingModelsInput | string[]
    typicalTimelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    useCases?: AISolutionUpdateuseCasesInput | string[]
    caseStudies?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: AISolutionModuleUncheckedUpdateManyWithoutSolutionNestedInput
    clientSolutions?: ClientSolutionUncheckedUpdateManyWithoutSolutionNestedInput
  }

  export type UserCreateWithoutActivitiesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutUsersInput
    managedBy?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagedByInput
    leads?: LeadCreateNestedManyWithoutOwnerInput
    opportunities?: OpportunityCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskCreateNestedManyWithoutAssigneeInput
    projectMilestones?: ProjectMilestoneCreateNestedManyWithoutOwnerInput
    tickets?: TicketCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    managerId?: string | null
    subordinates?: UserUncheckedCreateNestedManyWithoutManagedByInput
    leads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskUncheckedCreateNestedManyWithoutAssigneeInput
    projectMilestones?: ProjectMilestoneUncheckedCreateNestedManyWithoutOwnerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type LeadCreateWithoutActivitiesInput = {
    id?: string
    source: string
    sourceDetails?: string | null
    status?: $Enums.LeadStatus
    companyName: string
    contactName: string
    contactEmail: string
    contactPhone?: string | null
    industry?: string | null
    companySize?: string | null
    leadScore?: number
    scoreTier?: string
    scoreReason?: string | null
    budgetRange?: string | null
    timeline?: string | null
    needDescription?: string | null
    convertedAt?: Date | string | null
    lostAt?: Date | string | null
    lossReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutLeadsInput
    owner: UserCreateNestedOneWithoutLeadsInput
    opportunities?: OpportunityCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutActivitiesInput = {
    id?: string
    clientId?: string | null
    ownerId: string
    source: string
    sourceDetails?: string | null
    status?: $Enums.LeadStatus
    companyName: string
    contactName: string
    contactEmail: string
    contactPhone?: string | null
    industry?: string | null
    companySize?: string | null
    leadScore?: number
    scoreTier?: string
    scoreReason?: string | null
    budgetRange?: string | null
    timeline?: string | null
    needDescription?: string | null
    convertedAt?: Date | string | null
    lostAt?: Date | string | null
    lossReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutActivitiesInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutActivitiesInput, LeadUncheckedCreateWithoutActivitiesInput>
  }

  export type OpportunityCreateWithoutActivitiesInput = {
    id?: string
    name: string
    stage?: $Enums.OpportunityStage
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    estimatedValue?: number
    weightedValue?: number
    nextStep?: string | null
    nextStepDate?: Date | string | null
    lostReason?: string | null
    wonReason?: string | null
    solutionType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lead?: LeadCreateNestedOneWithoutOpportunitiesInput
    client?: ClientCreateNestedOneWithoutOpportunitiesInput
    owner: UserCreateNestedOneWithoutOpportunitiesInput
    proposals?: ProposalCreateNestedManyWithoutOpportunityInput
    project?: ProjectCreateNestedOneWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutActivitiesInput = {
    id?: string
    leadId?: string | null
    clientId?: string | null
    ownerId: string
    name: string
    stage?: $Enums.OpportunityStage
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    estimatedValue?: number
    weightedValue?: number
    nextStep?: string | null
    nextStepDate?: Date | string | null
    lostReason?: string | null
    wonReason?: string | null
    solutionType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proposals?: ProposalUncheckedCreateNestedManyWithoutOpportunityInput
    project?: ProjectUncheckedCreateNestedOneWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutActivitiesInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutActivitiesInput, OpportunityUncheckedCreateWithoutActivitiesInput>
  }

  export type ContactCreateWithoutActivitiesInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    jobTitle?: string | null
    isDecisionMaker?: boolean
    isInfluencer?: boolean
    isTechnicalLead?: boolean
    isEndUser?: boolean
    isBudgetHolder?: boolean
    influenceLevel?: number
    relationshipScore?: number
    lastInteraction?: Date | string | null
    preferredChannel?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateWithoutActivitiesInput = {
    id?: string
    clientId: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    jobTitle?: string | null
    isDecisionMaker?: boolean
    isInfluencer?: boolean
    isTechnicalLead?: boolean
    isEndUser?: boolean
    isBudgetHolder?: boolean
    influenceLevel?: number
    relationshipScore?: number
    lastInteraction?: Date | string | null
    preferredChannel?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateOrConnectWithoutActivitiesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutUsersNestedInput
    managedBy?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagedByNestedInput
    leads?: LeadUpdateManyWithoutOwnerNestedInput
    opportunities?: OpportunityUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUpdateManyWithoutAssigneeNestedInput
    projectMilestones?: ProjectMilestoneUpdateManyWithoutOwnerNestedInput
    tickets?: TicketUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    subordinates?: UserUncheckedUpdateManyWithoutManagedByNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    projectMilestones?: ProjectMilestoneUncheckedUpdateManyWithoutOwnerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type LeadUpsertWithoutActivitiesInput = {
    update: XOR<LeadUpdateWithoutActivitiesInput, LeadUncheckedUpdateWithoutActivitiesInput>
    create: XOR<LeadCreateWithoutActivitiesInput, LeadUncheckedCreateWithoutActivitiesInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutActivitiesInput, LeadUncheckedUpdateWithoutActivitiesInput>
  }

  export type LeadUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceDetails?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    leadScore?: IntFieldUpdateOperationsInput | number
    scoreTier?: StringFieldUpdateOperationsInput | string
    scoreReason?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    needDescription?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutLeadsNestedInput
    owner?: UserUpdateOneRequiredWithoutLeadsNestedInput
    opportunities?: OpportunityUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceDetails?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    leadScore?: IntFieldUpdateOperationsInput | number
    scoreTier?: StringFieldUpdateOperationsInput | string
    scoreReason?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    needDescription?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: OpportunityUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type OpportunityUpsertWithoutActivitiesInput = {
    update: XOR<OpportunityUpdateWithoutActivitiesInput, OpportunityUncheckedUpdateWithoutActivitiesInput>
    create: XOR<OpportunityCreateWithoutActivitiesInput, OpportunityUncheckedCreateWithoutActivitiesInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutActivitiesInput, OpportunityUncheckedUpdateWithoutActivitiesInput>
  }

  export type OpportunityUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneWithoutOpportunitiesNestedInput
    client?: ClientUpdateOneWithoutOpportunitiesNestedInput
    owner?: UserUpdateOneRequiredWithoutOpportunitiesNestedInput
    proposals?: ProposalUpdateManyWithoutOpportunityNestedInput
    project?: ProjectUpdateOneWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposals?: ProposalUncheckedUpdateManyWithoutOpportunityNestedInput
    project?: ProjectUncheckedUpdateOneWithoutOpportunityNestedInput
  }

  export type ContactUpsertWithoutActivitiesInput = {
    update: XOR<ContactUpdateWithoutActivitiesInput, ContactUncheckedUpdateWithoutActivitiesInput>
    create: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutActivitiesInput, ContactUncheckedUpdateWithoutActivitiesInput>
  }

  export type ContactUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    isInfluencer?: BoolFieldUpdateOperationsInput | boolean
    isTechnicalLead?: BoolFieldUpdateOperationsInput | boolean
    isEndUser?: BoolFieldUpdateOperationsInput | boolean
    isBudgetHolder?: BoolFieldUpdateOperationsInput | boolean
    influenceLevel?: IntFieldUpdateOperationsInput | number
    relationshipScore?: IntFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredChannel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    isInfluencer?: BoolFieldUpdateOperationsInput | boolean
    isTechnicalLead?: BoolFieldUpdateOperationsInput | boolean
    isEndUser?: BoolFieldUpdateOperationsInput | boolean
    isBudgetHolder?: BoolFieldUpdateOperationsInput | boolean
    influenceLevel?: IntFieldUpdateOperationsInput | number
    relationshipScore?: IntFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredChannel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateWithoutFeedbackInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutClientInput
    leads?: LeadCreateNestedManyWithoutClientInput
    opportunities?: OpportunityCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    tickets?: TicketCreateNestedManyWithoutClientInput
    aiSolutions?: ClientSolutionCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutFeedbackInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    tickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    aiSolutions?: ClientSolutionUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutFeedbackInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutFeedbackInput, ClientUncheckedCreateWithoutFeedbackInput>
  }

  export type ClientUpsertWithoutFeedbackInput = {
    update: XOR<ClientUpdateWithoutFeedbackInput, ClientUncheckedUpdateWithoutFeedbackInput>
    create: XOR<ClientCreateWithoutFeedbackInput, ClientUncheckedCreateWithoutFeedbackInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutFeedbackInput, ClientUncheckedUpdateWithoutFeedbackInput>
  }

  export type ClientUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutClientNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    opportunities?: OpportunityUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    tickets?: TicketUpdateManyWithoutClientNestedInput
    aiSolutions?: ClientSolutionUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    aiSolutions?: ClientSolutionUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutTicketsInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutClientInput
    leads?: LeadCreateNestedManyWithoutClientInput
    opportunities?: OpportunityCreateNestedManyWithoutClientInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    feedback?: FeedbackCreateNestedManyWithoutClientInput
    aiSolutions?: ClientSolutionCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutTicketsInput = {
    id?: string
    name: string
    legalName?: string | null
    industry?: string | null
    industryCode?: string | null
    size?: string | null
    revenueBand?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    phone?: string | null
    website?: string | null
    aiMaturityLevel?: string | null
    aiReadinessScore?: number | null
    technologyStack?: ClientCreatetechnologyStackInput | string[]
    lifecycleStage?: $Enums.ClientLifecycleStage
    healthScore?: number
    npsScore?: number | null
    accountExecutiveId?: string | null
    contractStartDate?: Date | string | null
    contractEndDate?: Date | string | null
    autoRenewal?: boolean
    renewalNoticeDays?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    leads?: LeadUncheckedCreateNestedManyWithoutClientInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutClientInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutClientInput
    aiSolutions?: ClientSolutionUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutTicketsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutTicketsInput, ClientUncheckedCreateWithoutTicketsInput>
  }

  export type UserCreateWithoutTicketsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutUsersInput
    managedBy?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagedByInput
    leads?: LeadCreateNestedManyWithoutOwnerInput
    opportunities?: OpportunityCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskCreateNestedManyWithoutAssigneeInput
    projectMilestones?: ProjectMilestoneCreateNestedManyWithoutOwnerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutTicketsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    managerId?: string | null
    subordinates?: UserUncheckedCreateNestedManyWithoutManagedByInput
    leads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskUncheckedCreateNestedManyWithoutAssigneeInput
    projectMilestones?: ProjectMilestoneUncheckedCreateNestedManyWithoutOwnerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
  }

  export type TicketCommentCreateWithoutTicketInput = {
    id?: string
    authorId: string
    content: string
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type TicketCommentUncheckedCreateWithoutTicketInput = {
    id?: string
    authorId: string
    content: string
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type TicketCommentCreateOrConnectWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    create: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput>
  }

  export type TicketCommentCreateManyTicketInputEnvelope = {
    data: TicketCommentCreateManyTicketInput | TicketCommentCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutTicketsInput = {
    update: XOR<ClientUpdateWithoutTicketsInput, ClientUncheckedUpdateWithoutTicketsInput>
    create: XOR<ClientCreateWithoutTicketsInput, ClientUncheckedCreateWithoutTicketsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutTicketsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutTicketsInput, ClientUncheckedUpdateWithoutTicketsInput>
  }

  export type ClientUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutClientNestedInput
    leads?: LeadUpdateManyWithoutClientNestedInput
    opportunities?: OpportunityUpdateManyWithoutClientNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    feedback?: FeedbackUpdateManyWithoutClientNestedInput
    aiSolutions?: ClientSolutionUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    industryCode?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    revenueBand?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    aiMaturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    aiReadinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyStack?: ClientUpdatetechnologyStackInput | string[]
    lifecycleStage?: EnumClientLifecycleStageFieldUpdateOperationsInput | $Enums.ClientLifecycleStage
    healthScore?: IntFieldUpdateOperationsInput | number
    npsScore?: NullableIntFieldUpdateOperationsInput | number | null
    accountExecutiveId?: NullableStringFieldUpdateOperationsInput | string | null
    contractStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalNoticeDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    leads?: LeadUncheckedUpdateManyWithoutClientNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutClientNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutClientNestedInput
    aiSolutions?: ClientSolutionUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutTicketsInput = {
    update: XOR<UserUpdateWithoutTicketsInput, UserUncheckedUpdateWithoutTicketsInput>
    create: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketsInput, UserUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutUsersNestedInput
    managedBy?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagedByNestedInput
    leads?: LeadUpdateManyWithoutOwnerNestedInput
    opportunities?: OpportunityUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUpdateManyWithoutAssigneeNestedInput
    projectMilestones?: ProjectMilestoneUpdateManyWithoutOwnerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    subordinates?: UserUncheckedUpdateManyWithoutManagedByNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    projectMilestones?: ProjectMilestoneUncheckedUpdateManyWithoutOwnerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type TicketCommentUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    update: XOR<TicketCommentUpdateWithoutTicketInput, TicketCommentUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput>
  }

  export type TicketCommentUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    data: XOR<TicketCommentUpdateWithoutTicketInput, TicketCommentUncheckedUpdateWithoutTicketInput>
  }

  export type TicketCommentUpdateManyWithWhereWithoutTicketInput = {
    where: TicketCommentScalarWhereInput
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketCommentScalarWhereInput = {
    AND?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
    OR?: TicketCommentScalarWhereInput[]
    NOT?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
    id?: StringFilter<"TicketComment"> | string
    ticketId?: StringFilter<"TicketComment"> | string
    authorId?: StringFilter<"TicketComment"> | string
    content?: StringFilter<"TicketComment"> | string
    isInternal?: BoolFilter<"TicketComment"> | boolean
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
  }

  export type TicketCreateWithoutCommentsInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    type?: $Enums.TicketType
    severity?: $Enums.TicketSeverity
    status?: $Enums.TicketStatus
    resolution?: string | null
    rootCause?: string | null
    slaResponseDue?: Date | string | null
    slaResolutionDue?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutTicketsInput
    assignee?: UserCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutCommentsInput = {
    id?: string
    clientId: string
    assigneeId?: string | null
    ticketNumber: string
    title: string
    description: string
    type?: $Enums.TicketType
    severity?: $Enums.TicketSeverity
    status?: $Enums.TicketStatus
    resolution?: string | null
    rootCause?: string | null
    slaResponseDue?: Date | string | null
    slaResolutionDue?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateOrConnectWithoutCommentsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
  }

  export type TicketUpsertWithoutCommentsInput = {
    update: XOR<TicketUpdateWithoutCommentsInput, TicketUncheckedUpdateWithoutCommentsInput>
    create: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutCommentsInput, TicketUncheckedUpdateWithoutCommentsInput>
  }

  export type TicketUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    severity?: EnumTicketSeverityFieldUpdateOperationsInput | $Enums.TicketSeverity
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolutionDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutTicketsNestedInput
    assignee?: UserUpdateOneWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    severity?: EnumTicketSeverityFieldUpdateOperationsInput | $Enums.TicketSeverity
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolutionDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutUsersInput
    managedBy?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagedByInput
    leads?: LeadCreateNestedManyWithoutOwnerInput
    opportunities?: OpportunityCreateNestedManyWithoutOwnerInput
    activities?: ActivityCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskCreateNestedManyWithoutAssigneeInput
    projectMilestones?: ProjectMilestoneCreateNestedManyWithoutOwnerInput
    tickets?: TicketCreateNestedManyWithoutAssigneeInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    managerId?: string | null
    subordinates?: UserUncheckedCreateNestedManyWithoutManagedByInput
    leads?: LeadUncheckedCreateNestedManyWithoutOwnerInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOwnerInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOwnerInput
    projectTasks?: ProjectTaskUncheckedCreateNestedManyWithoutAssigneeInput
    projectMilestones?: ProjectMilestoneUncheckedCreateNestedManyWithoutOwnerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAssigneeInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutUsersNestedInput
    managedBy?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagedByNestedInput
    leads?: LeadUpdateManyWithoutOwnerNestedInput
    opportunities?: OpportunityUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUpdateManyWithoutAssigneeNestedInput
    projectMilestones?: ProjectMilestoneUpdateManyWithoutOwnerNestedInput
    tickets?: TicketUpdateManyWithoutAssigneeNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    subordinates?: UserUncheckedUpdateManyWithoutManagedByNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    projectMilestones?: ProjectMilestoneUncheckedUpdateManyWithoutOwnerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAssigneeNestedInput
  }

  export type UserCreateManyManagedByInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
  }

  export type LeadCreateManyOwnerInput = {
    id?: string
    clientId?: string | null
    source: string
    sourceDetails?: string | null
    status?: $Enums.LeadStatus
    companyName: string
    contactName: string
    contactEmail: string
    contactPhone?: string | null
    industry?: string | null
    companySize?: string | null
    leadScore?: number
    scoreTier?: string
    scoreReason?: string | null
    budgetRange?: string | null
    timeline?: string | null
    needDescription?: string | null
    convertedAt?: Date | string | null
    lostAt?: Date | string | null
    lossReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityCreateManyOwnerInput = {
    id?: string
    leadId?: string | null
    clientId?: string | null
    name: string
    stage?: $Enums.OpportunityStage
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    estimatedValue?: number
    weightedValue?: number
    nextStep?: string | null
    nextStepDate?: Date | string | null
    lostReason?: string | null
    wonReason?: string | null
    solutionType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateManyOwnerInput = {
    id?: string
    leadId?: string | null
    opportunityId?: string | null
    contactId?: string | null
    type: string
    subject: string
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    durationMinutes?: number | null
    outcome?: string | null
    sentiment?: string | null
    keyTopics?: ActivityCreatekeyTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTaskCreateManyAssigneeInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: string
    phase?: string | null
    parentTaskId?: string | null
    plannedHours?: number | null
    actualHours?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    blockerReason?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMilestoneCreateManyOwnerInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    status?: $Enums.MilestoneStatus
    phase?: string | null
    order: number
    plannedStartDate?: Date | string | null
    plannedEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    completionCriteria?: string | null
    dependsOnId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateManyAssigneeInput = {
    id?: string
    clientId: string
    ticketNumber: string
    title: string
    description: string
    type?: $Enums.TicketType
    severity?: $Enums.TicketSeverity
    status?: $Enums.TicketStatus
    resolution?: string | null
    rootCause?: string | null
    slaResponseDue?: Date | string | null
    slaResolutionDue?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyAuthorInput = {
    id?: string
    entityType: string
    entityId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutManagedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutUsersNestedInput
    subordinates?: UserUpdateManyWithoutManagedByNestedInput
    leads?: LeadUpdateManyWithoutOwnerNestedInput
    opportunities?: OpportunityUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUpdateManyWithoutAssigneeNestedInput
    projectMilestones?: ProjectMilestoneUpdateManyWithoutOwnerNestedInput
    tickets?: TicketUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutManagedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    subordinates?: UserUncheckedUpdateManyWithoutManagedByNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    projectMilestones?: ProjectMilestoneUncheckedUpdateManyWithoutOwnerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateManyWithoutManagedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceDetails?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    leadScore?: IntFieldUpdateOperationsInput | number
    scoreTier?: StringFieldUpdateOperationsInput | string
    scoreReason?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    needDescription?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutLeadsNestedInput
    activities?: ActivityUpdateManyWithoutLeadNestedInput
    opportunities?: OpportunityUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    sourceDetails?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    leadScore?: IntFieldUpdateOperationsInput | number
    scoreTier?: StringFieldUpdateOperationsInput | string
    scoreReason?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    needDescription?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutLeadNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    sourceDetails?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    leadScore?: IntFieldUpdateOperationsInput | number
    scoreTier?: StringFieldUpdateOperationsInput | string
    scoreReason?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    needDescription?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneWithoutOpportunitiesNestedInput
    client?: ClientUpdateOneWithoutOpportunitiesNestedInput
    activities?: ActivityUpdateManyWithoutOpportunityNestedInput
    proposals?: ProposalUpdateManyWithoutOpportunityNestedInput
    project?: ProjectUpdateOneWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutOpportunityNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutOpportunityNestedInput
    project?: ProjectUncheckedUpdateOneWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    keyTopics?: ActivityUpdatekeyTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneWithoutActivitiesNestedInput
    opportunity?: OpportunityUpdateOneWithoutActivitiesNestedInput
    contact?: ContactUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    keyTopics?: ActivityUpdatekeyTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    keyTopics?: ActivityUpdatekeyTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTaskUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: StringFieldUpdateOperationsInput | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: FloatFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
  }

  export type ProjectTaskUncheckedUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: StringFieldUpdateOperationsInput | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: FloatFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTaskUncheckedUpdateManyWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: StringFieldUpdateOperationsInput | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: FloatFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMilestoneUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMilestonesNestedInput
  }

  export type ProjectMilestoneUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMilestoneUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    severity?: EnumTicketSeverityFieldUpdateOperationsInput | $Enums.TicketSeverity
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolutionDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutTicketsNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    severity?: EnumTicketSeverityFieldUpdateOperationsInput | $Enums.TicketSeverity
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolutionDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    severity?: EnumTicketSeverityFieldUpdateOperationsInput | $Enums.TicketSeverity
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolutionDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateManyClientInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    jobTitle?: string | null
    isDecisionMaker?: boolean
    isInfluencer?: boolean
    isTechnicalLead?: boolean
    isEndUser?: boolean
    isBudgetHolder?: boolean
    influenceLevel?: number
    relationshipScore?: number
    lastInteraction?: Date | string | null
    preferredChannel?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCreateManyClientInput = {
    id?: string
    ownerId: string
    source: string
    sourceDetails?: string | null
    status?: $Enums.LeadStatus
    companyName: string
    contactName: string
    contactEmail: string
    contactPhone?: string | null
    industry?: string | null
    companySize?: string | null
    leadScore?: number
    scoreTier?: string
    scoreReason?: string | null
    budgetRange?: string | null
    timeline?: string | null
    needDescription?: string | null
    convertedAt?: Date | string | null
    lostAt?: Date | string | null
    lossReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityCreateManyClientInput = {
    id?: string
    leadId?: string | null
    ownerId: string
    name: string
    stage?: $Enums.OpportunityStage
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    estimatedValue?: number
    weightedValue?: number
    nextStep?: string | null
    nextStepDate?: Date | string | null
    lostReason?: string | null
    wonReason?: string | null
    solutionType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateManyClientInput = {
    id?: string
    opportunityId?: string | null
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    budget?: number
    actualCost?: number
    projectManagerId?: string | null
    solutionType?: string | null
    healthStatus?: string
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateManyClientInput = {
    id?: string
    assigneeId?: string | null
    ticketNumber: string
    title: string
    description: string
    type?: $Enums.TicketType
    severity?: $Enums.TicketSeverity
    status?: $Enums.TicketStatus
    resolution?: string | null
    rootCause?: string | null
    slaResponseDue?: Date | string | null
    slaResolutionDue?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackCreateManyClientInput = {
    id?: string
    projectId?: string | null
    milestoneId?: string | null
    type: string
    rating: number
    comments?: string | null
    deliveredOnTime?: boolean | null
    metExpectations?: boolean | null
    wouldRecommend?: boolean | null
    responderName?: string | null
    responderEmail?: string | null
    createdAt?: Date | string
  }

  export type ClientSolutionCreateManyClientInput = {
    id?: string
    solutionId: string
    deployedAt?: Date | string | null
    status?: string
  }

  export type UserCreateManyClientInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
  }

  export type ContactUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    isInfluencer?: BoolFieldUpdateOperationsInput | boolean
    isTechnicalLead?: BoolFieldUpdateOperationsInput | boolean
    isEndUser?: BoolFieldUpdateOperationsInput | boolean
    isBudgetHolder?: BoolFieldUpdateOperationsInput | boolean
    influenceLevel?: IntFieldUpdateOperationsInput | number
    relationshipScore?: IntFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredChannel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    isInfluencer?: BoolFieldUpdateOperationsInput | boolean
    isTechnicalLead?: BoolFieldUpdateOperationsInput | boolean
    isEndUser?: BoolFieldUpdateOperationsInput | boolean
    isBudgetHolder?: BoolFieldUpdateOperationsInput | boolean
    influenceLevel?: IntFieldUpdateOperationsInput | number
    relationshipScore?: IntFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredChannel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    isInfluencer?: BoolFieldUpdateOperationsInput | boolean
    isTechnicalLead?: BoolFieldUpdateOperationsInput | boolean
    isEndUser?: BoolFieldUpdateOperationsInput | boolean
    isBudgetHolder?: BoolFieldUpdateOperationsInput | boolean
    influenceLevel?: IntFieldUpdateOperationsInput | number
    relationshipScore?: IntFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredChannel?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceDetails?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    leadScore?: IntFieldUpdateOperationsInput | number
    scoreTier?: StringFieldUpdateOperationsInput | string
    scoreReason?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    needDescription?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutLeadsNestedInput
    activities?: ActivityUpdateManyWithoutLeadNestedInput
    opportunities?: OpportunityUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceDetails?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    leadScore?: IntFieldUpdateOperationsInput | number
    scoreTier?: StringFieldUpdateOperationsInput | string
    scoreReason?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    needDescription?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutLeadNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceDetails?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    leadScore?: IntFieldUpdateOperationsInput | number
    scoreTier?: StringFieldUpdateOperationsInput | string
    scoreReason?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    needDescription?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneWithoutOpportunitiesNestedInput
    owner?: UserUpdateOneRequiredWithoutOpportunitiesNestedInput
    activities?: ActivityUpdateManyWithoutOpportunityNestedInput
    proposals?: ProposalUpdateManyWithoutOpportunityNestedInput
    project?: ProjectUpdateOneWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutOpportunityNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutOpportunityNestedInput
    project?: ProjectUncheckedUpdateOneWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualCost?: FloatFieldUpdateOperationsInput | number
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    healthStatus?: StringFieldUpdateOperationsInput | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunity?: OpportunityUpdateOneWithoutProjectNestedInput
    milestones?: ProjectMilestoneUpdateManyWithoutProjectNestedInput
    tasks?: ProjectTaskUpdateManyWithoutProjectNestedInput
    metrics?: ProjectMetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualCost?: FloatFieldUpdateOperationsInput | number
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    healthStatus?: StringFieldUpdateOperationsInput | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: ProjectMilestoneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: ProjectTaskUncheckedUpdateManyWithoutProjectNestedInput
    metrics?: ProjectMetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualCost?: FloatFieldUpdateOperationsInput | number
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    healthStatus?: StringFieldUpdateOperationsInput | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    severity?: EnumTicketSeverityFieldUpdateOperationsInput | $Enums.TicketSeverity
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolutionDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignee?: UserUpdateOneWithoutTicketsNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    severity?: EnumTicketSeverityFieldUpdateOperationsInput | $Enums.TicketSeverity
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolutionDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    severity?: EnumTicketSeverityFieldUpdateOperationsInput | $Enums.TicketSeverity
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolutionDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    milestoneId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metExpectations?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responderName?: NullableStringFieldUpdateOperationsInput | string | null
    responderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    milestoneId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metExpectations?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responderName?: NullableStringFieldUpdateOperationsInput | string | null
    responderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    milestoneId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metExpectations?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responderName?: NullableStringFieldUpdateOperationsInput | string | null
    responderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSolutionUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    solution?: AISolutionUpdateOneRequiredWithoutClientSolutionsNestedInput
  }

  export type ClientSolutionUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    solutionId?: StringFieldUpdateOperationsInput | string
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ClientSolutionUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    solutionId?: StringFieldUpdateOperationsInput | string
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managedBy?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagedByNestedInput
    leads?: LeadUpdateManyWithoutOwnerNestedInput
    opportunities?: OpportunityUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUpdateManyWithoutAssigneeNestedInput
    projectMilestones?: ProjectMilestoneUpdateManyWithoutOwnerNestedInput
    tickets?: TicketUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    subordinates?: UserUncheckedUpdateManyWithoutManagedByNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOwnerNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOwnerNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOwnerNestedInput
    projectTasks?: ProjectTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    projectMilestones?: ProjectMilestoneUncheckedUpdateManyWithoutOwnerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityCreateManyContactInput = {
    id?: string
    ownerId: string
    leadId?: string | null
    opportunityId?: string | null
    type: string
    subject: string
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    durationMinutes?: number | null
    outcome?: string | null
    sentiment?: string | null
    keyTopics?: ActivityCreatekeyTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    keyTopics?: ActivityUpdatekeyTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    lead?: LeadUpdateOneWithoutActivitiesNestedInput
    opportunity?: OpportunityUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    keyTopics?: ActivityUpdatekeyTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    keyTopics?: ActivityUpdatekeyTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyLeadInput = {
    id?: string
    ownerId: string
    opportunityId?: string | null
    contactId?: string | null
    type: string
    subject: string
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    durationMinutes?: number | null
    outcome?: string | null
    sentiment?: string | null
    keyTopics?: ActivityCreatekeyTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityCreateManyLeadInput = {
    id?: string
    clientId?: string | null
    ownerId: string
    name: string
    stage?: $Enums.OpportunityStage
    probability?: number
    expectedCloseDate?: Date | string | null
    actualCloseDate?: Date | string | null
    estimatedValue?: number
    weightedValue?: number
    nextStep?: string | null
    nextStepDate?: Date | string | null
    lostReason?: string | null
    wonReason?: string | null
    solutionType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    keyTopics?: ActivityUpdatekeyTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    opportunity?: OpportunityUpdateOneWithoutActivitiesNestedInput
    contact?: ContactUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    keyTopics?: ActivityUpdatekeyTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    keyTopics?: ActivityUpdatekeyTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutOpportunitiesNestedInput
    owner?: UserUpdateOneRequiredWithoutOpportunitiesNestedInput
    activities?: ActivityUpdateManyWithoutOpportunityNestedInput
    proposals?: ProposalUpdateManyWithoutOpportunityNestedInput
    project?: ProjectUpdateOneWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutOpportunityNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutOpportunityNestedInput
    project?: ProjectUncheckedUpdateOneWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: EnumOpportunityStageFieldUpdateOperationsInput | $Enums.OpportunityStage
    probability?: IntFieldUpdateOperationsInput | number
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedValue?: FloatFieldUpdateOperationsInput | number
    weightedValue?: FloatFieldUpdateOperationsInput | number
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostReason?: NullableStringFieldUpdateOperationsInput | string | null
    wonReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyOpportunityInput = {
    id?: string
    ownerId: string
    leadId?: string | null
    contactId?: string | null
    type: string
    subject: string
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    durationMinutes?: number | null
    outcome?: string | null
    sentiment?: string | null
    keyTopics?: ActivityCreatekeyTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalCreateManyOpportunityInput = {
    id?: string
    version?: number
    title: string
    content?: NullableJsonNullValueInput | InputJsonValue
    solutionDescription?: string | null
    implementationPlan?: string | null
    timelineWeeks?: number | null
    basePrice?: number
    discount?: number
    finalPrice?: number
    terms?: string | null
    status?: string
    approvalStatus?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    signedAt?: Date | string | null
    documentUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    keyTopics?: ActivityUpdatekeyTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    lead?: LeadUpdateOneWithoutActivitiesNestedInput
    contact?: ContactUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    keyTopics?: ActivityUpdatekeyTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    keyTopics?: ActivityUpdatekeyTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    implementationPlan?: NullableStringFieldUpdateOperationsInput | string | null
    timelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    implementationPlan?: NullableStringFieldUpdateOperationsInput | string | null
    timelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalUncheckedUpdateManyWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    implementationPlan?: NullableStringFieldUpdateOperationsInput | string | null
    timelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMilestoneCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.MilestoneStatus
    phase?: string | null
    order: number
    plannedStartDate?: Date | string | null
    plannedEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    completionCriteria?: string | null
    ownerId?: string | null
    dependsOnId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTaskCreateManyProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: string
    phase?: string | null
    assigneeId?: string | null
    parentTaskId?: string | null
    plannedHours?: number | null
    actualHours?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    blockerReason?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMetricCreateManyProjectInput = {
    id?: string
    metricName: string
    metricCategory: string
    value: number
    unit?: string | null
    baselineValue?: number | null
    targetValue?: number | null
    recordedAt?: Date | string
  }

  export type ProjectMilestoneUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutProjectMilestonesNestedInput
  }

  export type ProjectMilestoneUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMilestoneUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTaskUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: StringFieldUpdateOperationsInput | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: FloatFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignee?: UserUpdateOneWithoutProjectTasksNestedInput
  }

  export type ProjectTaskUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: StringFieldUpdateOperationsInput | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: FloatFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTaskUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: StringFieldUpdateOperationsInput | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: FloatFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMetricUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricCategory?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMetricUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricCategory?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMetricUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricCategory?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AISolutionModuleCreateManySolutionInput = {
    id?: string
    name: string
    description?: string | null
    basePrice?: number
    isOptional?: boolean
  }

  export type QuoteCreateManySolutionInput = {
    id?: string
    clientId?: string | null
    quoteNumber: string
    version?: number
    status?: string
    scope?: string | null
    timelineWeeks?: number | null
    totalPrice?: number
    validUntil?: Date | string | null
    requestedBy?: string | null
    requestedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientSolutionCreateManySolutionInput = {
    id?: string
    clientId: string
    deployedAt?: Date | string | null
    status?: string
  }

  export type AISolutionModuleUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isOptional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AISolutionModuleUncheckedUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isOptional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AISolutionModuleUncheckedUpdateManyWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isOptional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuoteUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    timelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUncheckedUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    timelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUncheckedUpdateManyWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteNumber?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    timelineWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSolutionUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    client?: ClientUpdateOneRequiredWithoutAiSolutionsNestedInput
  }

  export type ClientSolutionUncheckedUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ClientSolutionUncheckedUpdateManyWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TicketCommentCreateManyTicketInput = {
    id?: string
    authorId: string
    content: string
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type TicketCommentUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientCountOutputTypeDefaultArgs instead
     */
    export type ClientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactCountOutputTypeDefaultArgs instead
     */
    export type ContactCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeadCountOutputTypeDefaultArgs instead
     */
    export type LeadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OpportunityCountOutputTypeDefaultArgs instead
     */
    export type OpportunityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OpportunityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AISolutionCountOutputTypeDefaultArgs instead
     */
    export type AISolutionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AISolutionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketCountOutputTypeDefaultArgs instead
     */
    export type TicketCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientDefaultArgs instead
     */
    export type ClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientSolutionDefaultArgs instead
     */
    export type ClientSolutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientSolutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactDefaultArgs instead
     */
    export type ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeadDefaultArgs instead
     */
    export type LeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OpportunityDefaultArgs instead
     */
    export type OpportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OpportunityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProposalDefaultArgs instead
     */
    export type ProposalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProposalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectMilestoneDefaultArgs instead
     */
    export type ProjectMilestoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectMilestoneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectTaskDefaultArgs instead
     */
    export type ProjectTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectTaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectMetricDefaultArgs instead
     */
    export type ProjectMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AISolutionDefaultArgs instead
     */
    export type AISolutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AISolutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AISolutionModuleDefaultArgs instead
     */
    export type AISolutionModuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AISolutionModuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuoteDefaultArgs instead
     */
    export type QuoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityDefaultArgs instead
     */
    export type ActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedbackDefaultArgs instead
     */
    export type FeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketDefaultArgs instead
     */
    export type TicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketCommentDefaultArgs instead
     */
    export type TicketCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefreshTokenDefaultArgs instead
     */
    export type RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefreshTokenDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}